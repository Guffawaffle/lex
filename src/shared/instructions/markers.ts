/**
 * Marker System for Lex-generated content
 *
 * Implements LEX:BEGIN/END markers for idempotent updates to host-specific
 * instruction files. Human content outside markers is preserved exactly.
 */

/**
 * Marker constants - exact strings used in instruction files
 */
export const LEX_BEGIN = "<!-- LEX:BEGIN -->";
export const LEX_END = "<!-- LEX:END -->";

/**
 * Header comment added after LEX:BEGIN
 */
const LEX_HEADER =
  "<!-- This block is auto-generated by `lex instructions generate`. Do not edit manually. -->";

/**
 * Result of extracting marked content from a file
 */
export interface ExtractResult {
  /** Content before the LEX:BEGIN marker (empty string if at start) */
  before: string;
  /** Content between markers, or null if no markers found */
  lex: string | null;
  /** Content after the LEX:END marker (empty string if at end) */
  after: string;
  /** Whether valid markers were found */
  hasMarkers: boolean;
}

/**
 * Wrap content with LEX:BEGIN/END markers
 *
 * @param content - The Lex-generated content to wrap
 * @returns Content wrapped with markers and header comment
 *
 * @example
 * ```ts
 * const wrapped = wrapWithMarkers("## Lex Section\nContent here");
 * // Returns:
 * // <!-- LEX:BEGIN -->
 * // <!-- This block is auto-generated... -->
 * //
 * // ## Lex Section
 * // Content here
 * //
 * // <!-- LEX:END -->
 * ```
 */
export function wrapWithMarkers(content: string): string {
  const trimmedContent = content.trim();
  return `${LEX_BEGIN}\n${LEX_HEADER}\n\n${trimmedContent}\n\n${LEX_END}`;
}

/**
 * Extract marked content from a file, preserving human sections
 *
 * @param fileContent - Full content of the file
 * @returns Object with before, lex (if found), and after sections
 *
 * @example
 * ```ts
 * const result = extractMarkedContent(fileContent);
 * if (result.hasMarkers) {
 *   console.log("Lex section:", result.lex);
 *   console.log("Human content preserved:", result.before + result.after);
 * }
 * ```
 */
export function extractMarkedContent(fileContent: string): ExtractResult {
  const beginIndex = fileContent.indexOf(LEX_BEGIN);
  const endIndex = fileContent.indexOf(LEX_END);

  // No markers found
  if (beginIndex === -1 || endIndex === -1) {
    return {
      before: fileContent,
      lex: null,
      after: "",
      hasMarkers: false,
    };
  }

  // Malformed: END before BEGIN
  if (endIndex < beginIndex) {
    return {
      before: fileContent,
      lex: null,
      after: "",
      hasMarkers: false,
    };
  }

  // Extract sections
  const before = fileContent.slice(0, beginIndex);
  const lexContent = fileContent.slice(beginIndex + LEX_BEGIN.length, endIndex).trim();
  const after = fileContent.slice(endIndex + LEX_END.length);

  return {
    before,
    lex: lexContent,
    after,
    hasMarkers: true,
  };
}

/**
 * Replace marked content in a file, preserving human sections
 *
 * If no markers exist, appends the new content at the end of the file.
 *
 * @param fileContent - Current file content
 * @param newLexContent - New Lex-generated content (without markers)
 * @returns Updated file content with new Lex section
 *
 * @example
 * ```ts
 * // Update existing marked section
 * const updated = replaceMarkedContent(existingFile, "## Updated Lex\nNew content");
 *
 * // Append to file without markers
 * const appended = replaceMarkedContent(noMarkersFile, "## Lex Section\nContent");
 * ```
 */
export function replaceMarkedContent(fileContent: string, newLexContent: string): string {
  const extracted = extractMarkedContent(fileContent);
  const wrappedNew = wrapWithMarkers(newLexContent);

  if (extracted.hasMarkers) {
    // Replace existing marked section
    // Preserve whitespace: before might end with newlines, after might start with newlines
    const normalizedBefore = extracted.before.replace(/\n+$/, "");
    const normalizedAfter = extracted.after.replace(/^\n+/, "");

    // Build result with proper spacing
    let result = "";
    if (normalizedBefore) {
      result += normalizedBefore + "\n\n";
    }
    result += wrappedNew;
    if (normalizedAfter) {
      result += "\n\n" + normalizedAfter;
    }
    return result;
  } else {
    // No markers: append at end
    const normalizedContent = fileContent.replace(/\n+$/, "");
    if (normalizedContent) {
      return normalizedContent + "\n\n" + wrappedNew + "\n";
    } else {
      return wrappedNew + "\n";
    }
  }
}

/**
 * Check if content appears to have valid Lex markers
 *
 * @param content - File content to check
 * @returns True if both BEGIN and END markers are present in correct order
 */
export function hasValidMarkers(content: string): boolean {
  const beginIndex = content.indexOf(LEX_BEGIN);
  const endIndex = content.indexOf(LEX_END);
  return beginIndex !== -1 && endIndex !== -1 && beginIndex < endIndex;
}
