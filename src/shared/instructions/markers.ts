/**
 * Marker System for Lex-generated content
 *
 * Implements LEX:BEGIN/END markers for idempotent updates to host-specific
 * instruction files. Human content outside markers is preserved exactly.
 */

/**
 * Marker constants - exact strings used in instruction files
 */
export const LEX_BEGIN = "<!-- LEX:BEGIN -->";
export const LEX_END = "<!-- LEX:END -->";

/**
 * Regex patterns for flexible marker detection
 * These match variant formats like:
 * - <!-- LEX:BEGIN -->
 * - <!-- LEX:BEGIN - comment -->
 * - <!--LEX:BEGIN-->
 * - <!--  LEX:BEGIN  -->
 */
const LEX_BEGIN_PATTERN = /<!--\s*LEX:BEGIN\s*(?:-[^>]*)?\s*-->/;
const LEX_END_PATTERN = /<!--\s*LEX:END\s*(?:-[^>]*)?\s*-->/;

/**
 * Header comment added after LEX:BEGIN
 */
const LEX_HEADER =
  "<!-- This block is auto-generated by `lex instructions generate`. Do not edit manually. -->";

/**
 * Result of extracting marked content from a file
 */
export interface ExtractResult {
  /** Content before the LEX:BEGIN marker (empty string if at start) */
  before: string;
  /** Content between markers, or null if no markers found */
  lex: string | null;
  /** Content after the LEX:END marker (empty string if at end) */
  after: string;
  /** Whether valid markers were found */
  hasMarkers: boolean;
  /** Whether variant (non-standard) markers were detected */
  hasVariantMarkers?: boolean;
  /** The actual BEGIN marker found (for diagnostics) */
  foundBeginMarker?: string;
  /** The actual END marker found (for diagnostics) */
  foundEndMarker?: string;
}

/**
 * Wrap content with LEX:BEGIN/END markers
 *
 * @param content - The Lex-generated content to wrap
 * @returns Content wrapped with markers and header comment
 *
 * @example
 * ```ts
 * const wrapped = wrapWithMarkers("## Lex Section\nContent here");
 * // Returns:
 * // <!-- LEX:BEGIN -->
 * // <!-- This block is auto-generated... -->
 * //
 * // ## Lex Section
 * // Content here
 * //
 * // <!-- LEX:END -->
 * ```
 */
export function wrapWithMarkers(content: string): string {
  const trimmedContent = content.trim();
  return `${LEX_BEGIN}\n${LEX_HEADER}\n\n${trimmedContent}\n\n${LEX_END}`;
}

/**
 * Extract marked content from a file, preserving human sections
 *
 * Supports both standard markers and variant formats:
 * - Standard: `<!-- LEX:BEGIN -->` and `<!-- LEX:END -->`
 * - Variant: `<!-- LEX:BEGIN - comment -->`, `<!--LEX:BEGIN-->`, etc.
 *
 * @param fileContent - Full content of the file
 * @returns Object with before, lex (if found), and after sections
 *
 * @example
 * ```ts
 * const result = extractMarkedContent(fileContent);
 * if (result.hasMarkers) {
 *   console.log("Lex section:", result.lex);
 *   console.log("Human content preserved:", result.before + result.after);
 *   if (result.hasVariantMarkers) {
 *     console.warn("Non-standard markers detected, will be normalized on next generate");
 *   }
 * }
 * ```
 */
export function extractMarkedContent(fileContent: string): ExtractResult {
  // First try exact match (fast path)
  let beginIndex = fileContent.indexOf(LEX_BEGIN);
  let endIndex = fileContent.indexOf(LEX_END);
  let foundBeginMarker = LEX_BEGIN;
  let foundEndMarker = LEX_END;
  let hasVariantMarkers = false;

  // If exact match fails, try regex patterns
  if (beginIndex === -1 || endIndex === -1) {
    const beginMatch = fileContent.match(LEX_BEGIN_PATTERN);
    const endMatch = fileContent.match(LEX_END_PATTERN);

    if (beginMatch && endMatch) {
      beginIndex = beginMatch.index!;
      endIndex = endMatch.index!;
      foundBeginMarker = beginMatch[0];
      foundEndMarker = endMatch[0];
      hasVariantMarkers = true;
    }
  }

  // No markers found
  if (beginIndex === -1 || endIndex === -1) {
    return {
      before: fileContent,
      lex: null,
      after: "",
      hasMarkers: false,
    };
  }

  // Malformed: END before BEGIN
  if (endIndex < beginIndex) {
    return {
      before: fileContent,
      lex: null,
      after: "",
      hasMarkers: false,
    };
  }

  // Extract sections
  const before = fileContent.slice(0, beginIndex);
  const lexContent = fileContent.slice(beginIndex + foundBeginMarker.length, endIndex).trim();
  const after = fileContent.slice(endIndex + foundEndMarker.length);

  return {
    before,
    lex: lexContent,
    after,
    hasMarkers: true,
    hasVariantMarkers,
    foundBeginMarker,
    foundEndMarker,
  };
}

/**
 * Replace marked content in a file, preserving human sections
 *
 * If no markers exist, appends the new content at the end of the file.
 *
 * @param fileContent - Current file content
 * @param newLexContent - New Lex-generated content (without markers)
 * @returns Updated file content with new Lex section
 *
 * @example
 * ```ts
 * // Update existing marked section
 * const updated = replaceMarkedContent(existingFile, "## Updated Lex\nNew content");
 *
 * // Append to file without markers
 * const appended = replaceMarkedContent(noMarkersFile, "## Lex Section\nContent");
 * ```
 */
export function replaceMarkedContent(fileContent: string, newLexContent: string): string {
  const extracted = extractMarkedContent(fileContent);
  const wrappedNew = wrapWithMarkers(newLexContent);

  if (extracted.hasMarkers) {
    // Replace existing marked section
    // Preserve whitespace: before might end with newlines, after might start with newlines
    const normalizedBefore = extracted.before.replace(/\n+$/, "");
    const normalizedAfter = extracted.after.replace(/^\n+/, "");

    // Build result with proper spacing
    let result = "";
    if (normalizedBefore) {
      result += normalizedBefore + "\n\n";
    }
    result += wrappedNew;
    if (normalizedAfter) {
      result += "\n\n" + normalizedAfter;
    }
    return result;
  } else {
    // No markers: append at end
    const normalizedContent = fileContent.replace(/\n+$/, "");
    if (normalizedContent) {
      return normalizedContent + "\n\n" + wrappedNew + "\n";
    } else {
      return wrappedNew + "\n";
    }
  }
}

/**
 * Check if content appears to have valid Lex markers
 *
 * Supports both standard markers and variant formats.
 *
 * @param content - File content to check
 * @returns True if both BEGIN and END markers are present in correct order
 */
export function hasValidMarkers(content: string): boolean {
  const result = extractMarkedContent(content);
  return result.hasMarkers;
}

/**
 * Check if content has variant (non-standard) markers that should be normalized
 *
 * @param content - File content to check
 * @returns True if variant markers were detected
 */
export function hasVariantMarkers(content: string): boolean {
  const result = extractMarkedContent(content);
  return result.hasVariantMarkers === true;
}

/**
 * Remove Lex-generated content from a file, preserving human sections
 *
 * @param fileContent - Current file content
 * @returns File content with Lex section removed, or original if no markers
 *
 * @example
 * ```ts
 * const cleaned = removeMarkedContent(fileWithLex);
 * // Returns file with only human content (before + after sections)
 * ```
 */
export function removeMarkedContent(fileContent: string): {
  content: string;
  removed: boolean;
  removedContent: string | null;
} {
  const extracted = extractMarkedContent(fileContent);

  if (!extracted.hasMarkers) {
    return {
      content: fileContent,
      removed: false,
      removedContent: null,
    };
  }

  // Combine before and after, normalizing whitespace
  const normalizedBefore = extracted.before.replace(/\n+$/, "");
  const normalizedAfter = extracted.after.replace(/^\n+/, "");

  let result = "";
  if (normalizedBefore && normalizedAfter) {
    result = normalizedBefore + "\n\n" + normalizedAfter;
  } else if (normalizedBefore) {
    result = normalizedBefore;
  } else if (normalizedAfter) {
    result = normalizedAfter;
  }

  // Ensure file ends with newline if non-empty
  if (result && !result.endsWith("\n")) {
    result += "\n";
  }

  return {
    content: result,
    removed: true,
    removedContent: extracted.lex,
  };
}
