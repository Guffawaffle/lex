[{"filePath":"/srv/lex-mcp/lex/eslint.config.mjs","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/srv/lex-mcp/lex/examples/consumer/index.mjs","messages":[{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":11,"column":3,"nodeType":"MemberExpression","messageId":"unexpected","endLine":11,"endColumn":14,"suggestions":[{"fix":{"range":[283,336],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":12,"column":3,"nodeType":"MemberExpression","messageId":"unexpected","endLine":12,"endColumn":14,"suggestions":[{"fix":{"range":[339,395],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":19,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":19,"endColumn":16,"suggestions":[{"fix":{"range":[519,576],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":37,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":37,"endColumn":16,"suggestions":[{"fix":{"range":[1175,1224],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":38,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":38,"endColumn":16,"suggestions":[{"fix":{"range":[1229,1284],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":39,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":39,"endColumn":16,"suggestions":[{"fix":{"range":[1289,1354],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":42,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":42,"endColumn":16,"suggestions":[{"fix":{"range":[1392,1445],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":45,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":45,"endColumn":16,"suggestions":[{"fix":{"range":[1518,1578],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":48,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":48,"endColumn":18,"suggestions":[{"fix":{"range":[1616,1668],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":49,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":49,"endColumn":18,"suggestions":[{"fix":{"range":[1675,1731],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":53,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":53,"endColumn":16,"suggestions":[{"fix":{"range":[1787,1826],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":59,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":59,"endColumn":18,"suggestions":[{"fix":{"range":[1992,2032],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":65,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":65,"endColumn":16,"suggestions":[{"fix":{"range":[2169,2204],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":66,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":66,"endColumn":16,"suggestions":[{"fix":{"range":[2209,2259],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":67,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":67,"endColumn":16,"suggestions":[{"fix":{"range":[2264,2292],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":69,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":69,"endColumn":18,"suggestions":[{"fix":{"range":[2317,2352],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":16,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Lex Consumer Example (ESM JavaScript)\n *\n * This example demonstrates using the Lex package API from plain JavaScript.\n * It captures a frame, recalls it, and validates the output.\n */\n\nimport { saveFrame, searchFrames, getDb, closeDb } from \"lex\";\n\nasync function main() {\n  console.log(\"Lex Consumer Example (JavaScript ESM)\");\n  console.log(\"======================================\\n\");\n\n  // Initialize database (in-memory for testing)\n  const db = getDb(\":memory:\");\n\n  try {\n    // Step 1: Save a frame\n    console.log(\"Step 1: Capturing a work session frame...\");\n    const frameData = {\n      id: `frame-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,\n      timestamp: new Date().toISOString(),\n      reference_point: \"implementing receipt validation\",\n      summary_caption: \"Added receipt generation to policy checker\",\n      status_snapshot: {\n        next_action: \"Add unit tests for receipt format\",\n        blockers: [],\n      },\n      module_scope: [\"policy/check\", \"shared/types\"],\n      branch: \"feature/receipts\",\n      jira: \"LEX-001\",\n      keywords: [\"receipts\", \"policy\", \"validation\"],\n    };\n\n    await saveFrame(db, frameData);\n\n    console.log(`✓ Frame captured: ${frameData.id}`);\n    console.log(`  Summary: ${frameData.summary_caption}`);\n    console.log(`  Modules: ${frameData.module_scope.join(\", \")}\\n`);\n\n    // Step 2: Recall the frame\n    console.log(\"Step 2: Recalling frame by keyword...\");\n    const recalled = await searchFrames(db, \"receipt validation\");\n\n    console.log(`✓ Found ${recalled.length} matching frame(s)`);\n\n    recalled.forEach((f) => {\n      console.log(`  [${f.branch}] ${f.summary_caption}`);\n      console.log(`  Next: ${f.status_snapshot.next_action}`);\n    });\n\n    // Step 3: Validate expected behavior\n    console.log(\"\\nStep 3: Validating...\");\n    if (recalled.length === 0) {\n      throw new Error(\"No frames found - search failed\");\n    }\n\n    if (recalled[0].module_scope.includes(\"policy/check\")) {\n      console.log(\"✓ Module scope validated\");\n    } else {\n      throw new Error(\"Module scope incorrect\");\n    }\n\n    // Final output: RECEIPT_OK token for smoke test assertion\n    console.log(\"\\n\" + \"=\".repeat(40));\n    console.log(\"RECEIPT_OK: All validations passed\");\n    console.log(\"=\".repeat(40));\n  } catch (error) {\n    console.error(\"\\n❌ Error:\", error);\n    process.exit(1);\n  } finally {\n    closeDb(db);\n  }\n}\n\nmain();\n","usedDeprecatedRules":[]},{"filePath":"/srv/lex-mcp/lex/examples/consumer/index.ts","messages":[{"ruleId":null,"nodeType":null,"fatal":true,"severity":2,"message":"Parsing error: \"parserOptions.project\" has been provided for @typescript-eslint/parser.\nThe file was not found in any of the provided project(s): examples/consumer/index.ts"}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Lex Consumer Example (TypeScript)\n *\n * This example demonstrates using the Lex package API.\n * It captures a frame, recalls it, and validates the output.\n */\n\nimport { saveFrame, searchFrames, getDb, closeDb } from \"lex\";\nimport type { Frame } from \"lex\";\n\nasync function main(): Promise<void> {\n  console.log(\"Lex Consumer Example (TypeScript)\");\n  console.log(\"==================================\\n\");\n\n  // Initialize database (in-memory for testing)\n  const db = getDb(\":memory:\");\n\n  try {\n    // Step 1: Save a frame\n    console.log(\"Step 1: Capturing a work session frame...\");\n    const frameData: Frame = {\n      id: `frame-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,\n      timestamp: new Date().toISOString(),\n      reference_point: \"implementing receipt validation\",\n      summary_caption: \"Added receipt generation to policy checker\",\n      status_snapshot: {\n        next_action: \"Add unit tests for receipt format\",\n        blockers: [],\n      },\n      module_scope: [\"policy/check\", \"shared/types\"],\n      branch: \"feature/receipts\",\n      jira: \"LEX-001\",\n      keywords: [\"receipts\", \"policy\", \"validation\"],\n    };\n\n    await saveFrame(db, frameData);\n\n    console.log(`✓ Frame captured: ${frameData.id}`);\n    console.log(`  Summary: ${frameData.summary_caption}`);\n    console.log(`  Modules: ${frameData.module_scope.join(\", \")}\\n`);\n\n    // Step 2: Recall the frame\n    console.log(\"Step 2: Recalling frame by keyword...\");\n    const recalled = await searchFrames(db, \"receipt validation\");\n\n    console.log(`✓ Found ${recalled.length} matching frame(s)`);\n\n    recalled.forEach((f: Frame) => {\n      console.log(`  [${f.branch}] ${f.summary_caption}`);\n      console.log(`  Next: ${f.status_snapshot.next_action}`);\n    });\n\n    // Step 3: Validate expected behavior\n    console.log(\"\\nStep 3: Validating...\");\n    if (recalled.length === 0) {\n      throw new Error(\"No frames found - search failed\");\n    }\n\n    if (recalled[0].module_scope.includes(\"policy/check\")) {\n      console.log(\"✓ Module scope validated\");\n    } else {\n      throw new Error(\"Module scope incorrect\");\n    }\n\n    // Final output: RECEIPT_OK token for smoke test assertion\n    console.log(\"\\n\" + \"=\".repeat(40));\n    console.log(\"RECEIPT_OK: All validations passed\");\n    console.log(\"=\".repeat(40));\n  } catch (error) {\n    console.error(\"\\n❌ Error:\", error);\n    process.exit(1);\n  } finally {\n    closeDb(db);\n  }\n}\n\nmain();\n","usedDeprecatedRules":[]},{"filePath":"/srv/lex-mcp/lex/examples/frame-validation-example.mjs","messages":[{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":29,"column":3,"nodeType":"MemberExpression","messageId":"unexpected","endLine":29,"endColumn":14,"suggestions":[{"fix":{"range":[974,1025],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":51,"column":3,"nodeType":"MemberExpression","messageId":"unexpected","endLine":51,"endColumn":16,"suggestions":[{"fix":{"range":[1535,1583],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":52,"column":3,"nodeType":"MemberExpression","messageId":"unexpected","endLine":52,"endColumn":14,"suggestions":[{"fix":{"range":[1586,1633],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":68,"column":3,"nodeType":"MemberExpression","messageId":"unexpected","endLine":68,"endColumn":14,"suggestions":[{"fix":{"range":[2016,2074],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":70,"column":3,"nodeType":"MemberExpression","messageId":"unexpected","endLine":70,"endColumn":16,"suggestions":[{"fix":{"range":[2095,2145],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Example: Using Module ID Validation in Frame Creation\n * \n * This demonstrates how memory/frames/ can use the validator\n * to enforce THE CRITICAL RULE before creating a Frame.\n */\n\nimport { validateModuleIds, ModuleNotFoundError } from '../shared/module_ids/index.js';\nimport { readFileSync } from 'fs';\n\n// Example function that might exist in memory/frames/\nfunction createFrame(frameData, policyPath = './policy/policy_spec/lexmap.policy.json') {\n  // Load policy\n  const policyContent = readFileSync(policyPath, 'utf-8');\n  const policy = JSON.parse(policyContent);\n  \n  // Validate module_scope against policy\n  const validationResult = validateModuleIds(frameData.module_scope, policy);\n  \n  if (!validationResult.valid) {\n    // Throw error with first invalid module\n    throw new ModuleNotFoundError(\n      validationResult.errors[0].module,\n      validationResult.errors[0].suggestions\n    );\n  }\n  \n  // If validation passes, proceed with Frame creation\n  console.log('✓ Module IDs validated successfully');\n  return {\n    ...frameData,\n    validated: true\n  };\n}\n\n// Example usage\ntry {\n  // This should fail - 'auth-core' doesn't exist\n  createFrame({\n    id: 'frame-001',\n    timestamp: '2025-11-01T16:04:12-05:00',\n    branch: 'feature/auth-fix',\n    module_scope: ['auth-core'],  // Invalid - should be 'services/auth-core'\n    summary_caption: 'Auth fix',\n    reference_point: 'auth deadlock',\n    status_snapshot: {\n      next_action: 'Fix auth'\n    }\n  }, '/tmp/test-proper-policy.json');\n} catch (error) {\n  console.error('Expected error:', error.message);\n  console.log('Suggestions:', error.suggestions);\n}\n\n// This should succeed\ntry {\n  const frame2 = createFrame({\n    id: 'frame-002',\n    timestamp: '2025-11-01T16:04:12-05:00',\n    branch: 'feature/auth-fix',\n    module_scope: ['services/auth-core'],  // Valid\n    summary_caption: 'Auth fix',\n    reference_point: 'auth deadlock',\n    status_snapshot: {\n      next_action: 'Fix auth'\n    }\n  }, '/tmp/test-proper-policy.json');\n  console.log('\\n✓ Frame created successfully:', frame2.id);\n} catch (error) {\n  console.error('Unexpected error:', error.message);\n}\n","usedDeprecatedRules":[]},{"filePath":"/srv/lex-mcp/lex/examples/subpath-exports-example.ts","messages":[{"ruleId":null,"nodeType":null,"fatal":true,"severity":2,"message":"Parsing error: \"parserOptions.project\" has been provided for @typescript-eslint/parser.\nThe file was not found in any of the provided project(s): examples/subpath-exports-example.ts"}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Subpath Exports Example\n *\n * This example demonstrates all documented subpath exports from the Lex package.\n * It validates that the imports compile and basic operations work.\n *\n * NOTE: This file is for documentation purposes. To run it against the packaged tarball:\n * 1. Fix pre-existing build errors (missing @types/node)\n * 2. npm run build\n * 3. npm pack\n * 4. Install tarball in test project\n * 5. Run with tsx\n */\n\n// Main entry point\nimport { saveFrame, getDb, closeDb, searchFrames, getFrameById } from 'lex';\nimport type { Frame, Policy } from 'lex';\n\n// CLI entry point\nimport { createProgram } from 'lex/cli';\n\n// Memory store (alternative import)\nimport { getFramesByBranch, getFramesByJira } from 'lex/memory/store';\n\n// Policy utilities\nimport { loadPolicy, clearPolicyCache } from 'lex/shared/policy';\n\n// Atlas frame generation\nimport {\n  generateAtlasFrame,\n  buildPolicyGraph,\n  computeFoldRadius,\n  estimateTokens,\n} from 'lex/shared/atlas';\n\nasync function main(): Promise<void> {\n  console.log(\"Subpath Exports Validation\");\n  console.log(\"===========================\\n\");\n\n  // Test 1: Main entry point - frame operations\n  console.log(\"✓ Main entry imports compiled successfully\");\n  console.log(\"  - saveFrame, getDb, closeDb, searchFrames, getFrameById\");\n\n  const db = getDb(\":memory:\");\n  \n  const testFrame: Frame = {\n    id: `frame-test-${Date.now()}`,\n    timestamp: new Date().toISOString(),\n    reference_point: \"testing subpath exports\",\n    summary_caption: \"Validating all import paths\",\n    status_snapshot: {\n      next_action: \"Complete validation\",\n      blockers: [],\n    },\n    module_scope: [\"examples/test\"],\n    branch: \"test/subpath-exports\",\n    keywords: [\"test\", \"exports\"],\n  };\n\n  await saveFrame(db, testFrame);\n  const retrieved = await getFrameById(db, testFrame.id);\n  \n  if (!retrieved) {\n    throw new Error(\"Frame not saved/retrieved correctly\");\n  }\n  \n  console.log(\"✓ Main entry operations work correctly\\n\");\n\n  // Test 2: CLI entry point\n  console.log(\"✓ CLI entry imports compiled successfully\");\n  console.log(\"  - createProgram\");\n  \n  const program = createProgram();\n  if (!program || typeof program.parse !== 'function') {\n    throw new Error(\"CLI program not created correctly\");\n  }\n  \n  console.log(\"✓ CLI program created successfully\\n\");\n\n  // Test 3: Memory store alternative imports\n  console.log(\"✓ Memory store imports compiled successfully\");\n  console.log(\"  - getFramesByBranch, getFramesByJira\");\n  \n  const branchFrames = await getFramesByBranch(db, \"test/subpath-exports\");\n  if (branchFrames.length !== 1) {\n    throw new Error(\"getFramesByBranch failed\");\n  }\n  \n  console.log(\"✓ Memory store operations work correctly\\n\");\n\n  // Test 4: Policy utilities\n  console.log(\"✓ Policy utilities imports compiled successfully\");\n  console.log(\"  - loadPolicy, clearPolicyCache\");\n  \n  // Note: loadPolicy requires a policy file, so we just verify import works\n  clearPolicyCache(); // Safe to call even if cache is empty\n  \n  console.log(\"✓ Policy utilities available\\n\");\n\n  // Test 5: Atlas frame generation\n  console.log(\"✓ Atlas frame imports compiled successfully\");\n  console.log(\"  - generateAtlasFrame, buildPolicyGraph, computeFoldRadius, estimateTokens\");\n  \n  // Create a minimal test policy\n  const testPolicy: Policy = {\n    modules: {\n      \"test/module-a\": {\n        owns_paths: [\"test/a/**\"],\n        allowed_callers: [\"test/module-b\"],\n      },\n      \"test/module-b\": {\n        owns_paths: [\"test/b/**\"],\n      },\n    },\n    global_kill_patterns: [],\n  };\n  \n  // Build graph\n  const graph = buildPolicyGraph(testPolicy);\n  if (!graph || !graph.nodes) {\n    throw new Error(\"buildPolicyGraph failed\");\n  }\n  \n  // Generate atlas frame\n  const atlasFrame = generateAtlasFrame({\n    policy: testPolicy,\n    graph,\n    moduleScope: [\"test/module-a\"],\n    foldRadius: 1,\n  });\n  \n  if (!atlasFrame || !atlasFrame.modules) {\n    throw new Error(\"generateAtlasFrame failed\");\n  }\n  \n  console.log(\"✓ Atlas frame operations work correctly\\n\");\n\n  // Clean up\n  closeDb(db);\n\n  // Final validation\n  console.log(\"=\" .repeat(50));\n  console.log(\"✓ ALL SUBPATH EXPORTS VALIDATED\");\n  console.log(\"=\" .repeat(50));\n  console.log(\"\\nValidated exports:\");\n  console.log(\"  • lex (main entry)\");\n  console.log(\"  • lex/cli\");\n  console.log(\"  • lex/memory/store\");\n  console.log(\"  • lex/shared/policy\");\n  console.log(\"  • lex/shared/atlas\");\n  console.log(\"\\nAll imports compiled and basic operations work!\");\n}\n\nmain().catch((error) => {\n  console.error(\"\\n❌ Validation failed:\", error);\n  process.exit(1);\n});\n","usedDeprecatedRules":[]},{"filePath":"/srv/lex-mcp/lex/src/cli/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/srv/lex-mcp/lex/src/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/srv/lex-mcp/lex/src/memory/frames/types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/srv/lex-mcp/lex/src/memory/mcp_server/frame-mcp.mjs","messages":[{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":25,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":25,"endColumn":18,"suggestions":[{"fix":{"range":[680,751],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":26,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":26,"endColumn":18,"suggestions":[{"fix":{"range":[756,815],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":29,"column":3,"nodeType":"MemberExpression","messageId":"unexpected","endLine":29,"endColumn":16,"suggestions":[{"fix":{"range":[840,913],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":53,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":53,"endColumn":20,"suggestions":[{"fix":{"range":[1437,1562],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":60,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":60,"endColumn":20,"suggestions":[{"fix":{"range":[1631,1751],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":67,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":67,"endColumn":18,"suggestions":[{"fix":{"range":[1788,2021],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":95,"column":3,"nodeType":"MemberExpression","messageId":"unexpected","endLine":95,"endColumn":16,"suggestions":[{"fix":{"range":[2286,2346],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":7,"fixableErrorCount":0,"fixableWarningCount":0,"source":"#!/usr/bin/env node\n// Frame MCP Server Entry Point\n// Refactored to use TypeScript implementation from server.ts\n\nimport { MCPServer } from \"./dist/server.js\";\nimport { join, dirname } from \"path\";\nimport { fileURLToPath } from \"url\";\n\nconst __dirname = dirname(fileURLToPath(import.meta.url));\n\n// Repository root is two directories up from this script\nconst repoRoot = join(__dirname, \"../..\");\n\n// Configuration\nconst config = {\n  dbPath: process.env.LEX_MEMORY_DB || join(__dirname, \"../../lex-memory.db\"),\n  repoRoot: repoRoot,\n};\n\n// Initialize MCP server\nlet mcpServer;\ntry {\n  mcpServer = new MCPServer(config.dbPath, config.repoRoot);\n  if (process.env.LEX_DEBUG) {\n    console.error(`[LEX] Memory MCP server initialized: ${config.dbPath}`);\n    console.error(`[LEX] Repository root: ${config.repoRoot}`);\n  }\n} catch (error) {\n  console.error(`[LEX] Failed to initialize MCP server: ${error.message}`);\n  process.exit(1);\n}\n\n// MCP stdio protocol handler\nprocess.stdin.setEncoding(\"utf8\");\nlet buffer = \"\";\n\nprocess.stdin.on(\"data\", async (chunk) => {\n  buffer += chunk;\n  const lines = buffer.split(\"\\n\");\n  buffer = lines.pop() || \"\";\n\n  for (const line of lines) {\n    if (!line.trim()) continue;\n\n    let request;\n    try {\n      request = JSON.parse(line);\n      const response = await mcpServer.handleRequest(request);\n\n      // MCP protocol response format\n      if (response.error) {\n        // Error response\n        console.log(JSON.stringify({\n          jsonrpc: \"2.0\",\n          id: request.id,\n          error: response.error\n        }));\n      } else {\n        // Success response - wrap in result\n        console.log(JSON.stringify({\n          jsonrpc: \"2.0\",\n          id: request.id,\n          result: response\n        }));\n      }\n    } catch (error) {\n      console.log(\n        JSON.stringify({\n          jsonrpc: \"2.0\",\n          id: request?.id || null,\n          error: {\n            message: error.message,\n            code: error.code || \"PARSE_ERROR\",\n          },\n        })\n      );\n    }\n  }\n});// Graceful shutdown\nprocess.on(\"SIGINT\", () => {\n  if (mcpServer) {\n    mcpServer.close();\n  }\n  process.exit(0);\n});\n\nprocess.on(\"SIGTERM\", () => {\n  if (mcpServer) {\n    mcpServer.close();\n  }\n  process.exit(0);\n});\n\nif (process.env.LEX_DEBUG) {\n  console.error(\"[LEX] Memory MCP server ready (stdio mode)\");\n}\n","usedDeprecatedRules":[]},{"filePath":"/srv/lex-mcp/lex/src/memory/mcp_server/server.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":30,"column":12,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":30,"endColumn":15,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1307,1310],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1307,1310],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":34,"column":11,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":34,"endColumn":14,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1356,1359],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1356,1359],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":35,"column":13,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":35,"endColumn":16,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1375,1378],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1375,1378],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":44,"column":14,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":44,"endColumn":17,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1504,1507],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1504,1507],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":53,"column":19,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":53,"endColumn":22,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1677,1680],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1677,1680],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":59,"column":21,"nodeType":"Identifier","messageId":"conditionErrorNullableString","endLine":59,"endColumn":29,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[1995,2003],"text":"(repoRoot != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[1995,2003],"text":"(repoRoot ?? \"\")"},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[1995,2003],"text":"(Boolean(repoRoot))"},"desc":"Explicitly convert value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":65,"column":26,"nodeType":"MemberExpression","messageId":"conditionErrorNullableString","endLine":65,"endColumn":39,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[2249,2262],"text":"(this.repoRoot != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[2249,2262],"text":"(this.repoRoot ?? \"\")"},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[2249,2262],"text":"(Boolean(this.repoRoot))"},"desc":"Explicitly convert value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":1,"message":"Unsafe assignment of an error typed value.","line":68,"column":7,"nodeType":"AssignmentExpression","messageId":"anyAssignment","endLine":68,"endColumn":43},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":69,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":69,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2419,2422],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2419,2422],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":70,"column":11,"nodeType":"MemberExpression","messageId":"conditionErrorNullableString","endLine":70,"endColumn":32,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[2436,2457],"text":"process.env.LEX_DEBUG != null"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[2436,2457],"text":"process.env.LEX_DEBUG ?? \"\""},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[2436,2457],"text":"Boolean(process.env.LEX_DEBUG)"},"desc":"Explicitly convert value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .message on an `any` value.","line":71,"column":60,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":71,"endColumn":67},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":1,"message":"Unsafe object destructuring of a property with an `any` value.","line":82,"column":21,"nodeType":"Identifier","messageId":"unsafeObjectPattern","endLine":82,"endColumn":27},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":98,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":98,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3172,3175],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3172,3175],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":1,"message":"Unsafe assignment of an `any` value.","line":101,"column":11,"nodeType":"Property","messageId":"anyAssignment","endLine":101,"endColumn":33},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .message on an `any` value.","line":101,"column":26,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":101,"endColumn":33},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":1,"message":"Unsafe assignment of an `any` value.","line":102,"column":11,"nodeType":"Property","messageId":"anyAssignment","endLine":102,"endColumn":47},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected any value in conditional. An explicit comparison or type conversion is required.","line":102,"column":17,"nodeType":"MemberExpression","messageId":"conditionErrorAny","endLine":102,"endColumn":27,"suggestions":[{"messageId":"conditionFixCastBoolean","fix":{"range":[3261,3271],"text":"(Boolean(error.code))"},"desc":"Explicitly convert value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .code on an `any` value.","line":102,"column":23,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":102,"endColumn":27},{"ruleId":"@typescript-eslint/no-unsafe-return","severity":1,"message":"Unsafe return of a value of type `any`.","line":112,"column":5,"nodeType":"ReturnStatement","messageId":"unsafeReturn","endLine":121,"endColumn":14},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":121,"column":10,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":121,"endColumn":13,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3639,3642],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3639,3642],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":1,"message":"Unsafe object destructuring of a property with an `any` value.","line":137,"column":30,"nodeType":"Identifier","messageId":"unsafeObjectPattern","endLine":137,"endColumn":34},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":159,"column":38,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":159,"endColumn":41,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4475,4478],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4475,4478],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":1,"message":"Unsafe assignment of an `any` value.","line":160,"column":11,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":170,"endColumn":13},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected any value in conditional. An explicit comparison or type conversion is required.","line":173,"column":10,"nodeType":"Identifier","messageId":"conditionErrorAny","endLine":173,"endColumn":25,"suggestions":[{"messageId":"conditionFixCastBoolean","fix":{"range":[4739,4754],"text":"(Boolean(reference_point))"},"desc":"Explicitly convert value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected any value in conditional. An explicit comparison or type conversion is required.","line":173,"column":30,"nodeType":"Identifier","messageId":"conditionErrorAny","endLine":173,"endColumn":45,"suggestions":[{"messageId":"conditionFixCastBoolean","fix":{"range":[4759,4774],"text":"(Boolean(summary_caption))"},"desc":"Explicitly convert value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected any value in conditional. An explicit comparison or type conversion is required.","line":173,"column":50,"nodeType":"Identifier","messageId":"conditionErrorAny","endLine":173,"endColumn":65,"suggestions":[{"messageId":"conditionFixCastBoolean","fix":{"range":[4779,4794],"text":"(Boolean(status_snapshot))"},"desc":"Explicitly convert value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected any value in conditional. An explicit comparison or type conversion is required.","line":173,"column":70,"nodeType":"Identifier","messageId":"conditionErrorAny","endLine":173,"endColumn":82,"suggestions":[{"messageId":"conditionFixCastBoolean","fix":{"range":[4799,4811],"text":"(Boolean(module_scope))"},"desc":"Explicitly convert value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected any value in conditional. An explicit comparison or type conversion is required.","line":184,"column":10,"nodeType":"MemberExpression","messageId":"conditionErrorAny","endLine":184,"endColumn":37,"suggestions":[{"messageId":"conditionFixCastBoolean","fix":{"range":[5159,5186],"text":"(Boolean(status_snapshot.next_action))"},"desc":"Explicitly convert value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .next_action on an `any` value.","line":184,"column":26,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":184,"endColumn":37},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected any value in conditional. An explicit comparison or type conversion is required.","line":190,"column":9,"nodeType":"MemberExpression","messageId":"conditionErrorAny","endLine":190,"endColumn":20,"suggestions":[{"messageId":"conditionFixCastBoolean","fix":{"range":[5412,5423],"text":"Boolean(this.policy)"},"desc":"Explicitly convert value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .modules on an `any` value.","line":206,"column":59,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":206,"endColumn":66},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":214,"column":16,"nodeType":"MemberExpression","messageId":"conditionErrorNullableString","endLine":214,"endColumn":37,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[6406,6427],"text":"process.env.LEX_DEBUG != null"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[6406,6427],"text":"process.env.LEX_DEBUG ?? \"\""},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[6406,6427],"text":"Boolean(process.env.LEX_DEBUG)"},"desc":"Explicitly convert value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected any value in conditional. An explicit comparison or type conversion is required.","line":226,"column":9,"nodeType":"Identifier","messageId":"conditionErrorAny","endLine":226,"endColumn":15,"suggestions":[{"messageId":"conditionFixCastBoolean","fix":{"range":[6918,6924],"text":"Boolean(branch)"},"desc":"Explicitly convert value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":1,"message":"Unsafe assignment of an `any` value.","line":227,"column":7,"nodeType":"AssignmentExpression","messageId":"anyAssignment","endLine":227,"endColumn":27},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":228,"column":16,"nodeType":"MemberExpression","messageId":"conditionErrorNullableString","endLine":228,"endColumn":29,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[6971,6984],"text":"(this.repoRoot != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[6971,6984],"text":"(this.repoRoot ?? \"\")"},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[6971,6984],"text":"(Boolean(this.repoRoot))"},"desc":"Explicitly convert value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":228,"column":33,"nodeType":"MemberExpression","messageId":"conditionErrorNullableString","endLine":228,"endColumn":63,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[6988,7018],"text":"(process.env.LEX_DEFAULT_BRANCH != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[6988,7018],"text":"(process.env.LEX_DEFAULT_BRANCH ?? \"\")"},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[6988,7018],"text":"(Boolean(process.env.LEX_DEFAULT_BRANCH))"},"desc":"Explicitly convert value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":1,"message":"Unsafe assignment of an `any` value.","line":242,"column":7,"nodeType":"Property","messageId":"anyAssignment","endLine":242,"endColumn":25},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected any value in conditional. An explicit comparison or type conversion is required.","line":242,"column":13,"nodeType":"Identifier","messageId":"conditionErrorAny","endLine":242,"endColumn":17,"suggestions":[{"messageId":"conditionFixCastBoolean","fix":{"range":[7490,7494],"text":"(Boolean(jira))"},"desc":"Explicitly convert value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":1,"message":"Unsafe assignment of an `any` value.","line":244,"column":7,"nodeType":"Property","messageId":"anyAssignment","endLine":244,"endColumn":22},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":1,"message":"Unsafe assignment of an `any` value.","line":245,"column":7,"nodeType":"Property","messageId":"anyAssignment","endLine":245,"endColumn":22},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":1,"message":"Unsafe assignment of an `any` value.","line":246,"column":7,"nodeType":"Property","messageId":"anyAssignment","endLine":246,"endColumn":22},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":1,"message":"Unsafe assignment of an `any` value.","line":247,"column":7,"nodeType":"Property","messageId":"anyAssignment","endLine":247,"endColumn":38},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected any value in conditional. An explicit comparison or type conversion is required.","line":247,"column":17,"nodeType":"Identifier","messageId":"conditionErrorAny","endLine":247,"endColumn":25,"suggestions":[{"messageId":"conditionFixCastBoolean","fix":{"range":[7659,7667],"text":"(Boolean(keywords))"},"desc":"Explicitly convert value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":1,"message":"Unsafe assignment of an `any` value.","line":248,"column":7,"nodeType":"Property","messageId":"anyAssignment","endLine":248,"endColumn":45},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected any value in conditional. An explicit comparison or type conversion is required.","line":248,"column":23,"nodeType":"Identifier","messageId":"conditionErrorAny","endLine":248,"endColumn":37,"suggestions":[{"messageId":"conditionFixCastBoolean","fix":{"range":[7704,7718],"text":"(Boolean(atlas_frame_id))"},"desc":"Explicitly convert value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected any value in conditional. An explicit comparison or type conversion is required.","line":256,"column":9,"nodeType":"Identifier","messageId":"conditionErrorAny","endLine":256,"endColumn":15,"suggestions":[{"messageId":"conditionFixCastBoolean","fix":{"range":[7898,7904],"text":"(Boolean(images))"},"desc":"Explicitly convert value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .data on an `any` value.","line":260,"column":47,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":260,"endColumn":51},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .mime_type on an `any` value.","line":261,"column":82,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":261,"endColumn":91},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":263,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":263,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8254,8257],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8254,8257],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .message on an `any` value.","line":266,"column":59,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":266,"endColumn":66},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected any value in conditional. An explicit comparison or type conversion is required.","line":291,"column":16,"nodeType":"Identifier","messageId":"conditionErrorAny","endLine":291,"endColumn":20,"suggestions":[{"messageId":"conditionFixCastBoolean","fix":{"range":[9200,9204],"text":"(Boolean(jira))"},"desc":"Explicitly convert value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":303,"column":30,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":303,"endColumn":33,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9465,9468],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9465,9468],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":1,"message":"Unsafe assignment of an `any` value.","line":304,"column":11,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":304,"endColumn":63},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected any value in conditional. An explicit comparison or type conversion is required.","line":306,"column":10,"nodeType":"Identifier","messageId":"conditionErrorAny","endLine":306,"endColumn":25,"suggestions":[{"messageId":"conditionFixCastBoolean","fix":{"range":[9559,9574],"text":"(Boolean(reference_point))"},"desc":"Explicitly convert value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected any value in conditional. An explicit comparison or type conversion is required.","line":306,"column":30,"nodeType":"Identifier","messageId":"conditionErrorAny","endLine":306,"endColumn":34,"suggestions":[{"messageId":"conditionFixCastBoolean","fix":{"range":[9579,9583],"text":"(Boolean(jira))"},"desc":"Explicitly convert value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected any value in conditional. An explicit comparison or type conversion is required.","line":306,"column":39,"nodeType":"Identifier","messageId":"conditionErrorAny","endLine":306,"endColumn":45,"suggestions":[{"messageId":"conditionFixCastBoolean","fix":{"range":[9588,9594],"text":"(Boolean(branch))"},"desc":"Explicitly convert value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":1,"message":"Unsafe assignment of type `any[]` to a variable of type `{ id: string; timestamp: string; branch: string; module_scope: string[]; summary_caption: string; reference_point: string; status_snapshot: { next_action: string; blockers?: string[] | undefined; merge_blockers?: string[] | undefined; tests_failing?: string[] | undefined; }; ... 7 more ...; spend?: { ...; } | undefi...`.","line":312,"column":7,"nodeType":"AssignmentExpression","messageId":"unsafeAssignment","endLine":317,"endColumn":9},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":1,"message":"Unsafe assignment of an `any` value.","line":313,"column":9,"nodeType":"Property","messageId":"anyAssignment","endLine":313,"endColumn":24},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":1,"message":"Unsafe assignment of an `any` value.","line":314,"column":9,"nodeType":"Property","messageId":"anyAssignment","endLine":314,"endColumn":13},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":1,"message":"Unsafe assignment of an `any` value.","line":315,"column":9,"nodeType":"Property","messageId":"anyAssignment","endLine":315,"endColumn":15},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":1,"message":"Unsafe assignment of an `any` value.","line":316,"column":9,"nodeType":"Property","messageId":"anyAssignment","endLine":316,"endColumn":14},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":318,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":318,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9885,9888],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9885,9888],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .code on an `any` value.","line":321,"column":17,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":321,"endColumn":21},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected any value in conditional. An explicit comparison or type conversion is required.","line":321,"column":44,"nodeType":"ChainExpression","messageId":"conditionErrorAny","endLine":321,"endColumn":85,"suggestions":[{"messageId":"conditionFixCastBoolean","fix":{"range":[10105,10146],"text":"(Boolean((error.message?.includes(\"no such column\"))))"},"desc":"Explicitly convert value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":1,"message":"Unsafe call of a(n) `any` typed value.","line":321,"column":44,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":321,"endColumn":67},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .message on an `any` value.","line":321,"column":50,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":321,"endColumn":57},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":360,"column":14,"nodeType":"MemberExpression","messageId":"conditionErrorNullableString","endLine":360,"endColumn":20,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[11394,11400],"text":"(f.jira != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[11394,11400],"text":"(f.jira ?? \"\")"},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[11394,11400],"text":"(Boolean(f.jira))"},"desc":"Explicitly convert value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":368,"column":14,"nodeType":"MemberExpression","messageId":"conditionErrorNullableString","endLine":368,"endColumn":30,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[11929,11945],"text":"(f.atlas_frame_id != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[11929,11945],"text":"(f.atlas_frame_id ?? \"\")"},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[11929,11945],"text":"(Boolean(f.atlas_frame_id))"},"desc":"Explicitly convert value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":387,"column":34,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":387,"endColumn":37,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[12317,12320],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[12317,12320],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":1,"message":"Unsafe assignment of an `any` value.","line":388,"column":11,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":388,"endColumn":55},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":391,"column":18,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":391,"endColumn":21,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[12437,12440],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[12437,12440],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":1,"message":"Unsafe assignment of an `any` value.","line":391,"column":26,"nodeType":"Property","messageId":"anyAssignment","endLine":391,"endColumn":31},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected any value in conditional. An explicit comparison or type conversion is required.","line":393,"column":9,"nodeType":"Identifier","messageId":"conditionErrorAny","endLine":393,"endColumn":15,"suggestions":[{"messageId":"conditionFixCastBoolean","fix":{"range":[12463,12469],"text":"Boolean(branch)"},"desc":"Explicitly convert value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":1,"message":"Unsafe assignment of an `any` value.","line":394,"column":7,"nodeType":"AssignmentExpression","messageId":"anyAssignment","endLine":394,"endColumn":28},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .branch on an `any` value.","line":394,"column":13,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":394,"endColumn":19},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected any value in conditional. An explicit comparison or type conversion is required.","line":401,"column":9,"nodeType":"Identifier","messageId":"conditionErrorAny","endLine":401,"endColumn":15,"suggestions":[{"messageId":"conditionFixCastBoolean","fix":{"range":[12682,12688],"text":"Boolean(module)"},"desc":"Explicitly convert value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected any value in conditional. An explicit comparison or type conversion is required.","line":406,"column":9,"nodeType":"Identifier","messageId":"conditionErrorAny","endLine":406,"endColumn":14,"suggestions":[{"messageId":"conditionFixCastBoolean","fix":{"range":[12833,12838],"text":"Boolean(since)"},"desc":"Explicitly convert value to a boolean (`Boolean(value)`)"}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":77,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Lex Memory MCP Server\n *\n * Handles MCP protocol requests for Frame storage and recall.\n * Integrates with FrameStore (SQLite + FTS5) and Atlas Frame generation.\n */\n\n// @ts-ignore - importing from compiled dist directories\nimport { FrameStore } from \"../store/framestore.js\";\n// @ts-ignore - importing from compiled dist directories\nimport { ImageManager } from \"../store/images.js\";\n// @ts-ignore - importing from compiled dist directories\nimport type { Frame } from \"../frames/types.js\";\nimport { MCP_TOOLS } from \"./tools.js\";\n// @ts-ignore - importing from compiled dist directories\nimport { generateAtlasFrame, formatAtlasFrame } from \"../../shared/atlas/atlas-frame.js\";\n// @ts-ignore - importing from compiled dist directories\nimport { validateModuleIds } from \"../../shared/module_ids/validator.js\";\n// @ts-ignore - importing from compiled dist directories\nimport type { ModuleIdError } from \"../../shared/types/validation.js\";\n// @ts-ignore - importing from compiled dist directories\nimport { loadPolicy } from \"../../shared/policy/loader.js\";\n// @ts-ignore - importing from compiled dist directories\nimport { getCurrentBranch } from \"../../shared/git/branch.js\";\nimport { randomUUID } from \"crypto\";\nimport { join } from \"path\";\n\nexport interface MCPRequest {\n  method: string;\n  params?: any;\n}\n\nexport interface MCPResponse {\n  tools?: any[];\n  content?: any[];\n  error?: {\n    message: string;\n    code: string;\n  };\n}\n\nexport interface ToolCallParams {\n  name: string;\n  arguments: any;\n}\n\n/**\n * MCP Server - handles protocol requests\n */\nexport class MCPServer {\n  private frameStore: FrameStore;\n  private imageManager: ImageManager;\n  private policy: any | null; // Cached policy for validation (null if not available)\n  private repoRoot: string | null; // Repository root path\n\n  constructor(dbPath: string, repoRoot?: string) {\n    this.frameStore = new FrameStore(dbPath);\n    this.imageManager = new ImageManager(this.frameStore.getDatabase());\n    this.repoRoot = repoRoot || null;\n\n    // Load policy once at initialization for better performance\n    // If policy is not found, operate without policy enforcement\n    try {\n      // If repoRoot is provided, construct the policy path directly\n      const policyPath = this.repoRoot\n        ? join(this.repoRoot, \"policy/policy_spec/lexmap.policy.json\")\n        : undefined;\n      this.policy = loadPolicy(policyPath);\n    } catch (error: any) {\n      if (process.env.LEX_DEBUG) {\n        console.error(`[LEX] Policy not available: ${error.message}`);\n        console.error(`[LEX] Operating without policy enforcement`);\n      }\n      this.policy = null;\n    }\n  }\n\n  /**\n   * Handle incoming MCP request\n   */\n  async handleRequest(request: MCPRequest): Promise<MCPResponse> {\n    const { method, params } = request;\n\n    try {\n      switch (method) {\n        case \"initialize\":\n          return this.handleInitialize();\n\n        case \"tools/list\":\n          return this.handleToolsList();\n\n        case \"tools/call\":\n          return await this.handleToolsCall(params as ToolCallParams);\n\n        default:\n          throw new Error(`Unknown method: ${method}`);\n      }\n    } catch (error: any) {\n      return {\n        error: {\n          message: error.message,\n          code: error.code || \"INTERNAL_ERROR\",\n        },\n      };\n    }\n  }\n\n  /**\n   * Handle initialize request (MCP protocol handshake)\n   */\n  private handleInitialize(): MCPResponse {\n    return {\n      protocolVersion: \"2024-11-05\",\n      capabilities: {\n        tools: {},\n      },\n      serverInfo: {\n        name: \"lex-memory-mcp-server\",\n        version: \"0.1.0\",\n      },\n    } as any;\n  }\n\n  /**\n   * Handle tools/list request\n   */\n  private handleToolsList(): MCPResponse {\n    return {\n      tools: MCP_TOOLS,\n    };\n  }\n\n  /**\n   * Handle tools/call request\n   */\n  private async handleToolsCall(params: ToolCallParams): Promise<MCPResponse> {\n    const { name, arguments: args } = params;\n\n    switch (name) {\n      case \"lex.remember\":\n        return await this.handleRemember(args);\n\n      case \"lex.recall\":\n        return this.handleRecall(args);\n\n      case \"lex.list_frames\":\n        return this.handleListFrames(args);\n\n      default:\n        throw new Error(`Unknown tool: ${name}`);\n    }\n  }\n\n  /**\n   * Handle lex.remember tool - create new Frame\n   *\n   * Validates module IDs against policy with alias resolution before creating Frame (THE CRITICAL RULE)\n   */\n  private async handleRemember(args: any): Promise<MCPResponse> {\n    const {\n      reference_point,\n      summary_caption,\n      status_snapshot,\n      module_scope,\n      branch,\n      jira,\n      keywords,\n      atlas_frame_id,\n      images,\n    } = args;\n\n    // Validate required fields\n    if (!reference_point || !summary_caption || !status_snapshot || !module_scope) {\n      throw new Error(\n        \"Missing required fields: reference_point, summary_caption, status_snapshot, module_scope\"\n      );\n    }\n\n    if (!Array.isArray(module_scope) || module_scope.length === 0) {\n      throw new Error(\"module_scope must be a non-empty array of module IDs\");\n    }\n\n    // Validate status_snapshot structure\n    if (!status_snapshot.next_action) {\n      throw new Error(\"status_snapshot.next_action is required\");\n    }\n\n    // THE CRITICAL RULE: Resolve aliases and validate module IDs against policy (if available)\n    let canonicalModuleScope = module_scope;\n    if (this.policy) {\n      const validationResult = await validateModuleIds(module_scope, this.policy);\n\n      if (!validationResult.valid && validationResult.errors) {\n        // Format error message with suggestions\n        const errorMessages = validationResult.errors.map((error: ModuleIdError) => {\n          const suggestions =\n            error.suggestions.length > 0\n              ? `\\n  Did you mean: ${error.suggestions.join(\", \")}?`\n              : \"\";\n          return `  • ${error.message}${suggestions}`;\n        });\n\n        throw new Error(\n          `Invalid module IDs in module_scope:\\n${errorMessages.join(\"\\n\")}\\n\\n` +\n            `Module IDs must match those defined in lexmap.policy.json.\\n` +\n            `Available modules: ${Object.keys(this.policy.modules).join(\", \")}`\n        );\n      }\n\n      // Use canonical IDs for storage (never store aliases)\n      if (validationResult.canonical) {\n        canonicalModuleScope = validationResult.canonical;\n      }\n    } else if (process.env.LEX_DEBUG) {\n      console.error(`[LEX] Skipping module validation (no policy loaded)`);\n    }\n\n    // Generate Frame ID and timestamp\n    const frameId = `frame-${Date.now()}-${randomUUID()}`;\n    const timestamp = new Date().toISOString();\n\n    // Get current git branch if not provided - only auto-detect when we\n    // have an explicit repoRoot or an environment override. This avoids\n    // leaking the runner's git branch into tests or hosted environments.\n    let frameBranch: string;\n    if (branch) {\n      frameBranch = branch;\n    } else if (this.repoRoot || process.env.LEX_DEFAULT_BRANCH) {\n      frameBranch = getCurrentBranch();\n      // Log branch detection for debugging\n      console.log(`[lex.remember] Auto-detected branch: ${frameBranch}`);\n    } else {\n      // When no repoRoot is provided and no env override, avoid auto-detecting\n      // from the runner's repository; use 'unknown' to indicate no branch context.\n      frameBranch = \"unknown\";\n    }\n\n    const frame = {\n      id: frameId,\n      timestamp,\n      branch: frameBranch,\n      jira: jira || null,\n      module_scope: canonicalModuleScope, // Store canonical IDs only\n      summary_caption,\n      reference_point,\n      status_snapshot,\n      keywords: keywords || undefined,\n      atlas_frame_id: atlas_frame_id || null,\n      image_ids: [] as string[],\n    };\n\n    this.frameStore.insertFrame(frame);\n\n    // Process image attachments if provided\n    const imageIds: string[] = [];\n    if (images && Array.isArray(images) && images.length > 0) {\n      for (const img of images) {\n        try {\n          // Decode base64 image data\n          const imageBuffer = Buffer.from(img.data, \"base64\");\n          const imageId = this.imageManager.storeImage(frameId, imageBuffer, img.mime_type);\n          imageIds.push(imageId);\n        } catch (error: any) {\n          // If image storage fails, clean up the Frame and rethrow\n          this.frameStore.deleteFrame(frameId);\n          throw new Error(`Failed to store image: ${error.message}`);\n        }\n      }\n\n      // Update frame with image IDs\n      frame.image_ids = imageIds;\n      this.frameStore.insertFrame(frame);\n    }\n\n    // Generate Atlas Frame for the module scope\n    const atlasFrame = generateAtlasFrame(canonicalModuleScope);\n    const atlasOutput = formatAtlasFrame(atlasFrame);\n\n    const imageInfo = imageIds.length > 0 ? `🖼️  Images: ${imageIds.length} attached\\n` : \"\";\n\n    return {\n      content: [\n        {\n          type: \"text\",\n          text:\n            `✅ Frame stored: ${frameId}\\n` +\n            `📍 Reference: ${reference_point}\\n` +\n            `💬 Summary: ${summary_caption}\\n` +\n            `📦 Modules: ${canonicalModuleScope.join(\", \")}\\n` +\n            `🌿 Branch: ${frameBranch}\\n` +\n            `${jira ? `🎫 Jira: ${jira}\\n` : \"\"}` +\n            imageInfo +\n            `📅 Timestamp: ${timestamp}\\n` +\n            atlasOutput,\n        },\n      ],\n    };\n  }\n\n  /**\n   * Handle lex.recall tool - search Frames with Atlas Frame\n   */\n  private handleRecall(args: any): MCPResponse {\n    const { reference_point, jira, branch, limit = 10 } = args;\n\n    if (!reference_point && !jira && !branch) {\n      throw new Error(\"At least one search parameter required: reference_point, jira, or branch\");\n    }\n\n    let frames: Frame[];\n    try {\n      frames = this.frameStore.searchFrames({\n        reference_point,\n        jira,\n        branch,\n        limit,\n      });\n    } catch (error: any) {\n      // FTS5 search can fail with special characters (e.g., \"zzz-nonexistent-query-zzz\")\n      // Treat search errors as empty results rather than propagating the error\n      if (error.code === \"SQLITE_ERROR\" || error.message?.includes(\"no such column\")) {\n        frames = [];\n      } else {\n        throw error;\n      }\n    }\n\n    if (frames.length === 0) {\n      return {\n        content: [\n          {\n            type: \"text\",\n            text:\n              \"🔍 No matching Frames found.\\n\" +\n              \"Try broader search terms or check your query parameters.\",\n          },\n        ],\n      };\n    }\n\n    // Format results with Atlas Frame for each\n    const results = frames\n      .map((f: Frame, idx: number) => {\n        const nextAction = f.status_snapshot?.next_action || \"None specified\";\n        const blockers = f.status_snapshot?.blockers || [];\n        const mergeBlockers = f.status_snapshot?.merge_blockers || [];\n        const testsFailing = f.status_snapshot?.tests_failing || [];\n\n        // Generate Atlas Frame for this Frame's modules\n        const atlasFrame = generateAtlasFrame(f.module_scope);\n        const atlasOutput = formatAtlasFrame(atlasFrame);\n\n        return (\n          `\\n--- Frame ${idx + 1}/${frames.length} ---\\n` +\n          `ID: ${f.id}\\n` +\n          `📍 Reference: ${f.reference_point}\\n` +\n          `💬 Summary: ${f.summary_caption}\\n` +\n          `📦 Modules: ${f.module_scope.join(\", \")}\\n` +\n          `🌿 Branch: ${f.branch}\\n` +\n          `${f.jira ? `🎫 Jira: ${f.jira}\\n` : \"\"}` +\n          `📅 Timestamp: ${f.timestamp}\\n` +\n          `\\nStatus:\\n` +\n          `  ⏭️  Next Action: ${nextAction}\\n` +\n          `  🚫 Blockers (${blockers.length}): ${blockers.join(\", \") || \"none\"}\\n` +\n          `  ⛔ Merge Blockers (${mergeBlockers.length}): ${mergeBlockers.join(\", \") || \"none\"}\\n` +\n          `  ❌ Tests Failing (${testsFailing.length}): ${testsFailing.join(\", \") || \"none\"}\\n` +\n          `${f.keywords ? `🏷️  Keywords: ${f.keywords.join(\", \")}\\n` : \"\"}` +\n          `${f.atlas_frame_id ? `🗺️  Atlas: ${f.atlas_frame_id}\\n` : \"\"}` +\n          atlasOutput\n        );\n      })\n      .join(\"\\n\");\n\n    return {\n      content: [\n        {\n          type: \"text\",\n          text: `🎯 Found ${frames.length} Frame(s):\\n${results}`,\n        },\n      ],\n    };\n  }\n\n  /**\n   * Handle lex.list_frames tool - list recent Frames\n   */\n  private handleListFrames(args: any): MCPResponse {\n    const { branch, module, limit = 10, since } = args;\n\n    // Build search query\n    const query: any = { limit };\n\n    if (branch) {\n      query.branch = branch;\n    }\n\n    // Search frames (if no filters, searchFrames returns recent frames)\n    let frames = this.frameStore.searchFrames(query);\n\n    // Filter by module if specified\n    if (module) {\n      frames = frames.filter((f: Frame) => f.module_scope.includes(module));\n    }\n\n    // Filter by timestamp if since is specified\n    if (since) {\n      const sinceDate = new Date(since);\n      frames = frames.filter((f: Frame) => new Date(f.timestamp) >= sinceDate);\n    }\n\n    if (frames.length === 0) {\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: \"📋 No Frames found matching criteria.\",\n          },\n        ],\n      };\n    }\n\n    // Format results with Atlas Frame for each\n    const results = frames\n      .map((f: Frame, idx: number) => {\n        const atlasFrame = generateAtlasFrame(f.module_scope);\n        const atlasOutput = formatAtlasFrame(atlasFrame);\n\n        return (\n          `\\n${idx + 1}. ${f.reference_point}\\n` +\n          `   ID: ${f.id}\\n` +\n          `   📦 Modules: ${f.module_scope.join(\", \")}\\n` +\n          `   🌿 Branch: ${f.branch}\\n` +\n          `   📅 ${f.timestamp}\\n` +\n          atlasOutput\n        );\n      })\n      .join(\"\\n\");\n\n    return {\n      content: [\n        {\n          type: \"text\",\n          text: `📋 Recent Frames (${frames.length}):\\n${results}`,\n        },\n      ],\n    };\n  }\n\n  /**\n   * Close database connection\n   */\n  close() {\n    this.frameStore.close();\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/srv/lex-mcp/lex/src/memory/mcp_server/tools.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":14,"column":32,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":14,"endColumn":35,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[354,357],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[354,357],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * MCP Tools for Frame Memory\n *\n * Defines the tools exposed via Model Context Protocol for AI assistants.\n * Each tool can search, create, or list Frames with Atlas Frame neighborhoods.\n */\n\nexport interface MCPTool {\n  name: string;\n  description: string;\n  inputSchema: {\n    type: string;\n    required?: string[];\n    properties: Record<string, any>;\n  };\n}\n\n/**\n * Tool definitions for MCP protocol\n */\nexport const MCP_TOOLS: MCPTool[] = [\n  {\n    name: \"lex.remember\",\n    description: \"Store a Frame (episodic memory snapshot)\",\n    inputSchema: {\n      type: \"object\",\n      required: [\"reference_point\", \"summary_caption\", \"status_snapshot\", \"module_scope\"],\n      properties: {\n        reference_point: {\n          type: \"string\",\n          description: 'What you were working on (e.g., \"refactoring UserAuth module\")',\n        },\n        summary_caption: {\n          type: \"string\",\n          description:\n            'One-line summary of progress (e.g., \"Extracted password validation to separate function\")',\n        },\n        status_snapshot: {\n          type: \"object\",\n          description:\n            \"Current state: {next_action: string, blockers?: [], merge_blockers?: [], tests_failing?: []}\",\n          properties: {\n            next_action: { type: \"string\" },\n            blockers: { type: \"array\", items: { type: \"string\" } },\n            merge_blockers: { type: \"array\", items: { type: \"string\" } },\n            tests_failing: { type: \"array\", items: { type: \"string\" } },\n          },\n          required: [\"next_action\"],\n        },\n        module_scope: {\n          type: \"array\",\n          items: { type: \"string\" },\n          description: 'Module IDs from lexmap.policy.json (e.g., [\"auth/core\", \"auth/password\"])',\n        },\n        branch: {\n          type: \"string\",\n          description: \"Git branch (defaults to current branch)\",\n        },\n        jira: {\n          type: \"string\",\n          description: 'Optional Jira/issue ticket (e.g., \"PROJ-123\")',\n        },\n        keywords: {\n          type: \"array\",\n          items: { type: \"string\" },\n          description: 'Optional search tags (e.g., [\"refactoring\", \"authentication\"])',\n        },\n        atlas_frame_id: {\n          type: \"string\",\n          description: \"Reference to Atlas Frame (fold radius snapshot)\",\n        },\n        images: {\n          type: \"array\",\n          items: {\n            type: \"object\",\n            properties: {\n              data: {\n                type: \"string\",\n                description: \"Base64-encoded image data\",\n              },\n              mime_type: {\n                type: \"string\",\n                description: 'MIME type (e.g., \"image/png\", \"image/jpeg\")',\n              },\n            },\n            required: [\"data\", \"mime_type\"],\n          },\n          description: \"Optional array of image attachments (base64-encoded with MIME type)\",\n        },\n      },\n    },\n  },\n  {\n    name: \"lex.recall\",\n    description:\n      \"Search Frames by reference point, branch, or Jira ticket. Returns Frame + Atlas Frame neighborhood.\",\n    inputSchema: {\n      type: \"object\",\n      properties: {\n        reference_point: {\n          type: \"string\",\n          description: \"Fuzzy search on what you were working on\",\n        },\n        jira: {\n          type: \"string\",\n          description: \"Exact match on Jira ticket\",\n        },\n        branch: {\n          type: \"string\",\n          description: \"Filter by git branch\",\n        },\n        limit: {\n          type: \"number\",\n          description: \"Max results to return (default: 10)\",\n          default: 10,\n        },\n      },\n    },\n  },\n  {\n    name: \"lex.list_frames\",\n    description:\n      \"List recent Frames, optionally filtered by branch or module. Returns Frame + Atlas Frame for each result.\",\n    inputSchema: {\n      type: \"object\",\n      properties: {\n        branch: {\n          type: \"string\",\n          description: \"Filter by git branch\",\n        },\n        module: {\n          type: \"string\",\n          description: \"Filter by module ID in module_scope\",\n        },\n        limit: {\n          type: \"number\",\n          description: \"Max results to return (default: 10)\",\n          default: 10,\n        },\n        since: {\n          type: \"string\",\n          description: \"ISO 8601 timestamp - only return Frames after this time\",\n        },\n      },\n    },\n  },\n];\n","usedDeprecatedRules":[]},{"filePath":"/srv/lex-mcp/lex/src/memory/renderer/card.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'wrapText' is defined but never used. Allowed unused vars must match /^_/u.","line":16,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":16,"endColumn":11},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'highlightDiff' is defined but never used. Allowed unused vars must match /^_/u.","line":22,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":22,"endColumn":23},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'TruncationOptions' is defined but never used. Allowed unused vars must match /^_/u.","line":23,"column":41,"nodeType":null,"messageId":"unusedVar","endLine":23,"endColumn":58},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'language' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":172,"column":26,"nodeType":null,"messageId":"unusedVar","endLine":172,"endColumn":34},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":244,"column":17,"nodeType":"MemberExpression","messageId":"conditionErrorNullableString","endLine":244,"endColumn":35,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[8316,8334],"text":"(options.rawContext != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[8316,8334],"text":"(options.rawContext ?? \"\")"},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[8316,8334],"text":"(Boolean(options.rawContext))"},"desc":"Explicitly convert value to a boolean (`Boolean(value)`)"}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Memory card image rendering (Sharp + SVG)\n * Generates high-contrast visual panels with Frame state for vision-token compression\n *\n * Uses SVG for layout/styling and Sharp for PNG conversion (no system dependencies)\n */\n\nimport sharp from \"sharp\";\nimport type { Frame } from \"./types.js\";\nimport {\n  DEFAULT_DIMENSIONS,\n  DARK_COLOR_SCHEME,\n  MONOSPACE_FONT,\n  TEXT_LIMITS,\n  truncateText,\n  wrapText,\n  calculateCardHeight,\n  type CardDimensions,\n  type ColorScheme,\n  type FontConfig,\n} from \"./templates.js\";\nimport { highlightDiff } from \"./syntax.js\";\nimport { renderDiff, getDiffStats, type TruncationOptions } from \"./diff.js\";\nimport type { BundledLanguage } from \"shiki\";\n\nexport interface RenderOptions {\n  dimensions?: CardDimensions;\n  colorScheme?: ColorScheme;\n  fontConfig?: FontConfig;\n  rawContext?: string;\n}\n\n/**\n * Extract code diffs from raw context string\n * Looks for diff blocks in the context\n */\nfunction extractDiffs(rawContext: string): Array<{\n  diff: string;\n  language: BundledLanguage;\n}> {\n  const diffs: Array<{ diff: string; language: BundledLanguage }> = [];\n\n  // Detect unified diff format: lines starting with +, -, or space (for context)\n  // Must have at least one + or - line to be considered a diff\n  const lines = rawContext.split(\"\\n\");\n  let currentDiff: string[] = [];\n  let inDiff = false;\n  let hasChanges = false; // Track if current block has actual changes\n\n  for (const line of lines) {\n    const firstChar = line[0];\n\n    // Check for diff markers at the start of the line (not trimmed)\n    const isDiffLine = firstChar === \"+\" || firstChar === \"-\" || (firstChar === \" \" && inDiff); // Space only counts if already in diff\n\n    if (isDiffLine) {\n      if (!inDiff) {\n        inDiff = true;\n        currentDiff = [];\n        hasChanges = false;\n      }\n\n      // Track if we have actual changes (not just context)\n      if (firstChar === \"+\" || firstChar === \"-\") {\n        hasChanges = true;\n      }\n\n      currentDiff.push(line);\n    } else if (inDiff && currentDiff.length > 0) {\n      // End of diff block - only add if it has actual changes\n      if (hasChanges) {\n        diffs.push({\n          diff: currentDiff.join(\"\\n\"),\n          language: \"typescript\", // Default to TypeScript\n        });\n      }\n      currentDiff = [];\n      inDiff = false;\n      hasChanges = false;\n    }\n  }\n\n  // Add remaining diff if any and has changes\n  if (currentDiff.length > 0 && hasChanges) {\n    diffs.push({\n      diff: currentDiff.join(\"\\n\"),\n      language: \"typescript\",\n    });\n  }\n\n  return diffs;\n}\n\n/**\n * Generate SVG content for the memory card\n */\nasync function generateSVG(frame: Frame, options: Required<RenderOptions>): Promise<string> {\n  const { dimensions, colorScheme, fontConfig, rawContext } = options;\n  const dynamicHeight = calculateCardHeight(frame, dimensions);\n\n  let yOffset = dimensions.padding;\n  const lineHeight = dimensions.lineHeight;\n\n  const svgParts: string[] = [];\n\n  // SVG header\n  svgParts.push(\n    `<svg width=\"${dimensions.width}\" height=\"${dynamicHeight}\" xmlns=\"http://www.w3.org/2000/svg\">`\n  );\n\n  // Background\n  svgParts.push(`<rect width=\"100%\" height=\"100%\" fill=\"${colorScheme.background}\"/>`);\n\n  // Title\n  svgParts.push(\n    `<text x=\"${dimensions.padding}\" y=\"${yOffset}\" font-family=\"${fontConfig.family}\" font-size=\"${fontConfig.sizeTitle}\" fill=\"${colorScheme.heading}\" font-weight=\"bold\">Memory Card: ${escapeXml(frame.id.substring(0, 20))}</text>`\n  );\n  yOffset += lineHeight * 1.5;\n\n  // Timestamp and Branch\n  svgParts.push(\n    `<text x=\"${dimensions.padding}\" y=\"${yOffset}\" font-family=\"${fontConfig.family}\" font-size=\"${fontConfig.sizeSmall}\" fill=\"${colorScheme.muted}\">${escapeXml(new Date(frame.timestamp).toLocaleString())}</text>`\n  );\n  yOffset += lineHeight;\n\n  svgParts.push(\n    `<text x=\"${dimensions.padding}\" y=\"${yOffset}\" font-family=\"${fontConfig.family}\" font-size=\"${fontConfig.sizeBody}\" fill=\"${colorScheme.accent}\">Branch: ${escapeXml(frame.branch)}</text>`\n  );\n  yOffset += lineHeight * 1.5;\n\n  // Divider\n  svgParts.push(\n    `<line x1=\"${dimensions.padding}\" y1=\"${yOffset}\" x2=\"${dimensions.width - dimensions.padding}\" y2=\"${yOffset}\" stroke=\"${colorScheme.muted}\" stroke-width=\"1\"/>`\n  );\n  yOffset += lineHeight;\n\n  // Summary Caption\n  const summaryText = truncateText(frame.summary_caption, TEXT_LIMITS.summaryCaption);\n  svgParts.push(\n    `<text x=\"${dimensions.padding}\" y=\"${yOffset}\" font-family=\"${fontConfig.family}\" font-size=\"${fontConfig.sizeBody}\" fill=\"${colorScheme.text}\">${escapeXml(summaryText)}</text>`\n  );\n  yOffset += lineHeight * 1.5;\n\n  // Reference Point\n  svgParts.push(\n    `<text x=\"${dimensions.padding}\" y=\"${yOffset}\" font-family=\"${fontConfig.family}\" font-size=\"${fontConfig.sizeSmall}\" fill=\"${colorScheme.muted}\">Ref: ${escapeXml(truncateText(frame.reference_point, TEXT_LIMITS.referencePoint))}</text>`\n  );\n  yOffset += lineHeight * 1.5;\n\n  // Status Snapshot\n  svgParts.push(\n    `<text x=\"${dimensions.padding}\" y=\"${yOffset}\" font-family=\"${fontConfig.family}\" font-size=\"${fontConfig.sizeHeading}\" fill=\"${colorScheme.heading}\" font-weight=\"bold\">Status</text>`\n  );\n  yOffset += lineHeight;\n\n  const nextAction = truncateText(frame.status_snapshot.next_action, TEXT_LIMITS.nextAction);\n  svgParts.push(\n    `<text x=\"${dimensions.padding}\" y=\"${yOffset}\" font-family=\"${fontConfig.family}\" font-size=\"${fontConfig.sizeBody}\" fill=\"${colorScheme.text}\">Next: ${escapeXml(nextAction)}</text>`\n  );\n  yOffset += lineHeight * 1.5;\n\n  // Code Diffs (if present in raw context)\n  if (rawContext) {\n    const diffs = extractDiffs(rawContext);\n\n    if (diffs.length > 0) {\n      svgParts.push(\n        `<text x=\"${dimensions.padding}\" y=\"${yOffset}\" font-family=\"${fontConfig.family}\" font-size=\"${fontConfig.sizeHeading}\" fill=\"${colorScheme.heading}\" font-weight=\"bold\">Recent Changes</text>`\n      );\n      yOffset += lineHeight;\n\n      for (const { diff, language } of diffs.slice(0, 2)) {\n        // Limit to 2 diffs\n        // Apply smart truncation\n        const truncatedDiff = renderDiff(diff, { maxLines: 20, contextLines: 2 });\n        const stats = getDiffStats(diff);\n\n        // Show diff stats\n        svgParts.push(\n          `<text x=\"${dimensions.padding}\" y=\"${yOffset}\" font-family=\"${fontConfig.family}\" font-size=\"${fontConfig.sizeSmall}\" fill=\"${colorScheme.muted}\">+${stats.additions} -${stats.deletions}</text>`\n        );\n        yOffset += lineHeight;\n\n        // Render diff lines (simplified for SVG - no full syntax highlighting in SVG)\n        const diffLines = truncatedDiff.split(\"\\n\").slice(0, 15); // Limit lines\n        for (const line of diffLines) {\n          let color = colorScheme.text;\n          if (line.startsWith(\"+\")) {\n            color = colorScheme.diffAddition;\n          } else if (line.startsWith(\"-\")) {\n            color = colorScheme.diffDeletion;\n          } else if (line.includes(\"lines omitted\") || line.includes(\"more lines\")) {\n            color = colorScheme.diffContext;\n          }\n\n          svgParts.push(\n            `<text x=\"${dimensions.padding + 10}\" y=\"${yOffset}\" font-family=\"${fontConfig.family}\" font-size=\"${fontConfig.sizeSmall}\" fill=\"${color}\">${escapeXml(line.substring(0, 80))}</text>`\n          );\n          yOffset += lineHeight * 0.8;\n        }\n\n        yOffset += lineHeight * 0.5;\n      }\n    }\n  }\n\n  // Close SVG\n  svgParts.push(\"</svg>\");\n\n  return svgParts.join(\"\\n\");\n}\n\n/**\n * Escape XML special characters\n */\nfunction escapeXml(text: string): string {\n  return text\n    .replace(/&/g, \"&amp;\")\n    .replace(/</g, \"&lt;\")\n    .replace(/>/g, \"&gt;\")\n    .replace(/\"/g, \"&quot;\")\n    .replace(/'/g, \"&apos;\");\n}\n\n/**\n * Render memory card as PNG image\n */\nexport async function renderMemoryCard(frame: Frame, rawContext?: string): Promise<Buffer> {\n  return renderMemoryCardWithOptions(frame, { rawContext });\n}\n\n/**\n * Render memory card with custom options\n */\nexport async function renderMemoryCardWithOptions(\n  frame: Frame,\n  options: RenderOptions\n): Promise<Buffer> {\n  // Merge with defaults\n  const fullOptions: Required<RenderOptions> = {\n    dimensions: options.dimensions || DEFAULT_DIMENSIONS,\n    colorScheme: options.colorScheme || DARK_COLOR_SCHEME,\n    fontConfig: options.fontConfig || MONOSPACE_FONT,\n    rawContext: options.rawContext || \"\",\n  };\n\n  // Generate SVG\n  const svg = await generateSVG(frame, fullOptions);\n\n  // Convert SVG to PNG using Sharp\n  const buffer = await sharp(Buffer.from(svg)).png().toBuffer();\n\n  return buffer;\n}\n","usedDeprecatedRules":[]},{"filePath":"/srv/lex-mcp/lex/src/memory/renderer/diff.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/srv/lex-mcp/lex/src/memory/renderer/example.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/srv/lex-mcp/lex/src/memory/renderer/graph-example.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/srv/lex-mcp/lex/src/memory/renderer/graph.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'MIN_DISTANCE_THRESHOLD' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":102,"column":7,"nodeType":null,"messageId":"unusedVar","endLine":102,"endColumn":29},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":308,"column":7,"nodeType":"MemberExpression","messageId":"conditionErrorNullableString","endLine":308,"endColumn":18,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[8546,8557],"text":"edge.reason != null"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[8546,8557],"text":"edge.reason ?? \"\""},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[8546,8557],"text":"Boolean(edge.reason)"},"desc":"Explicitly convert value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.","line":411,"column":7,"nodeType":"MemberExpression","messageId":"conditionErrorNullableNumber","endLine":411,"endColumn":20,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[11326,11339],"text":"(options.width != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultZero","fix":{"range":[11326,11339],"text":"(options.width ?? 0)"},"desc":"Explicitly treat nullish value the same as 0 (`value ?? 0`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[11326,11339],"text":"(Boolean(options.width))"},"desc":"Explicitly convert value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.","line":411,"column":24,"nodeType":"MemberExpression","messageId":"conditionErrorNullableNumber","endLine":411,"endColumn":38,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[11343,11357],"text":"(options.height != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultZero","fix":{"range":[11343,11357],"text":"(options.height ?? 0)"},"desc":"Explicitly treat nullish value the same as 0 (`value ?? 0`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[11343,11357],"text":"(Boolean(options.height))"},"desc":"Explicitly convert value to a boolean (`Boolean(value)`)"}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Graph rendering for Atlas Frames\n * Generates SVG visualizations showing module nodes, dependency edges,\n * and visual indicators for allowed vs forbidden connections.\n */\n\n// Use inline types to avoid cross-package type dependencies that violate rootDir\nexport interface AtlasModule {\n  id: string;\n  coords?: [number, number];\n  owns_paths?: string[];\n  owns_namespaces?: string[];\n  allowed_callers?: string[];\n  forbidden_callers?: string[];\n  feature_flags?: string[];\n  requires_permissions?: string[];\n  kill_patterns?: string[];\n  notes?: string;\n}\n\nexport interface AtlasEdge {\n  from: string;\n  to: string;\n  allowed: boolean;\n  reason?: string;\n}\n\nexport interface AtlasFrame {\n  atlas_timestamp: string;\n  seed_modules: string[];\n  fold_radius: number;\n  modules: AtlasModule[];\n  edges: AtlasEdge[];\n  critical_rule: string;\n}\n\nimport {\n  forceDirectedLayout,\n  hierarchicalLayout,\n  type Layout,\n  type LayoutConfig,\n} from \"./layouts.js\";\n\nexport interface GraphRenderOptions {\n  width?: number;\n  height?: number;\n  layout?: \"force-directed\" | \"hierarchical\";\n  layoutConfig?: LayoutConfig;\n  showTooltips?: boolean;\n  nodeColors?: Record<string, string>;\n}\n\nexport interface GraphNode {\n  id: string;\n  x: number;\n  y: number;\n  radius: number;\n  isSeed: boolean;\n  module: AtlasModule;\n}\n\nexport interface GraphEdgeRenderable {\n  from: GraphNode;\n  to: GraphNode;\n  allowed: boolean;\n  reason?: string;\n}\n\nconst DEFAULT_OPTIONS: Required<GraphRenderOptions> = {\n  width: 800,\n  height: 600,\n  layout: \"force-directed\",\n  layoutConfig: {},\n  showTooltips: true,\n  nodeColors: {},\n};\n\n// Module type detection based on ID patterns\nfunction detectModuleType(moduleId: string): string {\n  const lower = moduleId.toLowerCase();\n  if (lower.includes(\"ui/\") || lower.includes(\"component\")) return \"component\";\n  if (lower.includes(\"api/\") || lower.includes(\"service\")) return \"service\";\n  if (lower.includes(\"util\") || lower.includes(\"helper\")) return \"util\";\n  if (lower.includes(\"backend\") || lower.includes(\"core\")) return \"core\";\n  if (lower.includes(\"database\") || lower.includes(\"db\")) return \"database\";\n  return \"default\";\n}\n\n// Color mapping for different module types\nconst MODULE_TYPE_COLORS: Record<string, string> = {\n  component: \"#4CAF50\",\n  service: \"#2196F3\",\n  util: \"#FF9800\",\n  core: \"#9C27B0\",\n  database: \"#795548\",\n  default: \"#607D8B\",\n};\n\n// Constants for rendering\nconst MAX_LABEL_LENGTH = 20;\nconst LABEL_TRUNCATE_AT = 17;\nconst MIN_DISTANCE_THRESHOLD = 0.1;\nconst WARNING_ICON = \"\\u26A0\\uFE0F\"; // ⚠️ as Unicode\n\n/**\n * Calculate node size based on number of dependencies\n */\nfunction calculateNodeRadius(module: AtlasModule, edges: AtlasEdge[]): number {\n  const minRadius = 20;\n  const maxRadius = 50;\n  const baseRadius = 30;\n\n  // Count incoming and outgoing edges\n  const edgeCount = edges.filter((e) => e.from === module.id || e.to === module.id).length;\n\n  // Scale radius based on edge count (logarithmic scaling)\n  const scaledRadius = baseRadius + Math.log(edgeCount + 1) * 5;\n  return Math.min(maxRadius, Math.max(minRadius, scaledRadius));\n}\n\n/**\n * Render Atlas Frame as SVG graph\n */\nexport function renderAtlasFrameGraph(\n  atlasFrame: AtlasFrame,\n  options: GraphRenderOptions = {}\n): string {\n  const opts = { ...DEFAULT_OPTIONS, ...options };\n\n  // Create graph nodes\n  const nodes: GraphNode[] = atlasFrame.modules.map((module) => {\n    const radius = calculateNodeRadius(module, atlasFrame.edges);\n    const isSeed = atlasFrame.seed_modules.includes(module.id);\n\n    return {\n      id: module.id,\n      x: module.coords?.[0] ?? 0,\n      y: module.coords?.[1] ?? 0,\n      radius,\n      isSeed,\n      module,\n    };\n  });\n\n  // Apply layout algorithm\n  const layout: Layout =\n    opts.layout === \"hierarchical\"\n      ? hierarchicalLayout(nodes, atlasFrame.edges, opts.layoutConfig)\n      : forceDirectedLayout(nodes, atlasFrame.edges, opts.layoutConfig);\n\n  // Scale to fit canvas\n  scaleToFit(layout.nodes, opts.width, opts.height);\n\n  // Build edges with positioned nodes\n  const nodeMap = new Map(layout.nodes.map((n) => [n.id, n]));\n  const edges: GraphEdgeRenderable[] = [];\n  for (const edge of atlasFrame.edges) {\n    const from = nodeMap.get(edge.from);\n    const to = nodeMap.get(edge.to);\n    if (from && to) {\n      edges.push({ from, to, allowed: edge.allowed, reason: edge.reason });\n    }\n  }\n\n  // Generate SVG\n  return generateSVG(layout.nodes, edges, opts);\n}\n\n/**\n * Scale nodes to fit within canvas bounds\n */\nfunction scaleToFit(nodes: GraphNode[], width: number, height: number): void {\n  if (nodes.length === 0) return;\n\n  const padding = 60;\n  const availableWidth = width - 2 * padding;\n  const availableHeight = height - 2 * padding;\n\n  // Find current bounds\n  let minX = Infinity,\n    maxX = -Infinity;\n  let minY = Infinity,\n    maxY = -Infinity;\n\n  for (const node of nodes) {\n    minX = Math.min(minX, node.x - node.radius);\n    maxX = Math.max(maxX, node.x + node.radius);\n    minY = Math.min(minY, node.y - node.radius);\n    maxY = Math.max(maxY, node.y + node.radius);\n  }\n\n  const currentWidth = maxX - minX;\n  const currentHeight = maxY - minY;\n\n  // Calculate scale factor\n  const scaleX = currentWidth > 0 ? availableWidth / currentWidth : 1;\n  const scaleY = currentHeight > 0 ? availableHeight / currentHeight : 1;\n  const scale = Math.min(scaleX, scaleY, 1); // Don't scale up, only down\n\n  // Apply scaling and centering\n  for (const node of nodes) {\n    node.x = (node.x - minX) * scale + padding;\n    node.y = (node.y - minY) * scale + padding;\n  }\n}\n\n/**\n * Generate SVG markup\n */\nfunction generateSVG(\n  nodes: GraphNode[],\n  edges: GraphEdgeRenderable[],\n  options: Required<GraphRenderOptions>\n): string {\n  const { width, height, showTooltips, nodeColors } = options;\n\n  let svg = `<svg width=\"${width}\" height=\"${height}\" xmlns=\"http://www.w3.org/2000/svg\">`;\n\n  // Add styles\n  svg += `\n  <defs>\n    <style>\n      .node { cursor: pointer; }\n      .node:hover { opacity: 0.8; }\n      .edge-allowed { stroke: #4CAF50; fill: none; }\n      .edge-forbidden { stroke: #F44336; fill: none; stroke-dasharray: 5,5; }\n      .node-label { \n        font-family: -apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto, sans-serif;\n        font-size: 12px;\n        fill: #333;\n        text-anchor: middle;\n        pointer-events: none;\n      }\n      .tooltip {\n        font-family: -apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto, sans-serif;\n        font-size: 11px;\n        fill: white;\n        pointer-events: none;\n      }\n      .tooltip-bg {\n        fill: rgba(0, 0, 0, 0.8);\n        rx: 4;\n      }\n    </style>\n    \n    <!-- Arrow markers for edges -->\n    <marker id=\"arrow-allowed\" markerWidth=\"10\" markerHeight=\"10\" refX=\"9\" refY=\"3\" orient=\"auto\" markerUnits=\"strokeWidth\">\n      <path d=\"M0,0 L0,6 L9,3 z\" fill=\"#4CAF50\" />\n    </marker>\n    <marker id=\"arrow-forbidden\" markerWidth=\"10\" markerHeight=\"10\" refX=\"9\" refY=\"3\" orient=\"auto\" markerUnits=\"strokeWidth\">\n      <path d=\"M0,0 L0,6 L9,3 z\" fill=\"#F44336\" />\n    </marker>\n  </defs>\n  `;\n\n  // Add background\n  svg += `<rect width=\"${width}\" height=\"${height}\" fill=\"#f5f5f5\"/>`;\n\n  // Render edges first (so they appear below nodes)\n  svg += '<g id=\"edges\">';\n  for (const edge of edges) {\n    svg += renderEdge(edge);\n  }\n  svg += \"</g>\";\n\n  // Render nodes\n  svg += '<g id=\"nodes\">';\n  for (const node of nodes) {\n    const color = nodeColors[node.id] || MODULE_TYPE_COLORS[detectModuleType(node.id)];\n    svg += renderNode(node, color, showTooltips);\n  }\n  svg += \"</g>\";\n\n  svg += \"</svg>\";\n  return svg;\n}\n\n/**\n * Render a single edge\n */\nfunction renderEdge(edge: GraphEdgeRenderable): string {\n  const { from, to, allowed } = edge;\n\n  // Calculate edge endpoints at circle boundaries\n  const dx = to.x - from.x;\n  const dy = to.y - from.y;\n  const distance = Math.sqrt(dx * dx + dy * dy);\n\n  if (distance === 0) return \"\";\n\n  // Offset from and to points by node radius\n  const offsetX = dx / distance;\n  const offsetY = dy / distance;\n\n  const x1 = from.x + offsetX * from.radius;\n  const y1 = from.y + offsetY * from.radius;\n  const x2 = to.x - offsetX * to.radius;\n  const y2 = to.y - offsetY * to.radius;\n\n  const className = allowed ? \"edge-allowed\" : \"edge-forbidden\";\n  const marker = allowed ? \"url(#arrow-allowed)\" : \"url(#arrow-forbidden)\";\n  const strokeWidth = 2;\n\n  let svg = `<line x1=\"${x1}\" y1=\"${y1}\" x2=\"${x2}\" y2=\"${y2}\" `;\n  svg += `class=\"${className}\" stroke-width=\"${strokeWidth}\" marker-end=\"${marker}\">`;\n\n  // Add title for tooltip\n  if (edge.reason) {\n    svg += `<title>${from.id} → ${to.id} (${edge.reason})</title>`;\n  } else {\n    svg += `<title>${from.id} → ${to.id}</title>`;\n  }\n\n  svg += \"</line>\";\n\n  // Add warning icon for forbidden edges\n  if (!allowed) {\n    const midX = (x1 + x2) / 2;\n    const midY = (y1 + y2) / 2;\n    svg += `<text x=\"${midX}\" y=\"${midY}\" font-size=\"14\" fill=\"#F44336\" text-anchor=\"middle\">${WARNING_ICON}</text>`;\n  }\n\n  return svg;\n}\n\n/**\n * Render a single node\n */\nfunction renderNode(node: GraphNode, color: string, showTooltips: boolean): string {\n  const { x, y, radius, isSeed, module } = node;\n\n  // Seed modules have bold border\n  const strokeWidth = isSeed ? 3 : 1;\n  const stroke = isSeed ? \"#000\" : \"#666\";\n\n  let svg = `<g class=\"node\">`;\n\n  // Circle\n  svg += `<circle cx=\"${x}\" cy=\"${y}\" r=\"${radius}\" fill=\"${color}\" stroke=\"${stroke}\" stroke-width=\"${strokeWidth}\">`;\n  svg += `<title>${module.id}</title>`;\n  svg += \"</circle>\";\n\n  // Label (truncate if too long)\n  const label =\n    module.id.length > MAX_LABEL_LENGTH\n      ? module.id.substring(0, LABEL_TRUNCATE_AT) + \"...\"\n      : module.id;\n  svg += `<text x=\"${x}\" y=\"${y + radius + 15}\" class=\"node-label\">${escapeXml(label)}</text>`;\n\n  // Tooltip (if enabled)\n  if (showTooltips) {\n    svg += renderTooltip(node);\n  }\n\n  svg += \"</g>\";\n  return svg;\n}\n\n/**\n * Render tooltip content for a node\n * Note: This creates a hidden tooltip that would be shown on hover with JavaScript\n */\nfunction renderTooltip(node: GraphNode): string {\n  const { module } = node;\n\n  let tooltip = \"\";\n  tooltip += `\\n<!-- Tooltip for ${module.id} -->`;\n  tooltip += `\\n<!-- ID: ${module.id} -->`;\n\n  if (module.owns_paths && module.owns_paths.length > 0) {\n    tooltip += `\\n<!-- Paths: ${module.owns_paths.join(\", \")} -->`;\n  }\n\n  if (module.feature_flags && module.feature_flags.length > 0) {\n    tooltip += `\\n<!-- Flags: ${module.feature_flags.join(\", \")} -->`;\n  }\n\n  if (module.requires_permissions && module.requires_permissions.length > 0) {\n    tooltip += `\\n<!-- Permissions: ${module.requires_permissions.join(\", \")} -->`;\n  }\n\n  return tooltip;\n}\n\n/**\n * Escape XML special characters\n */\nfunction escapeXml(text: string): string {\n  return text\n    .replace(/&/g, \"&amp;\")\n    .replace(/</g, \"&lt;\")\n    .replace(/>/g, \"&gt;\")\n    .replace(/\"/g, \"&quot;\")\n    .replace(/'/g, \"&apos;\");\n}\n\n/**\n * Export graph as PNG using sharp\n * Converts SVG to PNG for embedding in memory cards\n */\nexport async function exportGraphAsPNG(\n  svgContent: string,\n  options: { width?: number; height?: number } = {}\n): Promise<Buffer> {\n  // Import sharp dynamically to avoid issues if not installed\n  const sharp = (await import(\"sharp\")).default;\n\n  const buffer = Buffer.from(svgContent);\n  let image = sharp(buffer);\n\n  if (options.width || options.height) {\n    image = image.resize(options.width, options.height);\n  }\n\n  return image.png().toBuffer();\n}\n","usedDeprecatedRules":[]},{"filePath":"/srv/lex-mcp/lex/src/memory/renderer/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/srv/lex-mcp/lex/src/memory/renderer/integration-demo.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/srv/lex-mcp/lex/src/memory/renderer/layouts.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'layer' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":268,"column":15,"nodeType":null,"messageId":"unusedVar","endLine":268,"endColumn":20},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'config' is assigned a value but never used. Allowed unused args must match /^_/u.","line":296,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":296,"endColumn":9}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Layout algorithms for graph visualization\n * Provides force-directed and hierarchical layout options\n */\n\nimport type { GraphNode } from \"./graph.js\";\n\n// Use inline type to avoid cross-package dependencies\nexport interface AtlasEdge {\n  from: string;\n  to: string;\n  allowed: boolean;\n  reason?: string;\n}\n\nexport interface LayoutConfig {\n  iterations?: number;\n  repulsion?: number;\n  attraction?: number;\n  damping?: number;\n  levelSpacing?: number;\n  nodeSpacing?: number;\n}\n\nexport interface Layout {\n  nodes: GraphNode[];\n  width: number;\n  height: number;\n}\n\nconst DEFAULT_FORCE_CONFIG: Required<LayoutConfig> = {\n  iterations: 100,\n  repulsion: 2000,\n  attraction: 0.02,\n  damping: 0.85,\n  levelSpacing: 150,\n  nodeSpacing: 100,\n};\n\n// Constants for layout calculations\nconst MIN_DISTANCE_THRESHOLD = 0.1;\n\n/**\n * Force-directed graph layout (Fruchterman-Reingold algorithm)\n * Creates organic-looking layouts where connected nodes attract and all nodes repel\n */\nexport function forceDirectedLayout(\n  nodes: GraphNode[],\n  edges: AtlasEdge[],\n  config: LayoutConfig = {}\n): Layout {\n  const cfg = { ...DEFAULT_FORCE_CONFIG, ...config };\n\n  if (nodes.length === 0) {\n    return { nodes: [], width: 800, height: 600 };\n  }\n\n  // Create a mutable copy of nodes with positions\n  const layoutNodes = nodes.map((n) => ({ ...n }));\n\n  // Initialize velocities\n  const velocities = new Map<string, { vx: number; vy: number }>();\n  layoutNodes.forEach((node) => {\n    velocities.set(node.id, { vx: 0, vy: 0 });\n  });\n\n  // Build adjacency for quick edge lookups\n  const adjacency = new Map<string, Set<string>>();\n  for (const edge of edges) {\n    if (!adjacency.has(edge.from)) adjacency.set(edge.from, new Set());\n    if (!adjacency.has(edge.to)) adjacency.set(edge.to, new Set());\n    adjacency.get(edge.from)!.add(edge.to);\n    // For undirected behavior, also add reverse\n    adjacency.get(edge.to)!.add(edge.from);\n  }\n\n  const width = 1000;\n  const height = 1000;\n  const minDistance = 10;\n\n  // Run iterations\n  for (let iter = 0; iter < cfg.iterations; iter++) {\n    const forces = new Map<string, { fx: number; fy: number }>();\n\n    // Initialize forces\n    for (const node of layoutNodes) {\n      forces.set(node.id, { fx: 0, fy: 0 });\n    }\n\n    // Repulsive forces (all pairs)\n    for (let i = 0; i < layoutNodes.length; i++) {\n      for (let j = i + 1; j < layoutNodes.length; j++) {\n        const n1 = layoutNodes[i];\n        const n2 = layoutNodes[j];\n\n        const dx = n2.x - n1.x;\n        const dy = n2.y - n1.y;\n        const distSq = dx * dx + dy * dy;\n        const dist = Math.sqrt(distSq);\n\n        if (dist < MIN_DISTANCE_THRESHOLD) continue;\n\n        // Coulomb's law: F = k / r^2\n        const force = cfg.repulsion / distSq;\n        const fx = (dx / dist) * force;\n        const fy = (dy / dist) * force;\n\n        const f1 = forces.get(n1.id)!;\n        const f2 = forces.get(n2.id)!;\n        f1.fx -= fx;\n        f1.fy -= fy;\n        f2.fx += fx;\n        f2.fy += fy;\n      }\n    }\n\n    // Attractive forces (connected nodes)\n    for (const edge of edges) {\n      // Only use allowed edges for attraction\n      if (!edge.allowed) continue;\n\n      const n1 = layoutNodes.find((n) => n.id === edge.from);\n      const n2 = layoutNodes.find((n) => n.id === edge.to);\n\n      if (!n1 || !n2) continue;\n\n      const dx = n2.x - n1.x;\n      const dy = n2.y - n1.y;\n      const dist = Math.sqrt(dx * dx + dy * dy);\n\n      if (dist < MIN_DISTANCE_THRESHOLD) continue;\n\n      // Hooke's law: F = k * d\n      const force = dist * cfg.attraction;\n      const fx = (dx / dist) * force;\n      const fy = (dy / dist) * force;\n\n      const f1 = forces.get(n1.id)!;\n      const f2 = forces.get(n2.id)!;\n      f1.fx += fx;\n      f1.fy += fy;\n      f2.fx -= fx;\n      f2.fy -= fy;\n    }\n\n    // Update positions\n    for (const node of layoutNodes) {\n      const vel = velocities.get(node.id)!;\n      const force = forces.get(node.id)!;\n\n      // Update velocity with damping\n      vel.vx = (vel.vx + force.fx) * cfg.damping;\n      vel.vy = (vel.vy + force.fy) * cfg.damping;\n\n      // Update position\n      node.x += vel.vx;\n      node.y += vel.vy;\n\n      // Keep within bounds\n      node.x = Math.max(minDistance, Math.min(width - minDistance, node.x));\n      node.y = Math.max(minDistance, Math.min(height - minDistance, node.y));\n    }\n  }\n\n  return { nodes: layoutNodes, width, height };\n}\n\n/**\n * Hierarchical graph layout (top-down tree)\n * Organizes nodes in layers based on dependency structure\n */\nexport function hierarchicalLayout(\n  nodes: GraphNode[],\n  edges: AtlasEdge[],\n  config: LayoutConfig = {}\n): Layout {\n  const cfg = { ...DEFAULT_FORCE_CONFIG, ...config };\n\n  if (nodes.length === 0) {\n    return { nodes: [], width: 800, height: 600 };\n  }\n\n  // Create a mutable copy of nodes\n  const layoutNodes = nodes.map((n) => ({ ...n }));\n\n  // Build adjacency lists (directed)\n  const outgoing = new Map<string, Set<string>>();\n  const incoming = new Map<string, Set<string>>();\n\n  for (const node of layoutNodes) {\n    outgoing.set(node.id, new Set());\n    incoming.set(node.id, new Set());\n  }\n\n  for (const edge of edges) {\n    if (!edge.allowed) continue; // Only use allowed edges for hierarchy\n\n    const out = outgoing.get(edge.from);\n    const inc = incoming.get(edge.to);\n\n    if (out) out.add(edge.to);\n    if (inc) inc.add(edge.from);\n  }\n\n  // Assign layers using topological sort (BFS from roots)\n  const layers = new Map<string, number>();\n  const queue: string[] = [];\n\n  // Start with nodes that have no incoming edges (roots)\n  for (const node of layoutNodes) {\n    if (incoming.get(node.id)!.size === 0) {\n      layers.set(node.id, 0);\n      queue.push(node.id);\n    }\n  }\n\n  // If no roots found, start with seed nodes\n  if (queue.length === 0) {\n    for (const node of layoutNodes) {\n      if (node.isSeed) {\n        layers.set(node.id, 0);\n        queue.push(node.id);\n      }\n    }\n  }\n\n  // BFS to assign layers\n  while (queue.length > 0) {\n    const nodeId = queue.shift()!;\n    const currentLayer = layers.get(nodeId)!;\n\n    const neighbors = outgoing.get(nodeId);\n    if (!neighbors) continue;\n\n    for (const neighborId of neighbors) {\n      const existingLayer = layers.get(neighborId);\n      const newLayer = currentLayer + 1;\n\n      if (existingLayer === undefined || newLayer > existingLayer) {\n        layers.set(neighborId, newLayer);\n        queue.push(neighborId);\n      }\n    }\n  }\n\n  // Assign remaining nodes to a default layer\n  for (const node of layoutNodes) {\n    if (!layers.has(node.id)) {\n      layers.set(node.id, 0);\n    }\n  }\n\n  // Group nodes by layer\n  const layerGroups = new Map<number, GraphNode[]>();\n  for (const node of layoutNodes) {\n    const layer = layers.get(node.id)!;\n    if (!layerGroups.has(layer)) {\n      layerGroups.set(layer, []);\n    }\n    layerGroups.get(layer)!.push(node);\n  }\n\n  // Calculate positions\n  const maxLayer = Math.max(...Array.from(layers.values()), 0);\n  const height = (maxLayer + 1) * cfg.levelSpacing + 100;\n\n  let maxWidth = 0;\n  for (const [layer, layerNodes] of layerGroups.entries()) {\n    const layerWidth = layerNodes.length * cfg.nodeSpacing;\n    maxWidth = Math.max(maxWidth, layerWidth);\n  }\n  const width = maxWidth + 100;\n\n  // Position nodes\n  for (const [layer, layerNodes] of layerGroups.entries()) {\n    const y = 50 + layer * cfg.levelSpacing;\n    const layerWidth = layerNodes.length * cfg.nodeSpacing;\n    const startX = (width - layerWidth) / 2;\n\n    layerNodes.forEach((node, index) => {\n      node.x = startX + index * cfg.nodeSpacing + cfg.nodeSpacing / 2;\n      node.y = y;\n    });\n  }\n\n  return { nodes: layoutNodes, width, height };\n}\n\n/**\n * Circular layout (nodes arranged in a circle)\n * Simple fallback layout for small graphs\n */\nexport function circularLayout(\n  nodes: GraphNode[],\n  edges: AtlasEdge[],\n  config: LayoutConfig = {}\n): Layout {\n  if (nodes.length === 0) {\n    return { nodes: [], width: 800, height: 600 };\n  }\n\n  const layoutNodes = nodes.map((n) => ({ ...n }));\n  const width = 800;\n  const height = 600;\n  const centerX = width / 2;\n  const centerY = height / 2;\n  const radius = Math.min(width, height) / 2 - 100;\n\n  const angleStep = (2 * Math.PI) / layoutNodes.length;\n\n  layoutNodes.forEach((node, index) => {\n    const angle = index * angleStep;\n    node.x = centerX + radius * Math.cos(angle);\n    node.y = centerY + radius * Math.sin(angle);\n  });\n\n  return { nodes: layoutNodes, width, height };\n}\n","usedDeprecatedRules":[]},{"filePath":"/srv/lex-mcp/lex/src/memory/renderer/syntax.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'createHighlighter' is defined but never used. Allowed unused vars must match /^_/u.","line":6,"column":22,"nodeType":null,"messageId":"unusedVar","endLine":6,"endColumn":39},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":70,"column":10,"nodeType":"Identifier","messageId":"conditionErrorNullableString","endLine":70,"endColumn":13,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[1300,1303],"text":"(ext != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[1300,1303],"text":"(ext ?? \"\")"},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[1300,1303],"text":"(Boolean(ext))"},"desc":"Explicitly convert value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":192,"column":51,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":192,"endColumn":54,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4928,4931],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4928,4931],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Syntax highlighting wrapper using Shiki\n * Provides VS Code-quality syntax highlighting for code diffs\n */\n\nimport { codeToHtml, createHighlighter } from \"shiki\";\nimport type { BundledLanguage } from \"shiki\";\n\n// Common languages supported\nexport const SUPPORTED_LANGUAGES = [\n  \"typescript\",\n  \"javascript\",\n  \"python\",\n  \"php\",\n  \"java\",\n  \"go\",\n  \"rust\",\n  \"cpp\",\n  \"c\",\n  \"csharp\",\n  \"ruby\",\n  \"swift\",\n  \"kotlin\",\n  \"sql\",\n  \"html\",\n  \"css\",\n  \"json\",\n  \"yaml\",\n  \"markdown\",\n  \"bash\",\n  \"shell\",\n] as const;\n\nexport type SupportedLanguage = (typeof SUPPORTED_LANGUAGES)[number];\n\n// Language detection from file extension or content\nconst LANGUAGE_EXTENSIONS: Record<string, BundledLanguage> = {\n  ts: \"typescript\",\n  tsx: \"typescript\",\n  js: \"javascript\",\n  jsx: \"javascript\",\n  py: \"python\",\n  php: \"php\",\n  java: \"java\",\n  go: \"go\",\n  rs: \"rust\",\n  cpp: \"cpp\",\n  cc: \"cpp\",\n  c: \"c\",\n  cs: \"csharp\",\n  rb: \"ruby\",\n  swift: \"swift\",\n  kt: \"kotlin\",\n  sql: \"sql\",\n  html: \"html\",\n  css: \"css\",\n  json: \"json\",\n  yml: \"yaml\",\n  yaml: \"yaml\",\n  md: \"markdown\",\n  sh: \"bash\",\n  bash: \"bash\",\n};\n\n/**\n * Detect language from file extension\n */\nexport function detectLanguageFromExtension(filename: string): BundledLanguage {\n  const ext = filename.split(\".\").pop()?.toLowerCase();\n  return ext && ext in LANGUAGE_EXTENSIONS ? LANGUAGE_EXTENSIONS[ext] : \"typescript\"; // Default to TypeScript\n}\n\n/**\n * Highlight code with syntax highlighting\n *\n * @param code - Code to highlight\n * @param language - Programming language\n * @param theme - Color theme (default: 'dark-plus' to match VS Code)\n * @returns HTML string with syntax highlighting\n */\nexport async function highlightCode(\n  code: string,\n  language: BundledLanguage = \"typescript\",\n  theme: \"dark-plus\" | \"light-plus\" = \"dark-plus\"\n): Promise<string> {\n  try {\n    const html = await codeToHtml(code, {\n      lang: language,\n      theme: theme,\n    });\n    return html;\n  } catch (error) {\n    // Fallback to plain text if highlighting fails\n    console.error(`Syntax highlighting failed for ${language}:`, error);\n    return `<pre><code>${escapeHtml(code)}</code></pre>`;\n  }\n}\n\n/**\n * Highlight a diff with syntax highlighting\n * Preserves +/- indicators while applying syntax highlighting\n *\n * @param diff - Unified diff string\n * @param language - Programming language\n * @param theme - Color theme\n * @returns HTML string with syntax highlighted diff\n */\nexport async function highlightDiff(\n  diff: string,\n  language: BundledLanguage = \"typescript\",\n  theme: \"dark-plus\" | \"light-plus\" = \"dark-plus\"\n): Promise<string> {\n  try {\n    const lines = diff.split(\"\\n\");\n    const processedLines: string[] = [];\n\n    for (const line of lines) {\n      if (!line) {\n        processedLines.push(\"\");\n        continue;\n      }\n\n      const firstChar = line[0];\n      const isAddition = firstChar === \"+\";\n      const isDeletion = firstChar === \"-\";\n      const isUnchanged = firstChar === \" \";\n\n      if (isAddition || isDeletion || isUnchanged) {\n        // Extract the code without the diff marker\n        const code = line.substring(1);\n\n        // Highlight the code\n        const highlighted = await codeToHtml(code, {\n          lang: language,\n          theme: theme,\n        });\n\n        // Extract just the highlighted content (remove outer pre/code tags)\n        const match = highlighted.match(/<code[^>]*>(.*?)<\\/code>/s);\n        const highlightedContent = match ? match[1] : escapeHtml(code);\n\n        // Wrap in appropriate styling based on diff type\n        let className = \"\";\n        let prefix = \"\";\n\n        if (isAddition) {\n          className = \"diff-addition\";\n          prefix = \"+\";\n        } else if (isDeletion) {\n          className = \"diff-deletion\";\n          prefix = \"-\";\n        } else {\n          className = \"diff-unchanged\";\n          prefix = \" \";\n        }\n\n        processedLines.push(\n          `<div class=\"${className}\"><span class=\"diff-marker\">${prefix}</span>${highlightedContent}</div>`\n        );\n      } else {\n        // Context line (file headers, line numbers, etc.)\n        processedLines.push(`<div class=\"diff-context\">${escapeHtml(line)}</div>`);\n      }\n    }\n\n    return `<div class=\"diff-container\">${processedLines.join(\"\\n\")}</div>`;\n  } catch (error) {\n    console.error(\"Diff highlighting failed:\", error);\n    // Fallback to plain diff\n    return `<pre class=\"diff-fallback\"><code>${escapeHtml(diff)}</code></pre>`;\n  }\n}\n\n/**\n * Escape HTML special characters\n */\nfunction escapeHtml(text: string): string {\n  const htmlEscapes: Record<string, string> = {\n    \"&\": \"&amp;\",\n    \"<\": \"&lt;\",\n    \">\": \"&gt;\",\n    '\"': \"&quot;\",\n    \"'\": \"&#39;\",\n  };\n  return text.replace(/[&<>\"']/g, (char) => htmlEscapes[char]);\n}\n\n/**\n * Check if a language is supported\n */\nexport function isLanguageSupported(language: string): language is BundledLanguage {\n  return SUPPORTED_LANGUAGES.includes(language as any);\n}\n","usedDeprecatedRules":[]},{"filePath":"/srv/lex-mcp/lex/src/memory/renderer/templates.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":129,"column":44,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":129,"endColumn":47,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2719,2722],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2719,2722],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .summary_caption on an `any` value.","line":137,"column":24,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":137,"endColumn":39},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .status_snapshot on an `any` value.","line":147,"column":24,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":147,"endColumn":39},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .status_snapshot on an `any` value.","line":152,"column":13,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":152,"endColumn":28},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .status_snapshot on an `any` value.","line":154,"column":41,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":154,"endColumn":56},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .status_snapshot on an `any` value.","line":159,"column":13,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":159,"endColumn":28},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .status_snapshot on an `any` value.","line":162,"column":13,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":162,"endColumn":28},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .status_snapshot on an `any` value.","line":169,"column":13,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":169,"endColumn":28},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .status_snapshot on an `any` value.","line":171,"column":38,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":171,"endColumn":53},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .keywords on an `any` value.","line":179,"column":13,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":179,"endColumn":21},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected any value in conditional. An explicit comparison or type conversion is required.","line":184,"column":7,"nodeType":"MemberExpression","messageId":"conditionErrorAny","endLine":184,"endColumn":17,"suggestions":[{"messageId":"conditionFixCastBoolean","fix":{"range":[4130,4140],"text":"Boolean(frame.jira)"},"desc":"Explicitly convert value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .jira on an `any` value.","line":184,"column":13,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":184,"endColumn":17},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected any value in conditional. An explicit comparison or type conversion is required.","line":185,"column":7,"nodeType":"MemberExpression","messageId":"conditionErrorAny","endLine":185,"endColumn":27,"suggestions":[{"messageId":"conditionFixCastBoolean","fix":{"range":[4160,4180],"text":"Boolean(frame.atlas_frame_id)"},"desc":"Explicitly convert value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .atlas_frame_id on an `any` value.","line":185,"column":13,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":185,"endColumn":27}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":14,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Layout templates and styling for memory card rendering\n * Optimized for LLM vision input with high-contrast, readable design\n */\n\nexport interface CardDimensions {\n  width: number;\n  height: number;\n  padding: number;\n  lineHeight: number;\n}\n\nexport interface ColorScheme {\n  background: string;\n  text: string;\n  heading: string;\n  accent: string;\n  muted: string;\n  warning: string;\n  error: string;\n  diffAddition: string;\n  diffDeletion: string;\n  diffUnchanged: string;\n  diffContext: string;\n}\n\nexport interface FontConfig {\n  family: string;\n  sizeTitle: number;\n  sizeHeading: number;\n  sizeBody: number;\n  sizeSmall: number;\n}\n\n/**\n * Default card dimensions optimized for vision models\n * Based on research: ~800px wide for good token compression\n */\nexport const DEFAULT_DIMENSIONS: CardDimensions = {\n  width: 800,\n  height: 1000,\n  padding: 40,\n  lineHeight: 24,\n};\n\n/**\n * High-contrast dark theme color scheme\n * Optimized for readability in vision models\n */\nexport const DARK_COLOR_SCHEME: ColorScheme = {\n  background: \"#1a1a1a\",\n  text: \"#e0e0e0\",\n  heading: \"#ffffff\",\n  accent: \"#4a9eff\",\n  muted: \"#888888\",\n  warning: \"#ffaa00\",\n  error: \"#ff4444\",\n  diffAddition: \"#22863a\",\n  diffDeletion: \"#b31d28\",\n  diffUnchanged: \"#6a737d\",\n  diffContext: \"#586069\",\n};\n\n/**\n * Monospace font configuration for technical content\n */\nexport const MONOSPACE_FONT: FontConfig = {\n  family: \"monospace\",\n  sizeTitle: 28,\n  sizeHeading: 20,\n  sizeBody: 16,\n  sizeSmall: 14,\n};\n\n/**\n * Maximum text lengths to prevent overflow\n */\nexport const TEXT_LIMITS = {\n  summaryCaption: 120,\n  referencePoint: 80,\n  nextAction: 200,\n  blockerItem: 100,\n  maxBlockers: 5,\n  maxKeywords: 8,\n};\n\n/**\n * Truncate text with ellipsis if it exceeds max length\n */\nexport function truncateText(text: string, maxLength: number): string {\n  if (text.length <= maxLength) {\n    return text;\n  }\n  return text.substring(0, maxLength - 3) + \"...\";\n}\n\n/**\n * Wrap text to fit within a given width\n * Returns array of lines\n */\nexport function wrapText(text: string, maxWidth: number, charWidth: number): string[] {\n  const maxCharsPerLine = Math.floor(maxWidth / charWidth);\n  const words = text.split(\" \");\n  const lines: string[] = [];\n  let currentLine = \"\";\n\n  for (const word of words) {\n    const testLine = currentLine ? `${currentLine} ${word}` : word;\n    if (testLine.length <= maxCharsPerLine) {\n      currentLine = testLine;\n    } else {\n      if (currentLine) {\n        lines.push(currentLine);\n      }\n      currentLine = word;\n    }\n  }\n\n  if (currentLine) {\n    lines.push(currentLine);\n  }\n\n  return lines;\n}\n\n/**\n * Calculate dynamic card height based on content\n */\nexport function calculateCardHeight(frame: any, dimensions: CardDimensions): number {\n  let lines = 0;\n\n  // Title + timestamp + branch + divider\n  lines += 5;\n\n  // Summary caption (wrapped)\n  const summaryLines = Math.ceil(\n    truncateText(frame.summary_caption, TEXT_LIMITS.summaryCaption).length / 60\n  );\n  lines += summaryLines + 1;\n\n  // Reference point\n  lines += 2;\n\n  // Status snapshot\n  lines += 2; // heading + next action\n  const nextActionLines = Math.ceil(\n    truncateText(frame.status_snapshot.next_action, TEXT_LIMITS.nextAction).length / 60\n  );\n  lines += nextActionLines;\n\n  // Blockers\n  if (frame.status_snapshot.blockers?.length > 0) {\n    lines += 1; // heading\n    const blockerCount = Math.min(frame.status_snapshot.blockers.length, TEXT_LIMITS.maxBlockers);\n    lines += blockerCount;\n  }\n\n  // Merge blockers\n  if (frame.status_snapshot.merge_blockers?.length > 0) {\n    lines += 1; // heading\n    const mergeBlockerCount = Math.min(\n      frame.status_snapshot.merge_blockers.length,\n      TEXT_LIMITS.maxBlockers\n    );\n    lines += mergeBlockerCount;\n  }\n\n  // Tests failing\n  if (frame.status_snapshot.tests_failing?.length > 0) {\n    lines += 1; // heading\n    const testCount = Math.min(frame.status_snapshot.tests_failing.length, TEXT_LIMITS.maxBlockers);\n    lines += testCount;\n  }\n\n  // Module scope\n  lines += 2;\n\n  // Keywords\n  if (frame.keywords?.length > 0) {\n    lines += 2;\n  }\n\n  // Optional fields\n  if (frame.jira) lines += 1;\n  if (frame.atlas_frame_id) lines += 1;\n\n  // Raw context section\n  lines += 4; // spacing and potential context\n\n  const calculatedHeight = dimensions.padding * 2 + lines * dimensions.lineHeight;\n  return Math.max(calculatedHeight, dimensions.height);\n}\n","usedDeprecatedRules":[]},{"filePath":"/srv/lex-mcp/lex/src/memory/renderer/timeline.example.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'writeFileSync' is defined but never used. Allowed unused vars must match /^_/u.","line":15,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":15,"endColumn":23}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Timeline Example\n *\n * Demonstrates the timeline visualization for Frame evolution.\n */\n\nimport {\n  buildTimeline,\n  renderTimelineText,\n  renderModuleScopeEvolution,\n  renderBlockerTracking,\n  renderTimelineHTML,\n} from \"./timeline.js\";\nimport type { Frame } from \"./types.js\";\nimport { writeFileSync } from \"fs\";\n\n// Example frames for TICKET-123: Add user authentication\nconst frames: Frame[] = [\n  {\n    id: \"frame-abc123\",\n    timestamp: \"2025-11-01T14:00:00-05:00\",\n    branch: \"feature/user-auth\",\n    jira: \"TICKET-123\",\n    module_scope: [\"ui/login-form\"],\n    summary_caption: \"Started implementation\",\n    reference_point: \"auth login start\",\n    status_snapshot: {\n      next_action: \"Build login form UI components\",\n    },\n  },\n  {\n    id: \"frame-def456\",\n    timestamp: \"2025-11-02T09:30:00-05:00\",\n    branch: \"feature/user-auth\",\n    jira: \"TICKET-123\",\n    module_scope: [\"ui/login-form\", \"services/auth-core\"],\n    summary_caption: \"Auth API integration\",\n    reference_point: \"auth api integration\",\n    status_snapshot: {\n      next_action: \"Configure CORS headers for auth endpoint\",\n      blockers: [\"CORS configuration issue\"],\n    },\n  },\n  {\n    id: \"frame-ghi789\",\n    timestamp: \"2025-11-02T16:45:00-05:00\",\n    branch: \"feature/user-auth\",\n    jira: \"TICKET-123\",\n    module_scope: [\"ui/login-form\", \"services/auth-core\"],\n    summary_caption: \"Fixed CORS, tests failing\",\n    reference_point: \"cors fixed but tests failing\",\n    status_snapshot: {\n      next_action: \"Debug and fix test_login_flow failure\",\n      tests_failing: [\"test_login_flow\"],\n    },\n  },\n  {\n    id: \"frame-jkl012\",\n    timestamp: \"2025-11-03T11:20:00-05:00\",\n    branch: \"feature/user-auth\",\n    jira: \"TICKET-123\",\n    module_scope: [\"ui/login-form\", \"services/auth-core\"],\n    summary_caption: \"All tests passing\",\n    reference_point: \"tests passing ready for review\",\n    status_snapshot: {\n      next_action: \"Submit PR and request code review\",\n    },\n  },\n];\n\n// Build timeline\nconst timeline = buildTimeline(frames);\n\n// Render text output\nconsole.log(\"=\".repeat(80));\nconsole.log(\"TIMELINE TEXT OUTPUT\");\nconsole.log(\"=\".repeat(80));\nconsole.log();\nconst textOutput = renderTimelineText(timeline, \"TICKET-123: Add user authentication\");\nconsole.log(textOutput);\n\n// Module scope evolution\nconsole.log(\"=\".repeat(80));\nconsole.log(\"MODULE SCOPE EVOLUTION\");\nconsole.log(\"=\".repeat(80));\nconst evolutionGraph = renderModuleScopeEvolution(timeline);\nconsole.log(evolutionGraph);\n\n// Blocker tracking\nconsole.log(\"=\".repeat(80));\nconsole.log(\"BLOCKER TRACKING\");\nconsole.log(\"=\".repeat(80));\nconst blockerTracking = renderBlockerTracking(timeline);\nconsole.log(blockerTracking);\n\n// Generate HTML output (optional)\nconst htmlOutput = renderTimelineHTML(timeline, \"TICKET-123: Add user authentication\");\nconsole.log(\"=\".repeat(80));\nconsole.log(\"HTML OUTPUT (preview)\");\nconsole.log(\"=\".repeat(80));\nconsole.log(\"HTML file would be written to disk.\");\nconsole.log(\"Length:\", htmlOutput.length, \"characters\");\nconsole.log(\"Contains title:\", htmlOutput.includes(\"TICKET-123\"));\nconsole.log();\n\n// Uncomment to write HTML to file:\n// writeFileSync('/tmp/timeline-example.html', htmlOutput, 'utf-8');\n// console.log('✓ HTML timeline written to /tmp/timeline-example.html');\n","usedDeprecatedRules":[]},{"filePath":"/srv/lex-mcp/lex/src/memory/renderer/timeline.ts","messages":[{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.","line":188,"column":6,"nodeType":"ChainExpression","messageId":"conditionErrorNullableNumber","endLine":188,"endColumn":44,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[5105,5143],"text":"((frame.status_snapshot.blockers?.length) != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultZero","fix":{"range":[5105,5143],"text":"((frame.status_snapshot.blockers?.length) ?? 0)"},"desc":"Explicitly treat nullish value the same as 0 (`value ?? 0`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[5105,5143],"text":"(Boolean((frame.status_snapshot.blockers?.length)))"},"desc":"Explicitly convert value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.","line":189,"column":6,"nodeType":"ChainExpression","messageId":"conditionErrorNullableNumber","endLine":189,"endColumn":50,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[5162,5206],"text":"((frame.status_snapshot.merge_blockers?.length) != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultZero","fix":{"range":[5162,5206],"text":"((frame.status_snapshot.merge_blockers?.length) ?? 0)"},"desc":"Explicitly treat nullish value the same as 0 (`value ?? 0`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[5162,5206],"text":"(Boolean((frame.status_snapshot.merge_blockers?.length)))"},"desc":"Explicitly convert value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.","line":190,"column":28,"nodeType":"ChainExpression","messageId":"conditionErrorNullableNumber","endLine":190,"endColumn":71,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[5245,5288],"text":"((frame.status_snapshot.tests_failing?.length) != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultZero","fix":{"range":[5245,5288],"text":"((frame.status_snapshot.tests_failing?.length) ?? 0)"},"desc":"Explicitly treat nullish value the same as 0 (`value ?? 0`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[5245,5288],"text":"(Boolean((frame.status_snapshot.tests_failing?.length)))"},"desc":"Explicitly convert value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.","line":470,"column":6,"nodeType":"ChainExpression","messageId":"conditionErrorNullableNumber","endLine":470,"endColumn":44,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[12086,12124],"text":"((frame.status_snapshot.blockers?.length) != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultZero","fix":{"range":[12086,12124],"text":"((frame.status_snapshot.blockers?.length) ?? 0)"},"desc":"Explicitly treat nullish value the same as 0 (`value ?? 0`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[12086,12124],"text":"(Boolean((frame.status_snapshot.blockers?.length)))"},"desc":"Explicitly convert value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.","line":471,"column":6,"nodeType":"ChainExpression","messageId":"conditionErrorNullableNumber","endLine":471,"endColumn":50,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[12143,12187],"text":"((frame.status_snapshot.merge_blockers?.length) != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultZero","fix":{"range":[12143,12187],"text":"((frame.status_snapshot.merge_blockers?.length) ?? 0)"},"desc":"Explicitly treat nullish value the same as 0 (`value ?? 0`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[12143,12187],"text":"(Boolean((frame.status_snapshot.merge_blockers?.length)))"},"desc":"Explicitly convert value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.","line":472,"column":28,"nodeType":"ChainExpression","messageId":"conditionErrorNullableNumber","endLine":472,"endColumn":71,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[12226,12269],"text":"((frame.status_snapshot.tests_failing?.length) != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultZero","fix":{"range":[12226,12269],"text":"((frame.status_snapshot.tests_failing?.length) ?? 0)"},"desc":"Explicitly treat nullish value the same as 0 (`value ?? 0`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[12226,12269],"text":"(Boolean((frame.status_snapshot.tests_failing?.length)))"},"desc":"Explicitly convert value to a boolean (`Boolean(value)`)"}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":6,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Timeline Renderer - Visual timeline showing Frame evolution\n *\n * Renders Frames for a ticket/branch as a timeline with:\n * - Module scope evolution (what modules were touched when)\n * - Blocker introduction and resolution tracking\n * - Status updates over time\n */\n\nimport type { Frame } from \"./types.js\";\n\n/**\n * Timeline entry representing a single Frame in the timeline\n */\nexport interface TimelineEntry {\n  frame: Frame;\n  modulesAdded: string[];\n  modulesRemoved: string[];\n  blockersAdded: string[];\n  blockersRemoved: string[];\n}\n\n/**\n * Timeline filter options\n */\nexport interface TimelineOptions {\n  since?: Date;\n  until?: Date;\n  format?: \"text\" | \"json\" | \"html\";\n}\n\n/**\n * Build timeline from frames (chronologically ordered)\n */\nexport function buildTimeline(frames: Frame[]): TimelineEntry[] {\n  if (frames.length === 0) {\n    return [];\n  }\n\n  // Sort frames chronologically (oldest first)\n  const sortedFrames = [...frames].sort(\n    (a, b) => new Date(a.timestamp).getTime() - new Date(b.timestamp).getTime()\n  );\n\n  const timeline: TimelineEntry[] = [];\n  let previousModules = new Set<string>();\n  let previousBlockers = new Set<string>();\n\n  for (const frame of sortedFrames) {\n    const currentModules = new Set(frame.module_scope);\n    const currentBlockers = new Set([\n      ...(frame.status_snapshot.blockers || []),\n      ...(frame.status_snapshot.merge_blockers || []),\n    ]);\n\n    // Calculate changes\n    const modulesAdded = Array.from(currentModules).filter((m) => !previousModules.has(m));\n    const modulesRemoved = Array.from(previousModules).filter((m) => !currentModules.has(m));\n    const blockersAdded = Array.from(currentBlockers).filter((b) => !previousBlockers.has(b));\n    const blockersRemoved = Array.from(previousBlockers).filter((b) => !currentBlockers.has(b));\n\n    timeline.push({\n      frame,\n      modulesAdded,\n      modulesRemoved,\n      blockersAdded,\n      blockersRemoved,\n    });\n\n    previousModules = currentModules;\n    previousBlockers = currentBlockers;\n  }\n\n  return timeline;\n}\n\n/**\n * Filter timeline by date range\n */\nexport function filterTimeline(\n  timeline: TimelineEntry[],\n  options: TimelineOptions\n): TimelineEntry[] {\n  let filtered = timeline;\n\n  if (options.since) {\n    const sinceDate = options.since;\n    filtered = filtered.filter((entry) => new Date(entry.frame.timestamp) >= sinceDate);\n  }\n\n  if (options.until) {\n    const untilDate = options.until;\n    filtered = filtered.filter((entry) => new Date(entry.frame.timestamp) <= untilDate);\n  }\n\n  return filtered;\n}\n\n/**\n * Render timeline as text\n */\nexport function renderTimelineText(timeline: TimelineEntry[], title: string): string {\n  if (timeline.length === 0) {\n    return `\\n${title}\\nNo frames found.\\n`;\n  }\n\n  const lines: string[] = [];\n  lines.push(\"\");\n  lines.push(title);\n  lines.push(\"═\".repeat(title.length));\n  lines.push(\"\");\n\n  for (let i = 0; i < timeline.length; i++) {\n    const entry = timeline[i];\n    const frame = entry.frame;\n    const date = new Date(frame.timestamp);\n    const dateStr = date.toLocaleString(\"en-US\", {\n      month: \"short\",\n      day: \"numeric\",\n      hour: \"2-digit\",\n      minute: \"2-digit\",\n    });\n\n    // Frame header\n    lines.push(`${dateStr}  [Frame #${frame.id.slice(0, 8)}]  ${frame.summary_caption}`);\n\n    // Consistent indentation for all frame details\n    const modulePrefix = \"              \";\n\n    // Modules\n    if (frame.module_scope.length > 0) {\n      lines.push(`${modulePrefix}Modules: ${frame.module_scope.join(\", \")}`);\n\n      // Show module changes\n      if (entry.modulesAdded.length > 0) {\n        lines.push(`${modulePrefix}         + Added: ${entry.modulesAdded.join(\", \")}`);\n      }\n      if (entry.modulesRemoved.length > 0) {\n        lines.push(`${modulePrefix}         - Removed: ${entry.modulesRemoved.join(\", \")}`);\n      }\n    }\n\n    // Status indicator\n    const statusIndicator = getStatusIndicator(frame);\n    lines.push(`${modulePrefix}Status: ${statusIndicator}`);\n\n    // Blockers\n    const allBlockers = [\n      ...(frame.status_snapshot.blockers || []),\n      ...(frame.status_snapshot.merge_blockers || []),\n    ];\n\n    if (allBlockers.length > 0) {\n      for (const blocker of allBlockers) {\n        const isNew = entry.blockersAdded.includes(blocker);\n        const marker = isNew ? \"+ \" : \"  \";\n        lines.push(`${modulePrefix}         ${marker}⚠️  ${blocker}`);\n      }\n    }\n\n    if (entry.blockersRemoved.length > 0) {\n      for (const blocker of entry.blockersRemoved) {\n        lines.push(`${modulePrefix}         - ✅ Resolved: ${blocker}`);\n      }\n    }\n\n    // Tests failing\n    if (frame.status_snapshot.tests_failing && frame.status_snapshot.tests_failing.length > 0) {\n      for (const test of frame.status_snapshot.tests_failing) {\n        lines.push(`${modulePrefix}         ❌ ${test}`);\n      }\n    }\n\n    lines.push(\"\");\n  }\n\n  lines.push(\"═\".repeat(title.length));\n  lines.push(\"\");\n\n  return lines.join(\"\\n\");\n}\n\n/**\n * Get status indicator emoji for a frame\n */\nfunction getStatusIndicator(frame: Frame): string {\n  const hasBlockers =\n    (frame.status_snapshot.blockers?.length || 0) > 0 ||\n    (frame.status_snapshot.merge_blockers?.length || 0) > 0;\n  const hasTestFailures = (frame.status_snapshot.tests_failing?.length || 0) > 0;\n\n  if (hasBlockers) {\n    return \"⚠️  Blocked\";\n  } else if (hasTestFailures) {\n    return \"❌ Tests failing\";\n  } else {\n    return \"✅ In progress\";\n  }\n}\n\n/**\n * Render module scope evolution graph\n */\nexport function renderModuleScopeEvolution(timeline: TimelineEntry[]): string {\n  if (timeline.length === 0) {\n    return \"\";\n  }\n\n  const lines: string[] = [];\n  lines.push(\"\");\n  lines.push(\"Module Scope Evolution:\");\n  lines.push(\"\");\n\n  // Collect all modules that appear in any frame\n  const moduleAppearances = new Map<string, Set<number>>();\n\n  timeline.forEach((entry, index) => {\n    entry.frame.module_scope.forEach((module) => {\n      if (!moduleAppearances.has(module)) {\n        moduleAppearances.set(module, new Set());\n      }\n      const appearances = moduleAppearances.get(module);\n      if (appearances) {\n        appearances.add(index);\n      }\n    });\n  });\n\n  // Render each module with a visual representation\n  const maxModuleNameLength = Math.max(\n    ...Array.from(moduleAppearances.keys()).map((m) => m.length)\n  );\n\n  for (const [module, appearances] of Array.from(moduleAppearances.entries()).sort()) {\n    const paddedModule = module.padEnd(maxModuleNameLength);\n    const graph = Array.from({ length: timeline.length }, (_, i) =>\n      appearances.has(i) ? \"█\" : \" \"\n    ).join(\"\");\n\n    const frameCount = `(${appearances.size}/${timeline.length} frames)`;\n    lines.push(`${paddedModule}  ${graph}  ${frameCount}`);\n  }\n\n  lines.push(\"\");\n  return lines.join(\"\\n\");\n}\n\n/**\n * Render blocker tracking summary\n */\nexport function renderBlockerTracking(timeline: TimelineEntry[]): string {\n  if (timeline.length === 0) {\n    return \"\";\n  }\n\n  const lines: string[] = [];\n  lines.push(\"\");\n  lines.push(\"Blocker Tracking:\");\n  lines.push(\"\");\n\n  for (let i = 0; i < timeline.length; i++) {\n    const entry = timeline[i];\n    const frame = entry.frame;\n    const allBlockers = [\n      ...(frame.status_snapshot.blockers || []),\n      ...(frame.status_snapshot.merge_blockers || []),\n    ];\n\n    lines.push(`Frame ${i + 1}:`);\n\n    if (entry.blockersAdded.length > 0) {\n      for (const blocker of entry.blockersAdded) {\n        lines.push(`  + ${blocker}`);\n      }\n    }\n\n    if (entry.blockersRemoved.length > 0) {\n      for (const blocker of entry.blockersRemoved) {\n        lines.push(`  - ${blocker} (resolved)`);\n      }\n    }\n\n    if (\n      allBlockers.length === 0 &&\n      entry.blockersAdded.length === 0 &&\n      entry.blockersRemoved.length === 0\n    ) {\n      lines.push(`  No blockers`);\n    }\n  }\n\n  lines.push(\"\");\n  return lines.join(\"\\n\");\n}\n\n/**\n * Render timeline as JSON\n */\nexport function renderTimelineJSON(timeline: TimelineEntry[]): string {\n  return JSON.stringify(timeline, null, 2);\n}\n\n/**\n * Render timeline as HTML (basic implementation)\n */\nexport function renderTimelineHTML(timeline: TimelineEntry[], title: string): string {\n  const html = `\n<!DOCTYPE html>\n<html>\n<head>\n  <meta charset=\"utf-8\">\n  <title>${title}</title>\n  <style>\n    body {\n      font-family: -apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto, Helvetica, Arial, sans-serif;\n      max-width: 1200px;\n      margin: 40px auto;\n      padding: 0 20px;\n      background: #f5f5f5;\n    }\n    h1 {\n      border-bottom: 3px solid #333;\n      padding-bottom: 10px;\n    }\n    .timeline {\n      position: relative;\n      padding-left: 40px;\n    }\n    .timeline::before {\n      content: '';\n      position: absolute;\n      left: 10px;\n      top: 0;\n      bottom: 0;\n      width: 2px;\n      background: #ccc;\n    }\n    .entry {\n      position: relative;\n      margin-bottom: 30px;\n      background: white;\n      padding: 20px;\n      border-radius: 8px;\n      box-shadow: 0 2px 4px rgba(0,0,0,0.1);\n    }\n    .entry::before {\n      content: '';\n      position: absolute;\n      left: -30px;\n      top: 20px;\n      width: 12px;\n      height: 12px;\n      border-radius: 50%;\n      background: #4CAF50;\n      border: 2px solid white;\n    }\n    .date {\n      color: #666;\n      font-size: 0.9em;\n      margin-bottom: 5px;\n    }\n    .frame-id {\n      color: #999;\n      font-size: 0.85em;\n      font-family: monospace;\n    }\n    .summary {\n      font-weight: 600;\n      font-size: 1.1em;\n      margin: 10px 0;\n    }\n    .modules {\n      margin: 10px 0;\n      padding: 10px;\n      background: #f8f8f8;\n      border-radius: 4px;\n    }\n    .status {\n      display: inline-block;\n      padding: 4px 8px;\n      border-radius: 4px;\n      font-size: 0.9em;\n      margin: 5px 0;\n    }\n    .status.progress { background: #e3f2fd; color: #1976d2; }\n    .status.blocked { background: #fff3e0; color: #f57c00; }\n    .status.failing { background: #ffebee; color: #c62828; }\n    .blockers {\n      margin: 10px 0;\n    }\n    .blocker {\n      padding: 8px;\n      margin: 5px 0;\n      background: #fff3e0;\n      border-left: 3px solid #ff9800;\n      border-radius: 4px;\n    }\n    .change {\n      font-size: 0.9em;\n      color: #666;\n      margin-left: 10px;\n    }\n  </style>\n</head>\n<body>\n  <h1>${title}</h1>\n  <div class=\"timeline\">\n    ${timeline.map((entry) => renderEntryHTML(entry)).join(\"\\n\")}\n  </div>\n</body>\n</html>\n`;\n  return html;\n}\n\n/**\n * Render a single timeline entry as HTML\n */\nfunction renderEntryHTML(entry: TimelineEntry): string {\n  const frame = entry.frame;\n  const date = new Date(frame.timestamp);\n  const dateStr = date.toLocaleString();\n\n  const statusClass = getStatusClass(frame);\n  const statusText = getStatusIndicator(frame);\n\n  const allBlockers = [\n    ...(frame.status_snapshot.blockers || []),\n    ...(frame.status_snapshot.merge_blockers || []),\n  ];\n\n  return `\n    <div class=\"entry\">\n      <div class=\"date\">${dateStr}</div>\n      <div class=\"frame-id\">Frame #${frame.id.slice(0, 8)}</div>\n      <div class=\"summary\">${escapeHtml(frame.summary_caption)}</div>\n      <div class=\"modules\">\n        <strong>Modules:</strong> ${frame.module_scope.join(\", \")}\n        ${entry.modulesAdded.length > 0 ? `<span class=\"change\">+ ${entry.modulesAdded.join(\", \")}</span>` : \"\"}\n        ${entry.modulesRemoved.length > 0 ? `<span class=\"change\">- ${entry.modulesRemoved.join(\", \")}</span>` : \"\"}\n      </div>\n      <div class=\"status ${statusClass}\">${statusText}</div>\n      ${\n        allBlockers.length > 0\n          ? `\n        <div class=\"blockers\">\n          ${allBlockers.map((b) => `<div class=\"blocker\">${escapeHtml(b)}</div>`).join(\"\")}\n        </div>\n      `\n          : \"\"\n      }\n      ${\n        entry.blockersRemoved.length > 0\n          ? `\n        <div style=\"color: #4CAF50; margin-top: 10px;\">\n          ✅ Resolved: ${entry.blockersRemoved.join(\", \")}\n        </div>\n      `\n          : \"\"\n      }\n    </div>\n  `;\n}\n\n/**\n * Get status CSS class for a frame\n */\nfunction getStatusClass(frame: Frame): string {\n  const hasBlockers =\n    (frame.status_snapshot.blockers?.length || 0) > 0 ||\n    (frame.status_snapshot.merge_blockers?.length || 0) > 0;\n  const hasTestFailures = (frame.status_snapshot.tests_failing?.length || 0) > 0;\n\n  if (hasBlockers) return \"blocked\";\n  if (hasTestFailures) return \"failing\";\n  return \"progress\";\n}\n\n/**\n * Escape HTML special characters\n */\nfunction escapeHtml(text: string): string {\n  const map: Record<string, string> = {\n    \"&\": \"&amp;\",\n    \"<\": \"&lt;\",\n    \">\": \"&gt;\",\n    '\"': \"&quot;\",\n    \"'\": \"&#039;\",\n  };\n  return text.replace(/[&<>\"']/g, (m) => map[m]);\n}\n","usedDeprecatedRules":[]},{"filePath":"/srv/lex-mcp/lex/src/memory/renderer/types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/srv/lex-mcp/lex/src/memory/store/db.ts","messages":[{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":39,"column":7,"nodeType":"MemberExpression","messageId":"conditionErrorNullableString","endLine":39,"endColumn":30,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[1258,1281],"text":"process.env.LEX_DB_PATH != null"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[1258,1281],"text":"process.env.LEX_DB_PATH ?? \"\""},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[1258,1281],"text":"Boolean(process.env.LEX_DB_PATH)"},"desc":"Explicitly convert value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":1,"message":"Unsafe assignment of an `any` value.","line":70,"column":9,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":70,"endColumn":49},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":1,"message":"Unsafe call of a(n) `any` typed value.","line":72,"column":26,"nodeType":"Identifier","messageId":"unsafeCall","endLine":72,"endColumn":35},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":1,"message":"Unsafe assignment of an `any` value.","line":76,"column":15,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":76,"endColumn":93},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":1,"message":"Unsafe call of a(n) `any` typed value.","line":76,"column":40,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":76,"endColumn":66},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .readFileSync on an `any` value.","line":76,"column":54,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":76,"endColumn":66},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .name on an `any` value.","line":77,"column":25,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":77,"endColumn":29},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":1,"message":"Unsafe assignment of an `any` value.","line":84,"column":5,"nodeType":"AssignmentExpression","messageId":"anyAssignment","endLine":84,"endColumn":41},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":1,"message":"Unsafe call of a(n) `any` typed value.","line":84,"column":19,"nodeType":"Identifier","messageId":"unsafeCall","endLine":84,"endColumn":28},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.","line":113,"column":26,"nodeType":"ChainExpression","messageId":"conditionErrorNullableNumber","endLine":113,"endColumn":45,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[3433,3452],"text":"((versionRow?.version) != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultZero","fix":{"range":[3433,3452],"text":"((versionRow?.version) ?? 0)"},"desc":"Explicitly treat nullish value the same as 0 (`value ?? 0`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[3433,3452],"text":"(Boolean((versionRow?.version)))"},"desc":"Explicitly convert value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":250,"column":16,"nodeType":"Identifier","messageId":"conditionErrorNullableString","endLine":250,"endColumn":22,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[7081,7087],"text":"(dbPath != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[7081,7087],"text":"(dbPath ?? \"\")"},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[7081,7087],"text":"(Boolean(dbPath))"},"desc":"Explicitly convert value to a boolean (`Boolean(value)`)"}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":11,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Database initialization and schema management for Frame storage\n *\n * Creates SQLite database with FTS5 virtual table for full-text search\n * on reference_point, keywords, and summary_caption.\n */\n\nimport Database from \"better-sqlite3\";\nimport { homedir } from \"os\";\nimport { join } from \"path\";\nimport { mkdirSync, existsSync } from \"fs\";\n\nexport interface FrameRow {\n  id: string;\n  timestamp: string;\n  branch: string;\n  jira: string | null;\n  module_scope: string; // JSON stringified array\n  summary_caption: string;\n  reference_point: string;\n  status_snapshot: string; // JSON stringified object\n  keywords: string | null; // JSON stringified array\n  atlas_frame_id: string | null;\n  feature_flags: string | null; // JSON stringified array\n  permissions: string | null; // JSON stringified array\n  // Merge-weave metadata (v2)\n  run_id: string | null;\n  plan_hash: string | null;\n  spend: string | null; // JSON stringified object\n}\n\n/**\n * Get default database path: .smartergpt.local/lex/memory.db (relative to repo root)\n * Falls back to ~/.lex/frames.db if not in a lex repository\n * Can be overridden with LEX_DB_PATH environment variable\n */\nexport function getDefaultDbPath(): string {\n  // Check for environment variable override\n  if (process.env.LEX_DB_PATH) {\n    return process.env.LEX_DB_PATH;\n  }\n\n  // Try to find repo root\n  try {\n    const repoRoot = findRepoRoot(process.cwd());\n    const localPath = join(repoRoot, \".smartergpt.local\", \"lex\", \"memory.db\");\n    \n    // Ensure directory exists\n    const localDir = join(repoRoot, \".smartergpt.local\", \"lex\");\n    if (!existsSync(localDir)) {\n      mkdirSync(localDir, { recursive: true });\n    }\n    \n    return localPath;\n  } catch {\n    // Fallback to home directory if not in repo\n    const lexDir = join(homedir(), \".lex\");\n    if (!existsSync(lexDir)) {\n      mkdirSync(lexDir, { recursive: true });\n    }\n    return join(lexDir, \"frames.db\");\n  }\n}\n\n/**\n * Find repository root by looking for package.json with name \"lex\"\n */\nfunction findRepoRoot(startPath: string): string {\n  let currentPath = startPath;\n  const { dirname: parentDir } = require(\"path\");\n\n  while (currentPath !== parentDir(currentPath)) {\n    const packageJsonPath = join(currentPath, \"package.json\");\n    if (existsSync(packageJsonPath)) {\n      try {\n        const packageJson = JSON.parse(require(\"fs\").readFileSync(packageJsonPath, \"utf-8\"));\n        if (packageJson.name === \"lex\") {\n          return currentPath;\n        }\n      } catch {\n        // Invalid package.json, continue searching\n      }\n    }\n    currentPath = parentDir(currentPath);\n  }\n\n  throw new Error(\"Repository root not found\");\n}\n\n/**\n * Initialize database with schema and indexes\n */\nexport function initializeDatabase(db: Database.Database): void {\n  // Set SQLite pragmas for performance and reliability\n  db.pragma(\"journal_mode = WAL\");\n  db.pragma(\"busy_timeout = 5000\");\n  db.pragma(\"synchronous = NORMAL\");\n  db.pragma(\"cache_size = 10000\");\n  db.pragma(\"foreign_keys = ON\");\n\n  // Create schema version table for migration support\n  db.exec(`\n    CREATE TABLE IF NOT EXISTS schema_version (\n      version INTEGER PRIMARY KEY,\n      applied_at TEXT NOT NULL DEFAULT (datetime('now'))\n    );\n  `);\n\n  // Check current schema version\n  const versionRow = db.prepare(\"SELECT MAX(version) as version FROM schema_version\").get() as {\n    version: number | null;\n  };\n  const currentVersion = versionRow?.version || 0;\n\n  // Apply migrations\n  if (currentVersion < 1) {\n    applyMigrationV1(db);\n    db.prepare(\"INSERT INTO schema_version (version) VALUES (?)\").run(1);\n  }\n  if (currentVersion < 2) {\n    applyMigrationV2(db);\n    db.prepare(\"INSERT INTO schema_version (version) VALUES (?)\").run(2);\n  }\n  if (currentVersion < 3) {\n    applyMigrationV3(db);\n    db.prepare(\"INSERT INTO schema_version (version) VALUES (?)\").run(3);\n  }\n}\n\n/**\n * Migration V1: Initial schema\n */\nfunction applyMigrationV1(db: Database.Database): void {\n  // Create frames table with all fields from FRAME.md\n  db.exec(`\n    CREATE TABLE IF NOT EXISTS frames (\n      id TEXT PRIMARY KEY,\n      timestamp TEXT NOT NULL,\n      branch TEXT NOT NULL,\n      jira TEXT,\n      module_scope TEXT NOT NULL,\n      summary_caption TEXT NOT NULL,\n      reference_point TEXT NOT NULL,\n      status_snapshot TEXT NOT NULL,\n      keywords TEXT,\n      atlas_frame_id TEXT,\n      feature_flags TEXT,\n      permissions TEXT\n    );\n  `);\n\n  // Create FTS5 virtual table for fuzzy search on reference_point, keywords, summary_caption\n  db.exec(`\n    CREATE VIRTUAL TABLE IF NOT EXISTS frames_fts USING fts5(\n      reference_point,\n      summary_caption,\n      keywords,\n      content='frames',\n      content_rowid='rowid'\n    );\n  `);\n\n  // Create triggers to keep FTS index in sync with frames table\n  db.exec(`\n    CREATE TRIGGER IF NOT EXISTS frames_ai AFTER INSERT ON frames BEGIN\n      INSERT INTO frames_fts(rowid, reference_point, summary_caption, keywords)\n      VALUES (new.rowid, new.reference_point, new.summary_caption, new.keywords);\n    END;\n  `);\n\n  db.exec(`\n    CREATE TRIGGER IF NOT EXISTS frames_ad AFTER DELETE ON frames BEGIN\n      DELETE FROM frames_fts WHERE rowid = old.rowid;\n    END;\n  `);\n\n  db.exec(`\n    CREATE TRIGGER IF NOT EXISTS frames_au AFTER UPDATE ON frames BEGIN\n      UPDATE frames_fts\n      SET reference_point = new.reference_point,\n          summary_caption = new.summary_caption,\n          keywords = new.keywords\n      WHERE rowid = new.rowid;\n    END;\n  `);\n\n  // Create indexes for common query patterns\n  db.exec(`\n    CREATE INDEX IF NOT EXISTS idx_frames_timestamp ON frames(timestamp DESC);\n  `);\n\n  db.exec(`\n    CREATE INDEX IF NOT EXISTS idx_frames_branch ON frames(branch);\n  `);\n\n  db.exec(`\n    CREATE INDEX IF NOT EXISTS idx_frames_jira ON frames(jira);\n  `);\n\n  db.exec(`\n    CREATE INDEX IF NOT EXISTS idx_frames_atlas_frame_id ON frames(atlas_frame_id);\n  `);\n}\n\n/**\n * Migration V2: Add images table\n */\nfunction applyMigrationV2(db: Database.Database): void {\n  // Create images table for Frame attachments\n  db.exec(`\n    CREATE TABLE IF NOT EXISTS images (\n      image_id TEXT PRIMARY KEY,\n      frame_id TEXT NOT NULL,\n      data BLOB NOT NULL,\n      mime_type TEXT NOT NULL,\n      created_at INTEGER NOT NULL,\n      FOREIGN KEY (frame_id) REFERENCES frames(id) ON DELETE CASCADE\n    );\n  `);\n\n  // Create index for frame_id lookups\n  db.exec(`\n    CREATE INDEX IF NOT EXISTS idx_images_frame_id ON images(frame_id);\n  `);\n}\n\n/**\n * Migration V3: Add merge-weave metadata fields (Frame schema v2)\n */\nfunction applyMigrationV3(db: Database.Database): void {\n  // Add new optional columns for merge-weave provenance\n  // Safe to add with NULL default, backward compatible\n  db.exec(`\n    ALTER TABLE frames ADD COLUMN run_id TEXT;\n  `);\n\n  db.exec(`\n    ALTER TABLE frames ADD COLUMN plan_hash TEXT;\n  `);\n\n  db.exec(`\n    ALTER TABLE frames ADD COLUMN spend TEXT;\n  `);\n}\n\n/**\n * Create and initialize a database connection\n */\nexport function createDatabase(dbPath?: string): Database.Database {\n  const path = dbPath || getDefaultDbPath();\n  const db = new Database(path);\n  initializeDatabase(db);\n  return db;\n}\n","usedDeprecatedRules":[]},{"filePath":"/srv/lex-mcp/lex/src/memory/store/framestore.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":61,"column":22,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":61,"endColumn":25,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1629,1632],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1629,1632],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":75,"column":29,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":75,"endColumn":32,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1940,1943],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1940,1943],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":88,"column":7,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":88,"endColumn":10,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2266,2269],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2266,2269],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":89,"column":9,"nodeType":"MemberExpression","messageId":"conditionErrorNullableString","endLine":89,"endColumn":30,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[2282,2303],"text":"query.reference_point != null"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[2282,2303],"text":"query.reference_point ?? \"\""},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[2282,2303],"text":"Boolean(query.reference_point)"},"desc":"Explicitly convert value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":94,"column":9,"nodeType":"MemberExpression","messageId":"conditionErrorNullableString","endLine":94,"endColumn":19,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[2465,2475],"text":"query.jira != null"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[2465,2475],"text":"query.jira ?? \"\""},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[2465,2475],"text":"Boolean(query.jira)"},"desc":"Explicitly convert value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":98,"column":9,"nodeType":"MemberExpression","messageId":"conditionErrorNullableString","endLine":98,"endColumn":21,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[2545,2557],"text":"query.branch != null"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[2545,2557],"text":"query.branch ?? \"\""},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[2545,2557],"text":"Boolean(query.branch)"},"desc":"Explicitly convert value to a boolean (`Boolean(value)`)"}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":6,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// Legacy class-based API for Frame storage\n// Wraps the new modular implementation (db.ts, queries.ts, index.ts)\n// This provides backward compatibility while using the new modular code internally\n\nimport Database from \"better-sqlite3\";\nimport { createDatabase } from \"./db.js\";\nimport {\n  saveFrame as save,\n  getFrameById as getById,\n  searchFrames as search,\n  deleteFrame as remove,\n  getFramesByBranch,\n  getFramesByJira,\n  getAllFrames,\n} from \"./queries.js\";\nimport type { Frame } from \"../frames/types.js\";\n\nexport interface FrameRow {\n  id: string;\n  timestamp: string;\n  branch: string;\n  jira: string | null;\n  module_scope: string; // JSON stringified array\n  summary_caption: string;\n  reference_point: string;\n  status_snapshot: string; // JSON stringified object\n  keywords: string | null; // JSON stringified array\n  atlas_frame_id: string | null;\n}\n\n/**\n * Frame storage manager using SQLite\n *\n * @deprecated Use the modular API from index.ts instead\n * @example\n * ```typescript\n * // Old API (still works)\n * const store = new FrameStore('/path/to/db');\n * store.insertFrame(frame);\n *\n * // New API (recommended)\n * import { getDb, saveFrame } from 'lex/store';\n * const db = getDb('/path/to/db');\n * saveFrame(db, frame);\n * ```\n *\n * Frames are stored locally with full-text search on reference_point for fuzzy recall.\n * No telemetry. No cloud sync.\n */\nexport class FrameStore {\n  private db: Database.Database;\n\n  constructor(dbPath: string) {\n    this.db = createDatabase(dbPath);\n  }\n\n  /**\n   * Insert or update a Frame\n   * @deprecated Use saveFrame from the modular API\n   */\n  insertFrame(frame: any): boolean {\n    try {\n      save(this.db, frame as Frame);\n      return true;\n    } catch (error) {\n      console.error(\"Failed to insert frame:\", error);\n      return false;\n    }\n  }\n\n  /**\n   * Retrieve Frame by ID\n   * @deprecated Use getFrameById from the modular API\n   */\n  getFrameById(id: string): any | null {\n    return getById(this.db, id);\n  }\n\n  /**\n   * Search Frames with FTS and optional filters\n   * @deprecated Use searchFrames, getFramesByBranch, or getFramesByJira from the modular API\n   */\n  searchFrames(query: {\n    reference_point?: string;\n    jira?: string;\n    branch?: string;\n    limit?: number;\n  }): any[] {\n    if (query.reference_point) {\n      // Return just the frames array from SearchResult for backward compatibility\n      return search(this.db, query.reference_point).frames;\n    }\n\n    if (query.jira) {\n      return getFramesByJira(this.db, query.jira);\n    }\n\n    if (query.branch) {\n      return getFramesByBranch(this.db, query.branch);\n    }\n\n    return getAllFrames(this.db, query.limit);\n  }\n\n  /**\n   * Delete Frame by ID\n   * @deprecated Use deleteFrame from the modular API\n   */\n  deleteFrame(id: string): boolean {\n    return remove(this.db, id);\n  }\n\n  /**\n   * Close database connection\n   */\n  close() {\n    this.db.close();\n  }\n\n  /**\n   * Get the underlying database instance (for testing/internal use)\n   * @internal\n   */\n  getDatabase(): Database.Database {\n    return this.db;\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/srv/lex-mcp/lex/src/memory/store/images.ts","messages":[{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected any value in conditional. An explicit comparison or type conversion is required.","line":74,"column":10,"nodeType":"Identifier","messageId":"conditionErrorAny","endLine":74,"endColumn":21,"suggestions":[{"messageId":"conditionFixCastBoolean","fix":{"range":[1828,1839],"text":"(Boolean(frameExists))"},"desc":"Explicitly convert value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.","line":189,"column":12,"nodeType":"MemberExpression","messageId":"conditionErrorNullableNumber","endLine":189,"endColumn":24,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[4563,4575],"text":"(result.total != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultZero","fix":{"range":[4563,4575],"text":"(result.total ?? 0)"},"desc":"Explicitly treat nullish value the same as 0 (`value ?? 0`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[4563,4575],"text":"(Boolean(result.total))"},"desc":"Explicitly convert value to a boolean (`Boolean(value)`)"}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Image Manager for Frame Attachments\n *\n * Manages binary image storage in SQLite for Frame visual snapshots.\n * Supports multiple image formats with validation and efficient retrieval.\n */\n\nimport Database from \"better-sqlite3\";\nimport { randomUUID } from \"crypto\";\n\n/**\n * Metadata for a stored image\n */\nexport interface ImageMetadata {\n  image_id: string;\n  frame_id: string;\n  mime_type: string;\n  size: number;\n  created_at: number;\n}\n\n/**\n * Allowed MIME types for image storage\n */\nexport const ALLOWED_MIME_TYPES = [\n  \"image/png\",\n  \"image/jpeg\",\n  \"image/jpg\",\n  \"image/svg+xml\",\n] as const;\n\n/**\n * Maximum image size in bytes (10MB)\n */\nexport const MAX_IMAGE_SIZE = 10 * 1024 * 1024;\n\n/**\n * Image Manager - handles binary image storage for Frames\n */\nexport class ImageManager {\n  private db: Database.Database;\n\n  constructor(db: Database.Database) {\n    this.db = db;\n  }\n\n  /**\n   * Store an image attachment for a Frame\n   *\n   * @param frameId - ID of the Frame to attach the image to\n   * @param data - Binary image data as Buffer\n   * @param mimeType - MIME type of the image (e.g., \"image/png\")\n   * @returns The generated image_id\n   * @throws Error if validation fails\n   */\n  storeImage(frameId: string, data: Buffer, mimeType: string): string {\n    // Validate MIME type\n    if (!(ALLOWED_MIME_TYPES as readonly string[]).includes(mimeType)) {\n      throw new Error(\n        `Invalid MIME type: ${mimeType}. Allowed types: ${ALLOWED_MIME_TYPES.join(\", \")}`\n      );\n    }\n\n    // Validate size\n    if (data.length > MAX_IMAGE_SIZE) {\n      throw new Error(\n        `Image size ${data.length} bytes exceeds maximum ${MAX_IMAGE_SIZE} bytes (10MB)`\n      );\n    }\n\n    // Validate frameId exists\n    const frameExists = this.db.prepare(\"SELECT id FROM frames WHERE id = ?\").get(frameId);\n\n    if (!frameExists) {\n      throw new Error(`Frame not found: ${frameId}`);\n    }\n\n    // Generate image_id and store\n    const imageId = `img-${Date.now()}-${randomUUID()}`;\n    const createdAt = Date.now();\n\n    const stmt = this.db.prepare(`\n      INSERT INTO images (image_id, frame_id, mime_type, data, created_at)\n      VALUES (?, ?, ?, ?, ?)\n    `);\n\n    stmt.run(imageId, frameId, mimeType, data, createdAt);\n\n    return imageId;\n  }\n\n  /**\n   * Retrieve an image by its ID\n   *\n   * @param imageId - The image_id to retrieve\n   * @returns Object containing image data and MIME type, or null if not found\n   */\n  getImage(imageId: string): { data: Buffer; mimeType: string } | null {\n    const stmt = this.db.prepare(`\n      SELECT data, mime_type FROM images WHERE image_id = ?\n    `);\n\n    const row = stmt.get(imageId) as { data: Buffer; mime_type: string } | undefined;\n\n    if (!row) {\n      return null;\n    }\n\n    return {\n      data: row.data,\n      mimeType: row.mime_type,\n    };\n  }\n\n  /**\n   * List all images attached to a Frame\n   *\n   * @param frameId - The Frame ID to list images for\n   * @returns Array of image metadata (without binary data)\n   */\n  listFrameImages(frameId: string): ImageMetadata[] {\n    const stmt = this.db.prepare(`\n      SELECT \n        image_id, \n        frame_id, \n        mime_type, \n        LENGTH(data) as size,\n        created_at\n      FROM images\n      WHERE frame_id = ?\n      ORDER BY created_at ASC\n    `);\n\n    const rows = stmt.all(frameId) as Array<{\n      image_id: string;\n      frame_id: string;\n      mime_type: string;\n      size: number;\n      created_at: number;\n    }>;\n\n    return rows.map((row) => ({\n      image_id: row.image_id,\n      frame_id: row.frame_id,\n      mime_type: row.mime_type,\n      size: row.size,\n      created_at: row.created_at,\n    }));\n  }\n\n  /**\n   * Delete an image by its ID\n   *\n   * @param imageId - The image_id to delete\n   * @returns True if image was deleted, false if not found\n   */\n  deleteImage(imageId: string): boolean {\n    const stmt = this.db.prepare(`\n      DELETE FROM images WHERE image_id = ?\n    `);\n\n    const result = stmt.run(imageId);\n    return result.changes > 0;\n  }\n\n  /**\n   * Get total count of images in storage\n   *\n   * @returns Total number of images\n   */\n  getImageCount(): number {\n    const result = this.db.prepare(\"SELECT COUNT(*) as count FROM images\").get() as {\n      count: number;\n    };\n\n    return result.count;\n  }\n\n  /**\n   * Get total size of all images in storage (in bytes)\n   *\n   * @returns Total size in bytes\n   */\n  getTotalImageSize(): number {\n    const result = this.db.prepare(\"SELECT SUM(LENGTH(data)) as total FROM images\").get() as {\n      total: number | null;\n    };\n\n    return result.total || 0;\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/srv/lex-mcp/lex/src/memory/store/index.ts","messages":[{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":43,"column":22,"nodeType":"Identifier","messageId":"conditionErrorNullableString","endLine":43,"endColumn":32,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[1181,1191],"text":"(customPath != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[1181,1191],"text":"(customPath ?? \"\")"},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[1181,1191],"text":"(Boolean(customPath))"},"desc":"Explicitly convert value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":46,"column":23,"nodeType":"Identifier","messageId":"conditionErrorNullableString","endLine":46,"endColumn":33,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[1301,1311],"text":"(customPath != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[1301,1311],"text":"(customPath ?? \"\")"},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[1301,1311],"text":"(Boolean(customPath))"},"desc":"Explicitly convert value to a boolean (`Boolean(value)`)"}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Frame storage interface\n *\n * Main export for database operations with connection pooling and graceful shutdown.\n *\n * Usage:\n *   import { getDb, saveFrame, getFrameById, searchFrames } from 'lex/store';\n *\n *   const db = getDb();\n *   await saveFrame(db, myFrame);\n *   const frame = await getFrameById(db, 'frame-001');\n *   const results = await searchFrames(db, 'auth deadlock');\n */\n\nimport Database from \"better-sqlite3\";\nimport { createDatabase, getDefaultDbPath } from \"./db.js\";\n\nexport type { FrameRow } from \"./db.js\";\nexport type { Frame, FrameStatusSnapshot } from \"../frames/types.js\";\nexport type { SearchResult } from \"./queries.js\";\n\nexport {\n  saveFrame,\n  getFrameById,\n  searchFrames,\n  getFramesByBranch,\n  getFramesByJira,\n  getFramesByModuleScope,\n  getAllFrames,\n  deleteFrame,\n  getFrameCount,\n} from \"./queries.js\";\n\n// Singleton database instance\nlet dbInstance: Database.Database | null = null;\nlet dbPath: string | null = null;\n\n/**\n * Get or create the database instance\n * @param customPath Optional custom database path (defaults to ~/.lex/frames.db)\n */\nexport function getDb(customPath?: string): Database.Database {\n  const targetPath = customPath || getDefaultDbPath();\n\n  // Create new instance if path changed or no instance exists\n  if (!dbInstance || (customPath && dbPath !== customPath)) {\n    // Close existing instance if path is changing\n    if (dbInstance && dbPath !== targetPath) {\n      dbInstance.close();\n    }\n\n    dbInstance = createDatabase(targetPath);\n    dbPath = targetPath;\n  }\n\n  return dbInstance;\n}\n\n/**\n * Close the database connection gracefully\n */\nexport function closeDb(): void {\n  if (dbInstance) {\n    dbInstance.close();\n    dbInstance = null;\n    dbPath = null;\n  }\n}\n\n/**\n * Handle graceful shutdown on process termination\n */\nfunction setupGracefulShutdown(): void {\n  const shutdown = () => {\n    closeDb();\n    process.exit(0);\n  };\n\n  process.on(\"SIGINT\", shutdown);\n  process.on(\"SIGTERM\", shutdown);\n  process.on(\"beforeExit\", () => {\n    closeDb();\n  });\n}\n\n// Setup shutdown handlers when module is imported\nsetupGracefulShutdown();\n\n// Export database creation for testing\nexport { createDatabase, getDefaultDbPath } from \"./db.js\";\n","usedDeprecatedRules":[]},{"filePath":"/srv/lex-mcp/lex/src/memory/store/queries.ts","messages":[{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":19,"column":11,"nodeType":"MemberExpression","messageId":"conditionErrorNullableString","endLine":19,"endColumn":21,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[431,441],"text":"(frame.jira != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[431,441],"text":"(frame.jira ?? \"\")"},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[431,441],"text":"(Boolean(frame.jira))"},"desc":"Explicitly convert value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":25,"column":21,"nodeType":"MemberExpression","messageId":"conditionErrorNullableString","endLine":25,"endColumn":41,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[743,763],"text":"(frame.atlas_frame_id != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[743,763],"text":"(frame.atlas_frame_id ?? \"\")"},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[743,763],"text":"(Boolean(frame.atlas_frame_id))"},"desc":"Explicitly convert value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":29,"column":13,"nodeType":"MemberExpression","messageId":"conditionErrorNullableString","endLine":29,"endColumn":24,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[982,993],"text":"(frame.runId != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[982,993],"text":"(frame.runId ?? \"\")"},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[982,993],"text":"(Boolean(frame.runId))"},"desc":"Explicitly convert value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":30,"column":16,"nodeType":"MemberExpression","messageId":"conditionErrorNullableString","endLine":30,"endColumn":30,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[1018,1032],"text":"(frame.planHash != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[1018,1032],"text":"(frame.planHash ?? \"\")"},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[1018,1032],"text":"(Boolean(frame.planHash))"},"desc":"Explicitly convert value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":43,"column":11,"nodeType":"MemberExpression","messageId":"conditionErrorNullableString","endLine":43,"endColumn":19,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[1294,1302],"text":"(row.jira != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[1294,1302],"text":"(row.jira ?? \"\")"},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[1294,1302],"text":"(Boolean(row.jira))"},"desc":"Explicitly convert value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":1,"message":"Unsafe assignment of an `any` value.","line":44,"column":5,"nodeType":"Property","messageId":"anyAssignment","endLine":44,"endColumn":47},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":1,"message":"Unsafe assignment of an `any` value.","line":48,"column":5,"nodeType":"Property","messageId":"anyAssignment","endLine":48,"endColumn":66},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":48,"column":15,"nodeType":"MemberExpression","messageId":"conditionErrorNullableString","endLine":48,"endColumn":27,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[1540,1552],"text":"(row.keywords != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[1540,1552],"text":"(row.keywords ?? \"\")"},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[1540,1552],"text":"(Boolean(row.keywords))"},"desc":"Explicitly convert value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":49,"column":21,"nodeType":"MemberExpression","messageId":"conditionErrorNullableString","endLine":49,"endColumn":39,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[1613,1631],"text":"(row.atlas_frame_id != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[1613,1631],"text":"(row.atlas_frame_id ?? \"\")"},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[1613,1631],"text":"(Boolean(row.atlas_frame_id))"},"desc":"Explicitly convert value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":1,"message":"Unsafe assignment of an `any` value.","line":50,"column":5,"nodeType":"Property","messageId":"anyAssignment","endLine":50,"endColumn":81},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":50,"column":20,"nodeType":"MemberExpression","messageId":"conditionErrorNullableString","endLine":50,"endColumn":37,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[1665,1682],"text":"(row.feature_flags != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[1665,1682],"text":"(row.feature_flags ?? \"\")"},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[1665,1682],"text":"(Boolean(row.feature_flags))"},"desc":"Explicitly convert value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":1,"message":"Unsafe assignment of an `any` value.","line":51,"column":5,"nodeType":"Property","messageId":"anyAssignment","endLine":51,"endColumn":75},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":51,"column":18,"nodeType":"MemberExpression","messageId":"conditionErrorNullableString","endLine":51,"endColumn":33,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[1745,1760],"text":"(row.permissions != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[1745,1760],"text":"(row.permissions ?? \"\")"},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[1745,1760],"text":"(Boolean(row.permissions))"},"desc":"Explicitly convert value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":53,"column":12,"nodeType":"MemberExpression","messageId":"conditionErrorNullableString","endLine":53,"endColumn":22,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[1893,1903],"text":"(row.run_id != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[1893,1903],"text":"(row.run_id ?? \"\")"},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[1893,1903],"text":"(Boolean(row.run_id))"},"desc":"Explicitly convert value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":54,"column":15,"nodeType":"MemberExpression","messageId":"conditionErrorNullableString","endLine":54,"endColumn":28,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[1932,1945],"text":"(row.plan_hash != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[1932,1945],"text":"(row.plan_hash ?? \"\")"},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[1932,1945],"text":"(Boolean(row.plan_hash))"},"desc":"Explicitly convert value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":1,"message":"Unsafe assignment of an `any` value.","line":55,"column":5,"nodeType":"Property","messageId":"anyAssignment","endLine":55,"endColumn":57},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":55,"column":12,"nodeType":"MemberExpression","messageId":"conditionErrorNullableString","endLine":55,"endColumn":21,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[1971,1980],"text":"(row.spend != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[1971,1980],"text":"(row.spend ?? \"\")"},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[1971,1980],"text":"(Boolean(row.spend))"},"desc":"Explicitly convert value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":126,"column":19,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":126,"endColumn":22,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3803,3806],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3803,3806],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .code on an `any` value.","line":129,"column":14,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":129,"endColumn":18},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected any value in conditional. An explicit comparison or type conversion is required.","line":130,"column":8,"nodeType":"ChainExpression","messageId":"conditionErrorAny","endLine":130,"endColumn":54,"suggestions":[{"messageId":"conditionFixCastBoolean","fix":{"range":[3943,3989],"text":"(Boolean((error?.message?.includes(\"fts5: syntax error\"))))"},"desc":"Explicitly convert value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":1,"message":"Unsafe call of a(n) `any` typed value.","line":130,"column":8,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":130,"endColumn":32},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .message on an `any` value.","line":130,"column":15,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":130,"endColumn":22},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected any value in conditional. An explicit comparison or type conversion is required.","line":131,"column":9,"nodeType":"ChainExpression","messageId":"conditionErrorAny","endLine":131,"endColumn":51,"suggestions":[{"messageId":"conditionFixCastBoolean","fix":{"range":[4001,4043],"text":"(Boolean((error?.message?.includes(\"no such column\"))))"},"desc":"Explicitly convert value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":1,"message":"Unsafe call of a(n) `any` typed value.","line":131,"column":9,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":131,"endColumn":33},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .message on an `any` value.","line":131,"column":16,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":131,"endColumn":23},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected any value in conditional. An explicit comparison or type conversion is required.","line":132,"column":9,"nodeType":"ChainExpression","messageId":"conditionErrorAny","endLine":132,"endColumn":58,"suggestions":[{"messageId":"conditionFixCastBoolean","fix":{"range":[4055,4104],"text":"(Boolean((error?.message?.includes(\"unknown special query\"))))"},"desc":"Explicitly convert value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":1,"message":"Unsafe call of a(n) `any` typed value.","line":132,"column":9,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":132,"endColumn":33},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .message on an `any` value.","line":132,"column":16,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":132,"endColumn":23},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.","line":203,"column":7,"nodeType":"Identifier","messageId":"conditionErrorNullableNumber","endLine":203,"endColumn":12,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[6079,6084],"text":"(limit != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultZero","fix":{"range":[6079,6084],"text":"(limit ?? 0)"},"desc":"Explicitly treat nullish value the same as 0 (`value ?? 0`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[6079,6084],"text":"(Boolean(limit))"},"desc":"Explicitly convert value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.","line":206,"column":16,"nodeType":"Identifier","messageId":"conditionErrorNullableNumber","endLine":206,"endColumn":21,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[6125,6130],"text":"(limit != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultZero","fix":{"range":[6125,6130],"text":"(limit ?? 0)"},"desc":"Explicitly treat nullish value the same as 0 (`value ?? 0`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[6125,6130],"text":"(Boolean(limit))"},"desc":"Explicitly convert value to a boolean (`Boolean(value)`)"}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":30,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Frame storage queries\n *\n * CRUD operations and search functions for Frames.\n */\n\nimport Database from \"better-sqlite3\";\nimport type { FrameRow } from \"./db.js\";\nimport type { Frame, FrameStatusSnapshot } from \"../frames/types.js\";\n\n/**\n * Convert Frame object to database row\n */\nfunction frameToRow(frame: Frame): FrameRow {\n  return {\n    id: frame.id,\n    timestamp: frame.timestamp,\n    branch: frame.branch,\n    jira: frame.jira || null,\n    module_scope: JSON.stringify(frame.module_scope),\n    summary_caption: frame.summary_caption,\n    reference_point: frame.reference_point,\n    status_snapshot: JSON.stringify(frame.status_snapshot),\n    keywords: frame.keywords ? JSON.stringify(frame.keywords) : null,\n    atlas_frame_id: frame.atlas_frame_id || null,\n    feature_flags: frame.feature_flags ? JSON.stringify(frame.feature_flags) : null,\n    permissions: frame.permissions ? JSON.stringify(frame.permissions) : null,\n    // Merge-weave metadata (v2)\n    run_id: frame.runId || null,\n    plan_hash: frame.planHash || null,\n    spend: frame.spend ? JSON.stringify(frame.spend) : null,\n  };\n}\n\n/**\n * Convert database row to Frame object\n */\nfunction rowToFrame(row: FrameRow): Frame {\n  return {\n    id: row.id,\n    timestamp: row.timestamp,\n    branch: row.branch,\n    jira: row.jira || undefined,\n    module_scope: JSON.parse(row.module_scope),\n    summary_caption: row.summary_caption,\n    reference_point: row.reference_point,\n    status_snapshot: JSON.parse(row.status_snapshot) as FrameStatusSnapshot,\n    keywords: row.keywords ? JSON.parse(row.keywords) : undefined,\n    atlas_frame_id: row.atlas_frame_id || undefined,\n    feature_flags: row.feature_flags ? JSON.parse(row.feature_flags) : undefined,\n    permissions: row.permissions ? JSON.parse(row.permissions) : undefined,\n    // Merge-weave metadata (v2) - backward compatible, defaults to undefined\n    runId: row.run_id || undefined,\n    planHash: row.plan_hash || undefined,\n    spend: row.spend ? JSON.parse(row.spend) : undefined,\n  };\n}\n\n/**\n * Save a Frame to the database (insert or update)\n */\nexport function saveFrame(db: Database.Database, frame: Frame): void {\n  const row = frameToRow(frame);\n\n  const stmt = db.prepare(`\n    INSERT OR REPLACE INTO frames (\n      id, timestamp, branch, jira, module_scope, summary_caption,\n      reference_point, status_snapshot, keywords, atlas_frame_id,\n      feature_flags, permissions, run_id, plan_hash, spend\n    ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)\n  `);\n\n  stmt.run(\n    row.id,\n    row.timestamp,\n    row.branch,\n    row.jira,\n    row.module_scope,\n    row.summary_caption,\n    row.reference_point,\n    row.status_snapshot,\n    row.keywords,\n    row.atlas_frame_id,\n    row.feature_flags,\n    row.permissions,\n    row.run_id,\n    row.plan_hash,\n    row.spend\n  );\n}\n\n/**\n * Get a Frame by ID\n */\nexport function getFrameById(db: Database.Database, id: string): Frame | null {\n  const stmt = db.prepare(\"SELECT * FROM frames WHERE id = ?\");\n  const row = stmt.get(id) as FrameRow | undefined;\n\n  if (!row) return null;\n\n  return rowToFrame(row);\n}\n\nexport interface SearchResult {\n  frames: Frame[];\n  hint?: string;\n}\n\n/**\n * Search Frames using FTS5 full-text search\n * @param query Natural language query string (searches reference_point, summary_caption, keywords)\n * @returns SearchResult with frames array and optional hint for FTS5 syntax errors\n */\nexport function searchFrames(db: Database.Database, query: string): SearchResult {\n  try {\n    const stmt = db.prepare(`\n      SELECT f.*\n      FROM frames f\n      JOIN frames_fts fts ON f.rowid = fts.rowid\n      WHERE frames_fts MATCH ?\n      ORDER BY f.timestamp DESC\n    `);\n\n    const rows = stmt.all(query) as FrameRow[];\n    return { frames: rows.map(rowToFrame) };\n  } catch (error: any) {\n    // Check if this is an FTS5-related error (caused by special characters)\n    if (\n      error?.code === \"SQLITE_ERROR\" &&\n      (error?.message?.includes(\"fts5: syntax error\") ||\n        error?.message?.includes(\"no such column\") ||\n        error?.message?.includes(\"unknown special query\"))\n    ) {\n      // Extract a simpler search term by removing special characters\n      const simplifiedQuery = query.replace(/[^a-zA-Z0-9\\s]/g, \" \").trim();\n      const hint = simplifiedQuery\n        ? `Search contained special characters. Try simpler terms (e.g., '${simplifiedQuery}')`\n        : \"Search contained special characters. Try simpler terms\";\n\n      return {\n        frames: [],\n        hint,\n      };\n    }\n    // Re-throw non-FTS5 errors\n    throw error;\n  }\n}\n\n/**\n * Get all Frames for a specific branch\n */\nexport function getFramesByBranch(db: Database.Database, branch: string): Frame[] {\n  const stmt = db.prepare(`\n    SELECT * FROM frames\n    WHERE branch = ?\n    ORDER BY timestamp DESC\n  `);\n\n  const rows = stmt.all(branch) as FrameRow[];\n  return rows.map(rowToFrame);\n}\n\n/**\n * Get all Frames for a specific Jira/ticket ID\n */\nexport function getFramesByJira(db: Database.Database, jiraId: string): Frame[] {\n  const stmt = db.prepare(`\n    SELECT * FROM frames\n    WHERE jira = ?\n    ORDER BY timestamp DESC\n  `);\n\n  const rows = stmt.all(jiraId) as FrameRow[];\n  return rows.map(rowToFrame);\n}\n\n/**\n * Get all Frames that touch a specific module\n * @param moduleId Module ID to search for in module_scope arrays\n */\nexport function getFramesByModuleScope(db: Database.Database, moduleId: string): Frame[] {\n  // Get all frames and filter in JavaScript to avoid SQL injection\n  // This is safe because module_scope is stored as JSON array\n  const stmt = db.prepare(`\n    SELECT * FROM frames\n    ORDER BY timestamp DESC\n  `);\n\n  const rows = stmt.all() as FrameRow[];\n\n  // Filter frames that contain the moduleId in their module_scope array\n  return rows.map(rowToFrame).filter((frame) => frame.module_scope.includes(moduleId));\n}\n\n/**\n * Get all Frames (with optional limit)\n */\nexport function getAllFrames(db: Database.Database, limit?: number): Frame[] {\n  const stmt = db.prepare(`\n    SELECT * FROM frames\n    ORDER BY timestamp DESC\n    ${limit ? \"LIMIT ?\" : \"\"}\n  `);\n\n  const rows = limit ? (stmt.all(limit) as FrameRow[]) : (stmt.all() as FrameRow[]);\n  return rows.map(rowToFrame);\n}\n\n/**\n * Delete a Frame by ID\n */\nexport function deleteFrame(db: Database.Database, id: string): boolean {\n  const stmt = db.prepare(\"DELETE FROM frames WHERE id = ?\");\n  const result = stmt.run(id);\n  return result.changes > 0;\n}\n\n/**\n * Get count of all Frames\n */\nexport function getFrameCount(db: Database.Database): number {\n  const stmt = db.prepare(\"SELECT COUNT(*) as count FROM frames\");\n  const result = stmt.get() as { count: number };\n  return result.count;\n}\n","usedDeprecatedRules":[]},{"filePath":"/srv/lex-mcp/lex/src/policy/check/lexmap-check.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/srv/lex-mcp/lex/src/policy/check/reporter.ts","messages":[{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected object value in conditional. The condition is always true.","line":100,"column":37,"nodeType":"MemberExpression","messageId":"conditionErrorObject","endLine":100,"endColumn":51},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":227,"column":11,"nodeType":"MemberExpression","messageId":"conditionErrorNullableString","endLine":227,"endColumn":34,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[7082,7105],"text":"violation.target_module != null"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[7082,7105],"text":"violation.target_module ?? \"\""},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[7082,7105],"text":"Boolean(violation.target_module)"},"desc":"Explicitly convert value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":230,"column":11,"nodeType":"MemberExpression","messageId":"conditionErrorNullableString","endLine":230,"endColumn":32,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[7200,7221],"text":"violation.import_from != null"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[7200,7221],"text":"violation.import_from ?? \"\""},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[7200,7221],"text":"Boolean(violation.import_from)"},"desc":"Explicitly convert value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected object value in conditional. The condition is always true.","line":253,"column":10,"nodeType":"MemberExpression","messageId":"conditionErrorObject","endLine":253,"endColumn":34},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected object value in conditional. The condition is always true.","line":269,"column":10,"nodeType":"MemberExpression","messageId":"conditionErrorObject","endLine":269,"endColumn":32}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Policy Violation Reporting\n *\n * Formats and outputs policy violations for human reading and CI/CD integration.\n */\n\nimport { Violation } from \"./violations.js\";\n// @ts-ignore - importing from compiled dist directories\nimport type { Policy } from \"../../shared/types/policy.js\";\n// @ts-ignore - importing from compiled dist directories\nimport { generateAtlasFrame, formatAtlasFrame } from \"../../shared/atlas/atlas-frame.js\";\n\n/**\n * Report format options\n */\nexport type ReportFormat = \"text\" | \"json\" | \"markdown\";\n\n/**\n * Report result with exit code\n */\nexport interface ReportResult {\n  /** Exit code: 0=clean, 1=violations */\n  exitCode: 0 | 1;\n  /** Formatted report content */\n  content: string;\n}\n\n// Backward-compatible generateReport supporting legacy signature:\n//   generateReport(violations, policy, format)\n// New preferred signature:\n//   generateReport(violations, { policy, format, strict })\nexport function generateReport(\n  violations: Violation[],\n  policyOrOpts: Policy | { policy?: Policy; format?: ReportFormat; strict?: boolean } = {},\n  legacyFormat?: ReportFormat\n): ReportResult {\n  let policy: Policy | undefined;\n  let format: ReportFormat = \"text\";\n\n  const isPlainObject = (v: unknown): v is Record<string, unknown> =>\n    typeof v === \"object\" && v !== null;\n  const isPolicyObject = (val: unknown): val is Policy =>\n    isPlainObject(val) &&\n    Object.prototype.hasOwnProperty.call(val, \"modules\") &&\n    !Object.prototype.hasOwnProperty.call(val, \"policy\");\n\n  if (isPolicyObject(policyOrOpts) && legacyFormat) {\n    policy = policyOrOpts as Policy;\n    format = legacyFormat;\n  } else if (isPolicyObject(policyOrOpts) && !legacyFormat) {\n    policy = policyOrOpts as Policy;\n  } else {\n    const opts = policyOrOpts as { policy?: Policy; format?: ReportFormat; strict?: boolean };\n    policy = opts.policy;\n    format = opts.format ?? \"text\";\n  }\n\n  const exitCode = violations.length > 0 ? 1 : 0;\n\n  let content: string;\n  switch (format) {\n    case \"json\":\n      content = formatAsJson(violations);\n      break;\n    case \"markdown\":\n      content = formatAsMarkdown(violations, policy);\n      break;\n    case \"text\":\n    default:\n      content = formatAsText(violations, policy);\n      break;\n  }\n\n  return { exitCode, content };\n}\n\n/**\n * Format policy header for text output\n */\nfunction formatPolicyHeaderText(policy: Policy, count: number): string {\n  // Attempt to derive an identifier (fallback to 'policy')\n  const id = derivePolicyId(policy);\n  return `Policy: ${id} (violations: ${count})`;\n}\n\n/**\n * Format policy header for markdown output\n */\nfunction formatPolicyHeaderMarkdown(policy: Policy, count: number): string {\n  const id = derivePolicyId(policy);\n  return `**Policy:** ${id} • **Violations:** ${count}`;\n}\n\n/**\n * Derive a human-friendly policy identifier.\n * Currently uses number of modules; can evolve to use explicit metadata.\n */\nfunction derivePolicyId(policy: Policy): string {\n  try {\n    const moduleCount = Object.keys(policy.modules || {}).length;\n    return moduleCount > 0 ? `${moduleCount} modules` : \"policy\";\n  } catch {\n    return \"policy\";\n  }\n}\n\n/**\n * Format violations as human-readable text\n */\nfunction formatAsText(violations: Violation[], policy?: Policy): string {\n  if (violations.length === 0) {\n    const header = policy != null ? formatPolicyHeaderText(policy, 0) + \"\\n\" : \"\";\n    return header + \"✅ No violations found\\n\";\n  }\n\n  let output = \"\";\n  if (policy != null) {\n    output += formatPolicyHeaderText(policy, violations.length) + \"\\n\";\n  }\n  output += `❌ Found ${violations.length} violation(s):\\n\\n`;\n\n  // Group violations by module for better context\n  const byModule = groupViolationsByModule(violations);\n\n  for (const [moduleId, moduleViolations] of Object.entries(byModule)) {\n    output += `📦 Module: ${moduleId}\\n`;\n\n    // Include Atlas Frame context with error handling\n    try {\n      const atlasFrame = generateAtlasFrame([moduleId], 1);\n      const atlasContext = formatAtlasFrame(atlasFrame);\n      output += atlasContext;\n    } catch {\n      // If Atlas Frame generation fails, continue without it\n      output += `\\n⚠️  Atlas Frame context unavailable\\n`;\n    }\n\n    for (const violation of moduleViolations) {\n      output += `\\n  ❌ ${formatViolationType(violation.type)}\\n`;\n      output += `     File: ${violation.file}\\n`;\n      output += `     ${violation.message}\\n`;\n      if (typeof violation.details === \"string\" && violation.details.length > 0) {\n        output += `     Details: ${violation.details}\\n`;\n      }\n      if (typeof violation.target_module === \"string\" && violation.target_module.length > 0) {\n        output += `     Target: ${violation.target_module}\\n`;\n      }\n      if (typeof violation.import_from === \"string\" && violation.import_from.length > 0) {\n        output += `     Import: ${violation.import_from}\\n`;\n      }\n    }\n\n    output += \"\\n\";\n  }\n\n  return output;\n}\n\n/**\n * Format violations as JSON\n */\nfunction formatAsJson(violations: Violation[]): string {\n  return JSON.stringify(\n    {\n      violations,\n      count: violations.length,\n      status: violations.length === 0 ? \"clean\" : \"violations_found\",\n    },\n    null,\n    2\n  );\n}\n\n/**\n * Format violations as Markdown\n */\nfunction formatAsMarkdown(violations: Violation[], policy?: Policy): string {\n  if (violations.length === 0) {\n    let clean = \"# Policy Check Report\\n\\n\";\n    if (policy != null) clean += formatPolicyHeaderMarkdown(policy, 0) + \"\\n\\n\";\n    return clean + \"✅ **No violations found**\\n\";\n  }\n\n  let output = \"# Policy Check Report\\n\\n\";\n  if (policy != null) {\n    output += formatPolicyHeaderMarkdown(policy, violations.length) + \"\\n\\n\";\n  }\n  output += `**Status:** ❌ ${violations.length} violation(s) found\\n\\n`;\n\n  // Group violations by type\n  const byType = groupViolationsByType(violations);\n\n  output += \"## Summary\\n\\n\";\n  output += \"| Violation Type | Count |\\n\";\n  output += \"|----------------|-------|\\n\";\n  for (const [type, typeViolations] of Object.entries(byType)) {\n    output += `| ${formatViolationType(type)} | ${typeViolations.length} |\\n`;\n  }\n  output += \"\\n\";\n\n  // Detailed violations by module\n  output += \"## Violations by Module\\n\\n\";\n  const byModule = groupViolationsByModule(violations);\n\n  for (const [moduleId, moduleViolations] of Object.entries(byModule)) {\n    output += `### 📦 Module: \\`${moduleId}\\`\\n\\n`;\n\n    // Include Atlas Frame context with error handling\n    try {\n      const atlasFrame = generateAtlasFrame([moduleId], 1);\n      output += \"**Atlas Frame Context:**\\n\";\n      output += \"```\\n\";\n      output += formatAtlasFrame(atlasFrame);\n      output += \"```\\n\\n\";\n    } catch {\n      output += \"**Atlas Frame Context:** ⚠️ Unavailable\\n\\n\";\n    }\n\n    // List violations\n    for (const violation of moduleViolations) {\n      output += `- **${formatViolationType(violation.type)}**\\n`;\n      output += `  - File: \\`${violation.file}\\`\\n`;\n      output += `  - ${violation.message}\\n`;\n      if (violation.details) {\n        output += `  - Details: ${violation.details}\\n`;\n      }\n      if (violation.target_module) {\n        output += `  - Target Module: \\`${violation.target_module}\\`\\n`;\n      }\n      if (violation.import_from) {\n        output += `  - Import: \\`${violation.import_from}\\`\\n`;\n      }\n      output += \"\\n\";\n    }\n  }\n\n  output += \"## Recommendations\\n\\n\";\n  output += \"1. Review each violation and update code to comply with policy\\n\";\n  output += \"2. Update `lexmap.policy.json` if architectural boundaries have changed\\n\";\n  output += \"3. Run `lexmap check` again after fixes\\n\";\n  output += \"\\n\";\n\n  return output;\n}\n\n/**\n * Group violations by module\n */\nfunction groupViolationsByModule(violations: Violation[]): Record<string, Violation[]> {\n  const groups: Record<string, Violation[]> = {};\n\n  for (const violation of violations) {\n    if (!groups[violation.module]) {\n      groups[violation.module] = [];\n    }\n    groups[violation.module].push(violation);\n  }\n\n  return groups;\n}\n\n/**\n * Group violations by type\n */\nfunction groupViolationsByType(violations: Violation[]): Record<string, Violation[]> {\n  const groups: Record<string, Violation[]> = {};\n\n  for (const violation of violations) {\n    if (!groups[violation.type]) {\n      groups[violation.type] = [];\n    }\n    groups[violation.type].push(violation);\n  }\n\n  return groups;\n}\n\n/**\n * Format violation type as human-readable string\n */\nfunction formatViolationType(type: string): string {\n  const typeMap: Record<string, string> = {\n    forbidden_caller: \"Forbidden Caller\",\n    missing_allowed_caller: \"Missing Allowed Caller\",\n    feature_flag: \"Feature Flag Violation\",\n    permission: \"Permission Violation\",\n    kill_pattern: \"Kill Pattern Violation\",\n  };\n\n  return typeMap[type] || type;\n}\n\n/**\n * Print a report to console\n *\n * @param violations - List of violations\n * @param policy - Policy for context\n * @param format - Output format\n */\nexport function printReport(\n  violations: Violation[],\n  policy: Policy,\n  format: ReportFormat = \"text\"\n): void {\n  const report = generateReport(violations, { policy, format });\n  console.log(report.content);\n}\n\n/**\n * Get exit code for violations\n *\n * @param violations - List of violations\n * @returns Exit code: 0=clean, 1=violations\n */\nexport function getExitCode(violations: Violation[]): 0 | 1 {\n  return violations.length > 0 ? 1 : 0;\n}\n","usedDeprecatedRules":[]},{"filePath":"/srv/lex-mcp/lex/src/policy/check/violations.ts","messages":[{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":60,"column":10,"nodeType":"Identifier","messageId":"conditionErrorNullableString","endLine":60,"endColumn":18,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[1534,1543],"text":"moduleId == null"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[1535,1543],"text":"(moduleId ?? \"\")"},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[1534,1543],"text":"!Boolean(moduleId)"},"desc":"Explicitly convert value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":99,"column":10,"nodeType":"Identifier","messageId":"conditionErrorNullableString","endLine":99,"endColumn":26,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[2690,2707],"text":"importedModuleId == null"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[2691,2707],"text":"(importedModuleId ?? \"\")"},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[2690,2707],"text":"!Boolean(importedModuleId)"},"desc":"Explicitly convert value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected object value in conditional. The condition is always true.","line":105,"column":10,"nodeType":"Identifier","messageId":"conditionErrorObject","endLine":105,"endColumn":24},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":141,"column":10,"nodeType":"Identifier","messageId":"conditionErrorNullableString","endLine":141,"endColumn":26,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[3816,3833],"text":"importedModuleId == null"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[3817,3833],"text":"(importedModuleId ?? \"\")"},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[3816,3833],"text":"!Boolean(importedModuleId)"},"desc":"Explicitly convert value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected object value in conditional. The condition is always true.","line":147,"column":10,"nodeType":"Identifier","messageId":"conditionErrorObject","endLine":147,"endColumn":24}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Policy Violation Detection\n *\n * Detects various types of architectural policy violations by comparing\n * merged scanner output against the policy file.\n */\n\nimport { Policy, PolicyModule } from \"../../shared/types/policy.js\";\nimport { MergedScanResult, FileData } from \"../merge/types.js\";\n\n/**\n * Types of policy violations that can be detected\n */\nexport type ViolationType =\n  | \"forbidden_caller\"\n  | \"missing_allowed_caller\"\n  | \"feature_flag\"\n  | \"permission\"\n  | \"kill_pattern\";\n\n/**\n * A single policy violation\n */\nexport interface Violation {\n  /** File where the violation occurred */\n  file: string;\n\n  /** Module that owns the violating file */\n  module: string;\n\n  /** Type of violation */\n  type: ViolationType;\n\n  /** Human-readable message describing the violation */\n  message: string;\n\n  /** Additional context and details */\n  details: string;\n\n  /** Module involved in the violation (e.g., the module being called) */\n  target_module?: string;\n\n  /** Import statement or pattern that caused the violation */\n  import_from?: string;\n}\n\n/**\n * Detect all policy violations in the merged scanner output\n *\n * @param merged - Merged scanner output from lexmap merge\n * @param policy - Policy definitions from lexmap.policy.json\n * @returns Array of detected violations\n */\nexport function detectViolations(merged: MergedScanResult, policy: Policy): Violation[] {\n  const violations: Violation[] = [];\n\n  for (const file of merged.files) {\n    const moduleId = resolveFileToModule(file.path, policy);\n\n    if (!moduleId) {\n      // File doesn't belong to any known module - skip\n      continue;\n    }\n\n    const module = policy.modules[moduleId];\n\n    // Check for forbidden caller violations\n    violations.push(...detectForbiddenCallerViolations(file, moduleId, policy));\n\n    // Check for missing allowed caller violations\n    violations.push(...detectMissingAllowedCallerViolations(file, moduleId, policy));\n\n    // Check for feature flag violations\n    violations.push(...detectFeatureFlagViolations(file, moduleId, module));\n\n    // Check for permission violations\n    violations.push(...detectPermissionViolations(file, moduleId, module));\n\n    // Check for kill pattern violations\n    violations.push(...detectKillPatternViolations(file, moduleId, module, policy));\n  }\n\n  return violations;\n}\n\n/**\n * Detect violations where a module calls another module that has forbidden the caller\n */\nfunction detectForbiddenCallerViolations(\n  file: FileData,\n  moduleId: string,\n  policy: Policy\n): Violation[] {\n  const violations: Violation[] = [];\n\n  for (const imp of file.imports) {\n    const importedModuleId = resolveImportToModule(imp.from, policy);\n\n    if (!importedModuleId) {\n      continue;\n    }\n\n    const importedModule = policy.modules[importedModuleId];\n\n    if (!importedModule || !importedModule.forbidden_callers) {\n      continue;\n    }\n\n    // Check if current module matches any forbidden_caller pattern\n    for (const forbidden of importedModule.forbidden_callers) {\n      if (matchPattern(moduleId, forbidden)) {\n        violations.push({\n          file: file.path,\n          module: moduleId,\n          type: \"forbidden_caller\",\n          message: `Module ${moduleId} calls ${importedModuleId} but is forbidden`,\n          details: `Policy forbids: ${forbidden}`,\n          target_module: importedModuleId,\n          import_from: imp.from,\n        });\n      }\n    }\n  }\n\n  return violations;\n}\n\n/**\n * Detect violations where a module calls another module without being in allowed_callers\n */\nfunction detectMissingAllowedCallerViolations(\n  file: FileData,\n  moduleId: string,\n  policy: Policy\n): Violation[] {\n  const violations: Violation[] = [];\n\n  for (const imp of file.imports) {\n    const importedModuleId = resolveImportToModule(imp.from, policy);\n\n    if (!importedModuleId) {\n      continue;\n    }\n\n    const importedModule = policy.modules[importedModuleId];\n\n    if (!importedModule || !importedModule.allowed_callers) {\n      continue;\n    }\n\n    // If allowed_callers is defined and non-empty, check if current module is allowed\n    if (importedModule.allowed_callers.length > 0) {\n      const isAllowed = importedModule.allowed_callers.some((allowed: string) =>\n        matchPattern(moduleId, allowed)\n      );\n\n      if (!isAllowed) {\n        violations.push({\n          file: file.path,\n          module: moduleId,\n          type: \"missing_allowed_caller\",\n          message: `Module ${moduleId} calls ${importedModuleId} but is not in allowed_callers`,\n          details: `Allowed callers: ${importedModule.allowed_callers.join(\", \")}`,\n          target_module: importedModuleId,\n          import_from: imp.from,\n        });\n      }\n    }\n  }\n\n  return violations;\n}\n\n/**\n * Detect violations where code accesses a gated module without the required feature flag\n */\nfunction detectFeatureFlagViolations(\n  file: FileData,\n  moduleId: string,\n  module: PolicyModule\n): Violation[] {\n  const violations: Violation[] = [];\n\n  if (!module.feature_flags || module.feature_flags.length === 0) {\n    return violations;\n  }\n\n  // Check if all required feature flags are present in the file\n  for (const requiredFlag of module.feature_flags) {\n    if (!file.feature_flags.includes(requiredFlag)) {\n      violations.push({\n        file: file.path,\n        module: moduleId,\n        type: \"feature_flag\",\n        message: `Module ${moduleId} requires feature flag '${requiredFlag}' but file does not check it`,\n        details: `Required flags: ${module.feature_flags.join(\", \")}`,\n      });\n    }\n  }\n\n  return violations;\n}\n\n/**\n * Detect violations where code accesses a protected module without the required permission\n */\nfunction detectPermissionViolations(\n  file: FileData,\n  moduleId: string,\n  module: PolicyModule\n): Violation[] {\n  const violations: Violation[] = [];\n\n  if (!module.requires_permissions || module.requires_permissions.length === 0) {\n    return violations;\n  }\n\n  // Check if all required permissions are present in the file\n  for (const requiredPerm of module.requires_permissions) {\n    if (!file.permissions.includes(requiredPerm)) {\n      violations.push({\n        file: file.path,\n        module: moduleId,\n        type: \"permission\",\n        message: `Module ${moduleId} requires permission '${requiredPerm}' but file does not check it`,\n        details: `Required permissions: ${module.requires_permissions.join(\", \")}`,\n      });\n    }\n  }\n\n  return violations;\n}\n\n/**\n * Detect kill pattern violations (anti-patterns being removed)\n */\nfunction detectKillPatternViolations(\n  file: FileData,\n  moduleId: string,\n  module: PolicyModule,\n  policy: Policy\n): Violation[] {\n  const violations: Violation[] = [];\n\n  // Check module-specific kill patterns\n  if (module.kill_patterns) {\n    for (const pattern of module.kill_patterns) {\n      // Check if pattern appears in file warnings\n      for (const warning of file.warnings) {\n        if (warning.includes(pattern)) {\n          violations.push({\n            file: file.path,\n            module: moduleId,\n            type: \"kill_pattern\",\n            message: `Anti-pattern '${pattern}' found in module (scheduled for removal)`,\n            details: warning,\n          });\n        }\n      }\n    }\n  }\n\n  // Check global kill patterns\n  if (policy.global_kill_patterns) {\n    for (const killPattern of policy.global_kill_patterns) {\n      for (const warning of file.warnings) {\n        if (warning.includes(killPattern.pattern)) {\n          violations.push({\n            file: file.path,\n            module: moduleId,\n            type: \"kill_pattern\",\n            message: `Global anti-pattern '${killPattern.pattern}' found`,\n            details: `${killPattern.description}: ${warning}`,\n          });\n        }\n      }\n    }\n  }\n\n  return violations;\n}\n\n/**\n * Resolve a file path to its owning module ID\n */\nfunction resolveFileToModule(filePath: string, policy: Policy): string | null {\n  for (const [moduleId, module] of Object.entries(policy.modules) as [string, PolicyModule][]) {\n    // Check owns_paths\n    if (module.owns_paths) {\n      for (const pathPattern of module.owns_paths) {\n        if (matchPath(filePath, pathPattern)) {\n          return moduleId;\n        }\n      }\n    }\n  }\n  return null;\n}\n\n/**\n * Resolve an import path to its target module ID\n */\nfunction resolveImportToModule(importPath: string, policy: Policy): string | null {\n  // Try to match by namespace first (PHP style)\n  for (const [moduleId, module] of Object.entries(policy.modules) as [string, PolicyModule][]) {\n    if (module.owns_namespaces) {\n      for (const namespace of module.owns_namespaces) {\n        if (importPath.startsWith(namespace)) {\n          return moduleId;\n        }\n      }\n    }\n  }\n\n  // Try to match by file path pattern (TypeScript/JS style)\n  for (const [moduleId, module] of Object.entries(policy.modules) as [string, PolicyModule][]) {\n    if (module.owns_paths) {\n      for (const pathPattern of module.owns_paths) {\n        if (matchPath(importPath, pathPattern)) {\n          return moduleId;\n        }\n      }\n    }\n  }\n\n  return null;\n}\n\n/**\n * Match a value against a pattern (supports wildcards)\n *\n * @param value - Value to match\n * @param pattern - Pattern with wildcards (* and **)\n * @param escapePaths - Whether to escape path separators (/)\n */\nfunction matchPattern(value: string, pattern: string, escapePaths: boolean = false): boolean {\n  // Escape all regex special characters except * (which we'll handle separately)\n  // First, temporarily replace ** and * with placeholders to preserve them\n  let regexPattern = pattern\n    .replace(/\\*\\*/g, \"\\x00DOUBLESTAR\\x00\")\n    .replace(/\\*/g, \"\\x00STAR\\x00\")\n    // Escape all regex special characters including backslash\n    .replace(/[.+?^${}()|[\\]\\\\]/g, \"\\\\$&\")\n    // Restore wildcards as regex patterns\n    .replace(/\\x00DOUBLESTAR\\x00/g, \".*\")\n    .replace(/\\x00STAR\\x00/g, \"[^/]*\");\n\n  if (escapePaths) {\n    // Path separators are already escaped by the general escape above\n    // This flag is now redundant but kept for API compatibility\n  }\n\n  const regex = new RegExp(`^${regexPattern}$`);\n  return regex.test(value);\n}\n\n/**\n * Match a file path against a glob pattern\n */\nfunction matchPath(filePath: string, pattern: string): boolean {\n  return matchPattern(filePath, pattern, true);\n}\n","usedDeprecatedRules":[]},{"filePath":"/srv/lex-mcp/lex/src/policy/merge/lexmap-merge.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'path' is defined but never used. Allowed unused vars must match /^_/u.","line":31,"column":13,"nodeType":null,"messageId":"unusedVar","endLine":31,"endColumn":17},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":1,"message":"Unsafe assignment of an `any` value.","line":83,"column":13,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":83,"endColumn":54},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":123,"column":15,"nodeType":"MemberExpression","messageId":"conditionErrorNullableString","endLine":123,"endColumn":32,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[3200,3217],"text":"(file.module_scope != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[3200,3217],"text":"(file.module_scope ?? \"\")"},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[3200,3217],"text":"(Boolean(file.module_scope))"},"desc":"Explicitly convert value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":123,"column":37,"nodeType":"MemberExpression","messageId":"conditionErrorNullableString","endLine":123,"endColumn":62,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[3221,3247],"text":"(existingFile.module_scope == null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[3222,3247],"text":"(existingFile.module_scope ?? \"\")"},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[3221,3247],"text":"(!Boolean(existingFile.module_scope))"},"desc":"Explicitly convert value to a boolean (`Boolean(value)`)"}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"#!/usr/bin/env node\n/**\n * LexMap Merge Tool\n *\n * Combines scanner outputs from multiple language scanners into a single unified view.\n *\n * Usage:\n *     lexmap merge scanner1.json scanner2.json ... > merged.json\n *\n * Philosophy:\n *     This tool MERGES scanner outputs, it does NOT enforce policy.\n *     Policy enforcement happens AFTER merge, using lexmap.policy.json.\n *\n * Flow:\n *     1. Read all scanner output JSON files\n *     2. Validate each against scanner-output.schema.json\n *     3. Merge file lists (deduplicating by path)\n *     4. Output unified scanner-output.json\n *\n * Next Step:\n *     Feed merged output to policy checker which:\n *     - Resolves file paths → module_scope (using lexmap.policy.json)\n *     - Checks allowed_callers vs actual imports\n *     - Reports violations\n *\n * Author: LexMap\n * License: MIT\n */\n\nimport * as fs from \"fs\";\nimport * as path from \"path\";\n\ninterface Declaration {\n  type: string;\n  name: string;\n  namespace?: string;\n}\n\ninterface Import {\n  from: string;\n  type: string;\n  imported?: string[];\n  alias?: string | null;\n}\n\ninterface FileData {\n  path: string;\n  module_scope?: string;\n  declarations: Declaration[];\n  imports: Import[];\n  feature_flags: string[];\n  permissions: string[];\n  warnings: string[];\n}\n\ninterface ModuleEdge {\n  from_module: string;\n  to_module: string;\n  from_file: string;\n  import_statement: string;\n}\n\ninterface ScannerOutput {\n  language: string;\n  files: FileData[];\n  module_edges?: ModuleEdge[];\n}\n\ninterface MergedOutput {\n  sources: string[];\n  files: FileData[];\n  module_edges: ModuleEdge[];\n}\n\nclass LexMapMerge {\n  private scannerOutputs: ScannerOutput[] = [];\n  private fileMap: Map<string, FileData> = new Map();\n  private moduleEdges: ModuleEdge[] = [];\n\n  loadScanner(filePath: string): void {\n    try {\n      const content = fs.readFileSync(filePath, \"utf-8\");\n      const data: ScannerOutput = JSON.parse(content);\n\n      // Basic validation\n      if (!data.language || !Array.isArray(data.files)) {\n        console.error(`Error: ${filePath} does not conform to scanner-output.schema.json`);\n        process.exit(1);\n      }\n\n      this.scannerOutputs.push(data);\n      console.error(\n        `Loaded scanner output: ${filePath} (${data.language}, ${data.files.length} files)`\n      );\n    } catch (error) {\n      console.error(`Error loading ${filePath}:`, error);\n      process.exit(1);\n    }\n  }\n\n  merge(): MergedOutput {\n    const sources: string[] = [];\n\n    // Collect all files, deduplicating by path\n    for (const scanner of this.scannerOutputs) {\n      sources.push(scanner.language);\n\n      // Merge module edges\n      if (scanner.module_edges) {\n        this.moduleEdges.push(...scanner.module_edges);\n      }\n\n      for (const file of scanner.files) {\n        const existingFile = this.fileMap.get(file.path);\n\n        if (existingFile) {\n          // File already seen - merge metadata\n          // This shouldn't happen often (different scanners for different languages)\n          // but handle it gracefully\n          console.error(`Warning: File ${file.path} appears in multiple scanner outputs`);\n\n          // Prefer module_scope from scanner if it exists\n          if (file.module_scope && !existingFile.module_scope) {\n            existingFile.module_scope = file.module_scope;\n          }\n\n          // Merge arrays (deduplicate)\n          existingFile.feature_flags = [\n            ...new Set([...existingFile.feature_flags, ...file.feature_flags]),\n          ].sort();\n          existingFile.permissions = [\n            ...new Set([...existingFile.permissions, ...file.permissions]),\n          ].sort();\n          existingFile.warnings = [...new Set([...existingFile.warnings, ...file.warnings])];\n        } else {\n          // New file - add to map\n          this.fileMap.set(file.path, file);\n        }\n      }\n    }\n\n    // Deduplicate module edges based on from_module, to_module, and import_statement\n    const edgeMap = new Map<string, ModuleEdge>();\n    for (const edge of this.moduleEdges) {\n      const key = `${edge.from_module}:${edge.to_module}:${edge.import_statement}`;\n      if (!edgeMap.has(key)) {\n        edgeMap.set(key, edge);\n      }\n    }\n\n    return {\n      sources,\n      files: Array.from(this.fileMap.values()).sort((a, b) => a.path.localeCompare(b.path)),\n      module_edges: Array.from(edgeMap.values()),\n    };\n  }\n}\n\nfunction main() {\n  const args = process.argv.slice(2);\n\n  if (args.length < 1) {\n    console.error(\"Usage: lexmap merge <scanner1.json> <scanner2.json> ... > merged.json\");\n    console.error(\"\");\n    console.error(\"Combines scanner outputs from multiple language scanners.\");\n    console.error(\"Output conforms to scanner-output.schema.json structure.\");\n    console.error(\"\");\n    console.error(\"Example:\");\n    console.error(\"  python3 php_scanner.py app/ > php.json\");\n    console.error(\"  node ts_scanner.ts ui/ > ts.json\");\n    console.error(\"  lexmap merge php.json ts.json > merged.json\");\n    process.exit(1);\n  }\n\n  const merger = new LexMapMerge();\n\n  // Load all scanner outputs\n  for (const scannerFile of args) {\n    if (!fs.existsSync(scannerFile)) {\n      console.error(`Error: File not found: ${scannerFile}`);\n      process.exit(1);\n    }\n    merger.loadScanner(scannerFile);\n  }\n\n  // Merge and output\n  const merged = merger.merge();\n\n  console.log(JSON.stringify(merged, null, 2));\n  console.error(`\\nMerged ${merged.files.length} files from ${merged.sources.length} scanners`);\n}\n\nmain();\n","usedDeprecatedRules":[]},{"filePath":"/srv/lex-mcp/lex/src/policy/merge/merge.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/srv/lex-mcp/lex/src/policy/merge/types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/srv/lex-mcp/lex/src/policy/scanners/common.ts","messages":[{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected object value in conditional. The condition is always true.","line":51,"column":8,"nodeType":"Identifier","messageId":"conditionErrorObject","endLine":51,"endColumn":25},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":115,"column":11,"nodeType":"Identifier","messageId":"conditionErrorNullableString","endLine":115,"endColumn":19,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[3385,3393],"text":"moduleId != null"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[3385,3393],"text":"moduleId ?? \"\""},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[3385,3393],"text":"Boolean(moduleId)"},"desc":"Explicitly convert value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":122,"column":11,"nodeType":"Identifier","messageId":"conditionErrorNullableString","endLine":122,"endColumn":24,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[3618,3631],"text":"indexModuleId != null"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[3618,3631],"text":"indexModuleId ?? \"\""},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[3618,3631],"text":"Boolean(indexModuleId)"},"desc":"Explicitly convert value to a boolean (`Boolean(value)`)"}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Common utilities for LexMap scanners\n *\n * Shared path matching, module resolution, and glob pattern utilities\n * used by TypeScript, Python, and PHP scanners.\n */\n\nimport { minimatch } from \"minimatch\";\nimport * as path from \"path\";\n\n/**\n * Policy module definition (subset needed for scanners)\n */\nexport interface PolicyModule {\n  owns_paths?: string[];\n  owns_namespaces?: string[];\n  coords?: [number, number];\n  allowed_callers?: string[];\n  forbidden_callers?: string[];\n  feature_flags?: string[];\n  requires_permissions?: string[];\n  kill_patterns?: string[];\n  notes?: string;\n}\n\n/**\n * Policy file structure\n */\nexport interface Policy {\n  modules: Record<string, PolicyModule>;\n}\n\n/**\n * Module call edge (represents cross-module dependency)\n */\nexport interface ModuleEdge {\n  from_module: string;\n  to_module: string;\n  from_file: string;\n  import_statement: string;\n}\n\n/**\n * Check if a file path matches any of the owns_paths glob patterns\n *\n * @param filePath - Relative file path to check\n * @param ownsPathsPatterns - Array of glob patterns from module's owns_paths\n * @returns true if the file matches any pattern\n */\nexport function matchesOwnsPaths(filePath: string, ownsPathsPatterns: string[]): boolean {\n  if (!ownsPathsPatterns || ownsPathsPatterns.length === 0) {\n    return false;\n  }\n\n  // Normalize the file path to use forward slashes\n  const normalizedPath = filePath.replace(/\\\\/g, \"/\");\n\n  for (const pattern of ownsPathsPatterns) {\n    // Normalize pattern to use forward slashes\n    const normalizedPattern = pattern.replace(/\\\\/g, \"/\");\n\n    if (minimatch(normalizedPath, normalizedPattern, { dot: true })) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\n/**\n * Find which module owns a given file path\n *\n * @param filePath - Relative file path to resolve\n * @param policy - The loaded policy configuration\n * @returns Module ID if found, undefined otherwise\n */\nexport function resolveFileToModule(filePath: string, policy: Policy): string | undefined {\n  for (const [moduleId, moduleConfig] of Object.entries(policy.modules)) {\n    if (moduleConfig.owns_paths && matchesOwnsPaths(filePath, moduleConfig.owns_paths)) {\n      return moduleId;\n    }\n  }\n  return undefined;\n}\n\n/**\n * Resolve an import path to a module\n *\n * This is a simplified heuristic - scanners are \"dumb\" and just match imports\n * to file paths that might belong to modules.\n *\n * @param importPath - The import/require path (e.g., './other', '../services/auth')\n * @param currentFilePath - The file doing the importing\n * @param policy - The loaded policy configuration\n * @returns Module ID if the import can be resolved to a known module\n */\nexport function resolveImportToModule(\n  importPath: string,\n  currentFilePath: string,\n  policy: Policy\n): string | undefined {\n  // Relative imports: resolve relative to current file\n  if (importPath.startsWith(\"./\") || importPath.startsWith(\"../\")) {\n    const currentDir = path.dirname(currentFilePath);\n    let resolvedPath = path.join(currentDir, importPath);\n\n    // Normalize path separators\n    resolvedPath = resolvedPath.replace(/\\\\/g, \"/\");\n\n    // Try with common extensions\n    const extensions = [\"\", \".ts\", \".tsx\", \".js\", \".jsx\", \".py\", \".php\"];\n    for (const ext of extensions) {\n      const pathWithExt = resolvedPath + ext;\n      const moduleId = resolveFileToModule(pathWithExt, policy);\n      if (moduleId) {\n        return moduleId;\n      }\n\n      // Try index files\n      const indexPath = path.join(resolvedPath, \"index\" + ext).replace(/\\\\/g, \"/\");\n      const indexModuleId = resolveFileToModule(indexPath, policy);\n      if (indexModuleId) {\n        return indexModuleId;\n      }\n    }\n  }\n\n  // Absolute/package imports: check if any module owns_paths matches\n  // For example, import from '@/services/auth' or 'services/auth'\n  const normalizedImport = importPath.replace(/^@\\//, \"\");\n\n  for (const [moduleId, moduleConfig] of Object.entries(policy.modules)) {\n    if (moduleConfig.owns_paths) {\n      for (const ownPath of moduleConfig.owns_paths) {\n        // Check if import path starts with the module's path prefix\n        const pathPrefix = ownPath.replace(/\\/\\*\\*$/, \"\").replace(/\\/\\*$/, \"\");\n        if (normalizedImport.startsWith(pathPrefix)) {\n          return moduleId;\n        }\n      }\n    }\n  }\n\n  return undefined;\n}\n\n/**\n * Detect feature flag checks in code using common patterns\n *\n * Patterns detected (case-sensitive):\n * - flags.flag_name\n * - flags['flag_name']\n * - featureFlags.isEnabled('flag_name')\n * - FeatureFlags.enabled('flag_name')\n * - useFeatureFlag('flag_name')\n *\n * @param content - Source code content\n * @returns Array of detected flag names\n */\nexport function detectFeatureFlags(content: string): string[] {\n  const flags = new Set<string>();\n\n  // Pattern: flags.flag_name (property access)\n  const pattern1 = /flags\\.(\\w+)/g;\n  let match;\n  while ((match = pattern1.exec(content)) !== null) {\n    // Skip if it looks like a method call (e.g., flags.isEnabled)\n    if (!content.substring(match.index + match[0].length).match(/^\\s*\\(/)) {\n      flags.add(match[1]);\n    }\n  }\n\n  // Pattern: flags['flag_name'] or flags[\"flag_name\"]\n  const pattern2 = /flags\\[['\"](\\w+)['\"]\\]/g;\n  while ((match = pattern2.exec(content)) !== null) {\n    flags.add(match[1]);\n  }\n\n  // Pattern: featureFlags.isEnabled('flag_name')\n  const pattern3 = /featureFlags\\.isEnabled\\(['\"](\\w+)['\"]\\)/g;\n  while ((match = pattern3.exec(content)) !== null) {\n    flags.add(match[1]);\n  }\n\n  // Pattern: FeatureFlags.enabled('flag_name')\n  const pattern4 = /FeatureFlags\\.enabled\\(['\"](\\w+)['\"]\\)/g;\n  while ((match = pattern4.exec(content)) !== null) {\n    flags.add(match[1]);\n  }\n\n  // Pattern: useFeatureFlag('flag_name')\n  const pattern5 = /useFeatureFlag\\(['\"](\\w+)['\"]\\)/g;\n  while ((match = pattern5.exec(content)) !== null) {\n    flags.add(match[1]);\n  }\n\n  return Array.from(flags).sort();\n}\n\n/**\n * Detect permission checks in code using common patterns\n *\n * Patterns detected:\n * - user.can('permission_name')\n * - hasPermission('permission_name')\n * - usePermission('permission_name')\n * - checkPermission('permission_name')\n *\n * @param content - Source code content\n * @returns Array of detected permission names\n */\nexport function detectPermissions(content: string): string[] {\n  const permissions = new Set<string>();\n\n  // Pattern: user.can('permission_name') or $user->can('permission_name')\n  const pattern1 = /(?:user|User|\\$user)(?:\\.|->)can\\(['\"](\\w+)['\"]\\)/g;\n  let match;\n  while ((match = pattern1.exec(content)) !== null) {\n    permissions.add(match[1]);\n  }\n\n  // Pattern: hasPermission('permission_name')\n  const pattern2 = /hasPermission\\(['\"](\\w+)['\"]\\)/g;\n  while ((match = pattern2.exec(content)) !== null) {\n    permissions.add(match[1]);\n  }\n\n  // Pattern: usePermission('permission_name')\n  const pattern3 = /usePermission\\(['\"](\\w+)['\"]\\)/g;\n  while ((match = pattern3.exec(content)) !== null) {\n    permissions.add(match[1]);\n  }\n\n  // Pattern: checkPermission('permission_name')\n  const pattern4 = /checkPermission\\(['\"](\\w+)['\"]\\)/g;\n  while ((match = pattern4.exec(content)) !== null) {\n    permissions.add(match[1]);\n  }\n\n  return Array.from(permissions).sort();\n}\n","usedDeprecatedRules":[]},{"filePath":"/srv/lex-mcp/lex/src/policy/scanners/test_scanners.ts","messages":[{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .message on an `any` value.","line":39,"column":43,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":39,"endColumn":50},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":45,"column":19,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":45,"endColumn":22,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1120,1123],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1120,1123],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .message on an `any` value.","line":47,"column":37,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":47,"endColumn":44},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":1,"message":"Unsafe assignment of an `any` value.","line":105,"column":11,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":105,"endColumn":38},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":1,"message":"Unsafe assignment of an `any` value.","line":106,"column":11,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":106,"endColumn":79},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":1,"message":"Unsafe call of a(n) `any` typed value.","line":106,"column":18,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":106,"endColumn":35},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .files on an `any` value.","line":106,"column":25,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":106,"endColumn":30},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":106,"column":40,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":106,"endColumn":43,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2907,2910],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2907,2910],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .path on an `any` value.","line":106,"column":50,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":106,"endColumn":54},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected any value in conditional. An explicit comparison or type conversion is required.","line":107,"column":10,"nodeType":"Identifier","messageId":"conditionErrorAny","endLine":107,"endColumn":14,"suggestions":[{"messageId":"conditionFixCastBoolean","fix":{"range":[2957,2961],"text":"(Boolean(file))"},"desc":"Explicitly convert value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .module_scope on an `any` value.","line":107,"column":23,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":107,"endColumn":35},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .module_scope on an `any` value.","line":108,"column":71,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":108,"endColumn":83},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":1,"message":"Unsafe assignment of an `any` value.","line":135,"column":11,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":135,"endColumn":38},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":1,"message":"Unsafe assignment of an `any` value.","line":136,"column":11,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":138,"endColumn":6},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":1,"message":"Unsafe call of a(n) `any` typed value.","line":136,"column":18,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":136,"endColumn":43},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .module_edges on an `any` value.","line":136,"column":25,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":136,"endColumn":37},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":137,"column":11,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":137,"endColumn":14,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3771,3774],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3771,3774],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .from_module on an `any` value.","line":137,"column":21,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":137,"endColumn":32},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .to_module on an `any` value.","line":137,"column":53,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":137,"endColumn":62},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected any value in conditional. An explicit comparison or type conversion is required.","line":139,"column":10,"nodeType":"Identifier","messageId":"conditionErrorAny","endLine":139,"endColumn":14,"suggestions":[{"messageId":"conditionFixCastBoolean","fix":{"range":[3859,3863],"text":"(Boolean(edge))"},"desc":"Explicitly convert value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":1,"message":"Unsafe assignment of an `any` value.","line":160,"column":11,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":160,"endColumn":38},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":1,"message":"Unsafe assignment of an `any` value.","line":161,"column":11,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":161,"endColumn":82},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":1,"message":"Unsafe call of a(n) `any` typed value.","line":161,"column":18,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":161,"endColumn":35},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .files on an `any` value.","line":161,"column":25,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":161,"endColumn":30},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":161,"column":40,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":161,"endColumn":43,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4463,4466],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4463,4466],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unsafe-return","severity":1,"message":"Unsafe return of a value of type `any`.","line":161,"column":48,"nodeType":"CallExpression","messageId":"unsafeReturn","endLine":161,"endColumn":81},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":1,"message":"Unsafe call of a(n) `any` typed value.","line":161,"column":48,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":161,"endColumn":63},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .path on an `any` value.","line":161,"column":50,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":161,"endColumn":54},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected any value in conditional. An explicit comparison or type conversion is required.","line":162,"column":10,"nodeType":"Identifier","messageId":"conditionErrorAny","endLine":162,"endColumn":14,"suggestions":[{"messageId":"conditionFixCastBoolean","fix":{"range":[4516,4520],"text":"(Boolean(file))"},"desc":"Explicitly convert value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected any value in conditional. An explicit comparison or type conversion is required.","line":162,"column":19,"nodeType":"CallExpression","messageId":"conditionErrorAny","endLine":162,"endColumn":65,"suggestions":[{"messageId":"conditionFixCastBoolean","fix":{"range":[4525,4571],"text":"(Boolean(file.feature_flags.includes(\"beta_user_admin\")))"},"desc":"Explicitly convert value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":1,"message":"Unsafe call of a(n) `any` typed value.","line":162,"column":19,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":162,"endColumn":46},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .feature_flags on an `any` value.","line":162,"column":24,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":162,"endColumn":37},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":1,"message":"Unsafe assignment of an `any` value.","line":181,"column":11,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":181,"endColumn":38},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":1,"message":"Unsafe assignment of an `any` value.","line":182,"column":11,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":182,"endColumn":78},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":1,"message":"Unsafe call of a(n) `any` typed value.","line":182,"column":18,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":182,"endColumn":35},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .files on an `any` value.","line":182,"column":25,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":182,"endColumn":30},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":182,"column":40,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":182,"endColumn":43,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5178,5181],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5178,5181],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unsafe-return","severity":1,"message":"Unsafe return of a value of type `any`.","line":182,"column":48,"nodeType":"CallExpression","messageId":"unsafeReturn","endLine":182,"endColumn":77},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":1,"message":"Unsafe call of a(n) `any` typed value.","line":182,"column":48,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":182,"endColumn":63},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .path on an `any` value.","line":182,"column":50,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":182,"endColumn":54},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected any value in conditional. An explicit comparison or type conversion is required.","line":183,"column":10,"nodeType":"Identifier","messageId":"conditionErrorAny","endLine":183,"endColumn":14,"suggestions":[{"messageId":"conditionFixCastBoolean","fix":{"range":[5227,5231],"text":"(Boolean(file))"},"desc":"Explicitly convert value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected any value in conditional. An explicit comparison or type conversion is required.","line":183,"column":19,"nodeType":"CallExpression","messageId":"conditionErrorAny","endLine":183,"endColumn":61,"suggestions":[{"messageId":"conditionFixCastBoolean","fix":{"range":[5236,5278],"text":"(Boolean(file.feature_flags.includes(\"admin_panel\")))"},"desc":"Explicitly convert value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":1,"message":"Unsafe call of a(n) `any` typed value.","line":183,"column":19,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":183,"endColumn":46},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .feature_flags on an `any` value.","line":183,"column":24,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":183,"endColumn":37},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":1,"message":"Unsafe assignment of an `any` value.","line":202,"column":11,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":202,"endColumn":38},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":1,"message":"Unsafe assignment of an `any` value.","line":203,"column":11,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":203,"endColumn":77},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":1,"message":"Unsafe call of a(n) `any` typed value.","line":203,"column":18,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":203,"endColumn":35},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .files on an `any` value.","line":203,"column":25,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":203,"endColumn":30},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":203,"column":40,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":203,"endColumn":43,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5853,5856],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5853,5856],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unsafe-return","severity":1,"message":"Unsafe return of a value of type `any`.","line":203,"column":48,"nodeType":"CallExpression","messageId":"unsafeReturn","endLine":203,"endColumn":76},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":1,"message":"Unsafe call of a(n) `any` typed value.","line":203,"column":48,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":203,"endColumn":63},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .path on an `any` value.","line":203,"column":50,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":203,"endColumn":54},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected any value in conditional. An explicit comparison or type conversion is required.","line":204,"column":10,"nodeType":"Identifier","messageId":"conditionErrorAny","endLine":204,"endColumn":14,"suggestions":[{"messageId":"conditionFixCastBoolean","fix":{"range":[5901,5905],"text":"(Boolean(file))"},"desc":"Explicitly convert value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected any value in conditional. An explicit comparison or type conversion is required.","line":204,"column":19,"nodeType":"CallExpression","messageId":"conditionErrorAny","endLine":204,"endColumn":64,"suggestions":[{"messageId":"conditionFixCastBoolean","fix":{"range":[5910,5955],"text":"(Boolean(file.permissions.includes(\"can_manage_users\")))"},"desc":"Explicitly convert value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":1,"message":"Unsafe call of a(n) `any` typed value.","line":204,"column":19,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":204,"endColumn":44},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .permissions on an `any` value.","line":204,"column":24,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":204,"endColumn":35},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":1,"message":"Unsafe assignment of an `any` value.","line":226,"column":11,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":226,"endColumn":38},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":1,"message":"Unsafe assignment of an `any` value.","line":227,"column":11,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":227,"endColumn":81},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":1,"message":"Unsafe call of a(n) `any` typed value.","line":227,"column":18,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":227,"endColumn":35},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .files on an `any` value.","line":227,"column":25,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":227,"endColumn":30},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":227,"column":40,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":227,"endColumn":43,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6585,6588],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6585,6588],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unsafe-return","severity":1,"message":"Unsafe return of a value of type `any`.","line":227,"column":48,"nodeType":"CallExpression","messageId":"unsafeReturn","endLine":227,"endColumn":80},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":1,"message":"Unsafe call of a(n) `any` typed value.","line":227,"column":48,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":227,"endColumn":63},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .path on an `any` value.","line":227,"column":50,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":227,"endColumn":54},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected any value in conditional. An explicit comparison or type conversion is required.","line":228,"column":10,"nodeType":"Identifier","messageId":"conditionErrorAny","endLine":228,"endColumn":14,"suggestions":[{"messageId":"conditionFixCastBoolean","fix":{"range":[6637,6641],"text":"(Boolean(file))"},"desc":"Explicitly convert value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .module_scope on an `any` value.","line":228,"column":23,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":228,"endColumn":35},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .module_scope on an `any` value.","line":229,"column":76,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":229,"endColumn":88},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":1,"message":"Unsafe assignment of an `any` value.","line":248,"column":11,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":248,"endColumn":38},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":1,"message":"Unsafe assignment of an `any` value.","line":249,"column":11,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":251,"endColumn":6},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":1,"message":"Unsafe call of a(n) `any` typed value.","line":249,"column":18,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":249,"endColumn":43},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .module_edges on an `any` value.","line":249,"column":25,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":249,"endColumn":37},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":250,"column":11,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":250,"endColumn":14,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7290,7293],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7290,7293],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .from_module on an `any` value.","line":250,"column":21,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":250,"endColumn":32},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .to_module on an `any` value.","line":250,"column":53,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":250,"endColumn":62},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected any value in conditional. An explicit comparison or type conversion is required.","line":252,"column":10,"nodeType":"Identifier","messageId":"conditionErrorAny","endLine":252,"endColumn":14,"suggestions":[{"messageId":"conditionFixCastBoolean","fix":{"range":[7378,7382],"text":"(Boolean(edge))"},"desc":"Explicitly convert value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":1,"message":"Unsafe assignment of an `any` value.","line":271,"column":11,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":271,"endColumn":38},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":1,"message":"Unsafe assignment of an `any` value.","line":272,"column":11,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":272,"endColumn":81},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":1,"message":"Unsafe call of a(n) `any` typed value.","line":272,"column":18,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":272,"endColumn":35},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .files on an `any` value.","line":272,"column":25,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":272,"endColumn":30},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":272,"column":40,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":272,"endColumn":43,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7998,8001],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7998,8001],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unsafe-return","severity":1,"message":"Unsafe return of a value of type `any`.","line":272,"column":48,"nodeType":"CallExpression","messageId":"unsafeReturn","endLine":272,"endColumn":80},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":1,"message":"Unsafe call of a(n) `any` typed value.","line":272,"column":48,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":272,"endColumn":63},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .path on an `any` value.","line":272,"column":50,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":272,"endColumn":54},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected any value in conditional. An explicit comparison or type conversion is required.","line":273,"column":10,"nodeType":"Identifier","messageId":"conditionErrorAny","endLine":273,"endColumn":14,"suggestions":[{"messageId":"conditionFixCastBoolean","fix":{"range":[8050,8054],"text":"(Boolean(file))"},"desc":"Explicitly convert value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected any value in conditional. An explicit comparison or type conversion is required.","line":273,"column":19,"nodeType":"CallExpression","messageId":"conditionErrorAny","endLine":273,"endColumn":65,"suggestions":[{"messageId":"conditionFixCastBoolean","fix":{"range":[8059,8105],"text":"(Boolean(file.feature_flags.includes(\"beta_user_admin\")))"},"desc":"Explicitly convert value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":1,"message":"Unsafe call of a(n) `any` typed value.","line":273,"column":19,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":273,"endColumn":46},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .feature_flags on an `any` value.","line":273,"column":24,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":273,"endColumn":37},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":1,"message":"Unsafe assignment of an `any` value.","line":291,"column":11,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":291,"endColumn":38},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":1,"message":"Unsafe assignment of an `any` value.","line":292,"column":11,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":292,"endColumn":76},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":1,"message":"Unsafe call of a(n) `any` typed value.","line":292,"column":18,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":292,"endColumn":35},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .files on an `any` value.","line":292,"column":25,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":292,"endColumn":30},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":292,"column":40,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":292,"endColumn":43,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8665,8668],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8665,8668],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unsafe-return","severity":1,"message":"Unsafe return of a value of type `any`.","line":292,"column":48,"nodeType":"CallExpression","messageId":"unsafeReturn","endLine":292,"endColumn":75},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":1,"message":"Unsafe call of a(n) `any` typed value.","line":292,"column":48,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":292,"endColumn":63},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .path on an `any` value.","line":292,"column":50,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":292,"endColumn":54},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected any value in conditional. An explicit comparison or type conversion is required.","line":293,"column":10,"nodeType":"Identifier","messageId":"conditionErrorAny","endLine":293,"endColumn":14,"suggestions":[{"messageId":"conditionFixCastBoolean","fix":{"range":[8712,8716],"text":"(Boolean(file))"},"desc":"Explicitly convert value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected any value in conditional. An explicit comparison or type conversion is required.","line":293,"column":19,"nodeType":"CallExpression","messageId":"conditionErrorAny","endLine":293,"endColumn":64,"suggestions":[{"messageId":"conditionFixCastBoolean","fix":{"range":[8721,8766],"text":"(Boolean(file.permissions.includes(\"can_manage_users\")))"},"desc":"Explicitly convert value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":1,"message":"Unsafe call of a(n) `any` typed value.","line":293,"column":19,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":293,"endColumn":44},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .permissions on an `any` value.","line":293,"column":24,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":293,"endColumn":35},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":1,"message":"Unsafe assignment of an `any` value.","line":316,"column":11,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":316,"endColumn":38},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":1,"message":"Unsafe assignment of an `any` value.","line":317,"column":11,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":317,"endColumn":81},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":1,"message":"Unsafe call of a(n) `any` typed value.","line":317,"column":18,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":317,"endColumn":35},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .files on an `any` value.","line":317,"column":25,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":317,"endColumn":30},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":317,"column":40,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":317,"endColumn":43,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9415,9418],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9415,9418],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unsafe-return","severity":1,"message":"Unsafe return of a value of type `any`.","line":317,"column":48,"nodeType":"CallExpression","messageId":"unsafeReturn","endLine":317,"endColumn":80},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":1,"message":"Unsafe call of a(n) `any` typed value.","line":317,"column":48,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":317,"endColumn":63},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .path on an `any` value.","line":317,"column":50,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":317,"endColumn":54},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected any value in conditional. An explicit comparison or type conversion is required.","line":318,"column":10,"nodeType":"Identifier","messageId":"conditionErrorAny","endLine":318,"endColumn":14,"suggestions":[{"messageId":"conditionFixCastBoolean","fix":{"range":[9467,9471],"text":"(Boolean(file))"},"desc":"Explicitly convert value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .module_scope on an `any` value.","line":318,"column":23,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":318,"endColumn":35},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .module_scope on an `any` value.","line":319,"column":76,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":319,"endColumn":88},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":1,"message":"Unsafe assignment of an `any` value.","line":342,"column":11,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":342,"endColumn":38},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":1,"message":"Unsafe assignment of an `any` value.","line":343,"column":11,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":343,"endColumn":82},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":1,"message":"Unsafe call of a(n) `any` typed value.","line":343,"column":18,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":343,"endColumn":35},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .files on an `any` value.","line":343,"column":25,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":343,"endColumn":30},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":343,"column":40,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":343,"endColumn":43,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10200,10203],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10200,10203],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unsafe-return","severity":1,"message":"Unsafe return of a value of type `any`.","line":343,"column":48,"nodeType":"CallExpression","messageId":"unsafeReturn","endLine":343,"endColumn":81},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":1,"message":"Unsafe call of a(n) `any` typed value.","line":343,"column":48,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":343,"endColumn":63},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .path on an `any` value.","line":343,"column":50,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":343,"endColumn":54},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected any value in conditional. An explicit comparison or type conversion is required.","line":344,"column":10,"nodeType":"Identifier","messageId":"conditionErrorAny","endLine":344,"endColumn":14,"suggestions":[{"messageId":"conditionFixCastBoolean","fix":{"range":[10253,10257],"text":"(Boolean(file))"},"desc":"Explicitly convert value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected any value in conditional. An explicit comparison or type conversion is required.","line":344,"column":19,"nodeType":"CallExpression","messageId":"conditionErrorAny","endLine":344,"endColumn":61,"suggestions":[{"messageId":"conditionFixCastBoolean","fix":{"range":[10262,10304],"text":"(Boolean(file.feature_flags.includes(\"admin_panel\")))"},"desc":"Explicitly convert value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":1,"message":"Unsafe call of a(n) `any` typed value.","line":344,"column":19,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":344,"endColumn":46},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .feature_flags on an `any` value.","line":344,"column":24,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":344,"endColumn":37},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":1,"message":"Unsafe assignment of an `any` value.","line":366,"column":11,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":366,"endColumn":38},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":1,"message":"Unsafe assignment of an `any` value.","line":367,"column":11,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":367,"endColumn":78},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":1,"message":"Unsafe call of a(n) `any` typed value.","line":367,"column":18,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":367,"endColumn":35},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .files on an `any` value.","line":367,"column":25,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":367,"endColumn":30},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":367,"column":40,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":367,"endColumn":43,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10905,10908],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10905,10908],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unsafe-return","severity":1,"message":"Unsafe return of a value of type `any`.","line":367,"column":48,"nodeType":"CallExpression","messageId":"unsafeReturn","endLine":367,"endColumn":77},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":1,"message":"Unsafe call of a(n) `any` typed value.","line":367,"column":48,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":367,"endColumn":63},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .path on an `any` value.","line":367,"column":50,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":367,"endColumn":54},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected any value in conditional. An explicit comparison or type conversion is required.","line":368,"column":10,"nodeType":"Identifier","messageId":"conditionErrorAny","endLine":368,"endColumn":14,"suggestions":[{"messageId":"conditionFixCastBoolean","fix":{"range":[10954,10958],"text":"(Boolean(file))"},"desc":"Explicitly convert value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected any value in conditional. An explicit comparison or type conversion is required.","line":368,"column":19,"nodeType":"CallExpression","messageId":"conditionErrorAny","endLine":368,"endColumn":64,"suggestions":[{"messageId":"conditionFixCastBoolean","fix":{"range":[10963,11008],"text":"(Boolean(file.permissions.includes(\"can_manage_users\")))"},"desc":"Explicitly convert value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":1,"message":"Unsafe call of a(n) `any` typed value.","line":368,"column":19,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":368,"endColumn":44},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .permissions on an `any` value.","line":368,"column":24,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":368,"endColumn":35}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":134,"fixableErrorCount":0,"fixableWarningCount":0,"source":"#!/usr/bin/env node\n/**\n * Test suite for LexMap scanners\n *\n * Tests:\n * 1. File path correctly maps to module via owns_paths\n * 2. Cross-module calls are detected\n * 3. Feature flag checks are detected\n * 4. Permission checks are detected\n */\n\nimport * as fs from \"fs\";\nimport * as path from \"path\";\nimport { exec } from \"child_process\";\nimport { promisify } from \"util\";\n\nconst execAsync = promisify(exec);\n\nconst TEST_DIR = \"/tmp/scanner_tests\";\nconst POLICY_FILE = path.join(TEST_DIR, \"test.policy.json\");\nconst SCANNERS_DIR = \"/home/runner/work/lex/lex/policy/scanners\";\n\n// Test counter\nlet totalTests = 0;\nlet passedTests = 0;\n\nfunction test(name: string, fn: () => void | Promise<void>) {\n  totalTests++;\n  try {\n    const result = fn();\n    if (result instanceof Promise) {\n      return result\n        .then(() => {\n          passedTests++;\n          console.log(`✓ ${name}`);\n        })\n        .catch((error) => {\n          console.error(`✗ ${name}`);\n          console.error(`  Error: ${error.message}`);\n        });\n    } else {\n      passedTests++;\n      console.log(`✓ ${name}`);\n    }\n  } catch (error: any) {\n    console.error(`✗ ${name}`);\n    console.error(`  Error: ${error.message}`);\n  }\n}\n\nasync function setup() {\n  // Clean and create test directory\n  if (fs.existsSync(TEST_DIR)) {\n    fs.rmSync(TEST_DIR, { recursive: true });\n  }\n  fs.mkdirSync(TEST_DIR, { recursive: true });\n  fs.mkdirSync(path.join(TEST_DIR, \"ui/admin\"), { recursive: true });\n  fs.mkdirSync(path.join(TEST_DIR, \"services/auth\"), { recursive: true });\n  fs.mkdirSync(path.join(TEST_DIR, \"web-ui/userAdmin\"), { recursive: true });\n\n  // Create policy file\n  const policy = {\n    modules: {\n      \"ui/admin\": {\n        coords: [0, 1],\n        owns_paths: [\"ui/admin/**\"],\n        feature_flags: [\"admin_panel\"],\n        requires_permissions: [\"can_manage_users\"],\n      },\n      \"services/auth\": {\n        coords: [1, 1],\n        owns_paths: [\"services/auth/**\"],\n        owns_namespaces: [\"App\\\\\\\\Services\\\\\\\\Auth\"],\n        allowed_callers: [\"services/user-api\"],\n      },\n      \"ui/user-admin-panel\": {\n        coords: [0, 2],\n        owns_paths: [\"web-ui/userAdmin/**\"],\n        feature_flags: [\"beta_user_admin\"],\n        requires_permissions: [\"can_manage_users\"],\n      },\n    },\n  };\n\n  fs.writeFileSync(POLICY_FILE, JSON.stringify(policy, null, 2));\n}\n\nasync function testTypeScriptScanner() {\n  console.log(\"\\n--- TypeScript Scanner Tests ---\\n\");\n\n  // Test 1: File path maps to module\n  fs.writeFileSync(\n    path.join(TEST_DIR, \"ui/admin/panel.ts\"),\n    `\nexport class AdminPanel {\n  constructor() {}\n}\n`\n  );\n\n  await test(\"TS: File path maps to module via owns_paths\", async () => {\n    const { stdout } = await execAsync(\n      `npx tsx ${path.join(SCANNERS_DIR, \"ts_scanner.ts\")} ${TEST_DIR} ${POLICY_FILE}`\n    );\n    const result = JSON.parse(stdout);\n    const file = result.files.find((f: any) => f.path === \"ui/admin/panel.ts\");\n    if (!file || file.module_scope !== \"ui/admin\") {\n      throw new Error(`Expected module_scope 'ui/admin', got '${file?.module_scope}'`);\n    }\n  });\n\n  // Test 2: Cross-module calls detected\n  fs.writeFileSync(\n    path.join(TEST_DIR, \"ui/admin/panel.ts\"),\n    `\nimport { AuthService } from '../../services/auth/AuthService';\n\nexport class AdminPanel {\n  constructor(private auth: AuthService) {}\n}\n`\n  );\n\n  fs.writeFileSync(\n    path.join(TEST_DIR, \"services/auth/AuthService.ts\"),\n    `\nexport class AuthService {}\n`\n  );\n\n  await test(\"TS: Cross-module calls are detected\", async () => {\n    const { stdout } = await execAsync(\n      `npx tsx ${path.join(SCANNERS_DIR, \"ts_scanner.ts\")} ${TEST_DIR} ${POLICY_FILE}`\n    );\n    const result = JSON.parse(stdout);\n    const edge = result.module_edges?.find(\n      (e: any) => e.from_module === \"ui/admin\" && e.to_module === \"services/auth\"\n    );\n    if (!edge) {\n      throw new Error(\"Expected cross-module edge not found\");\n    }\n  });\n\n  // Test 3: Feature flag detection - flags.flag_name\n  fs.writeFileSync(\n    path.join(TEST_DIR, \"web-ui/userAdmin/view.tsx\"),\n    `\nexport function View() {\n  if (flags.beta_user_admin) {\n    return <div>Admin</div>;\n  }\n}\n`\n  );\n\n  await test(\"TS: Feature flag detection - flags.flag_name\", async () => {\n    const { stdout } = await execAsync(\n      `npx tsx ${path.join(SCANNERS_DIR, \"ts_scanner.ts\")} ${TEST_DIR} ${POLICY_FILE}`\n    );\n    const result = JSON.parse(stdout);\n    const file = result.files.find((f: any) => f.path.includes(\"userAdmin/view\"));\n    if (!file || !file.feature_flags.includes(\"beta_user_admin\")) {\n      throw new Error(`Expected feature flag 'beta_user_admin' not found`);\n    }\n  });\n\n  // Test 4: Feature flag detection - featureFlags.isEnabled()\n  fs.writeFileSync(\n    path.join(TEST_DIR, \"ui/admin/feature.ts\"),\n    `\nif (featureFlags.isEnabled('admin_panel')) {\n  console.log('enabled');\n}\n`\n  );\n\n  await test(\"TS: Feature flag detection - featureFlags.isEnabled()\", async () => {\n    const { stdout } = await execAsync(\n      `npx tsx ${path.join(SCANNERS_DIR, \"ts_scanner.ts\")} ${TEST_DIR} ${POLICY_FILE}`\n    );\n    const result = JSON.parse(stdout);\n    const file = result.files.find((f: any) => f.path.includes(\"feature.ts\"));\n    if (!file || !file.feature_flags.includes(\"admin_panel\")) {\n      throw new Error(`Expected feature flag 'admin_panel' not found`);\n    }\n  });\n\n  // Test 5: Permission checks detected\n  fs.writeFileSync(\n    path.join(TEST_DIR, \"ui/admin/access.ts\"),\n    `\nexport function checkAccess(user: User) {\n  return hasPermission('can_manage_users');\n}\n`\n  );\n\n  await test(\"TS: Permission checks are detected\", async () => {\n    const { stdout } = await execAsync(\n      `npx tsx ${path.join(SCANNERS_DIR, \"ts_scanner.ts\")} ${TEST_DIR} ${POLICY_FILE}`\n    );\n    const result = JSON.parse(stdout);\n    const file = result.files.find((f: any) => f.path.includes(\"access.ts\"));\n    if (!file || !file.permissions.includes(\"can_manage_users\")) {\n      throw new Error(`Expected permission 'can_manage_users' not found`);\n    }\n  });\n}\n\nasync function testPythonScanner() {\n  console.log(\"\\n--- Python Scanner Tests ---\\n\");\n\n  // Test 1: File path maps to module\n  fs.writeFileSync(\n    path.join(TEST_DIR, \"services/auth/service.py\"),\n    `\nclass AuthService:\n    pass\n`\n  );\n\n  await test(\"Python: File path maps to module via owns_paths\", async () => {\n    const { stdout } = await execAsync(\n      `python3 ${path.join(SCANNERS_DIR, \"python_scanner.py\")} ${TEST_DIR} ${POLICY_FILE}`\n    );\n    const result = JSON.parse(stdout);\n    const file = result.files.find((f: any) => f.path.includes(\"services/auth\"));\n    if (!file || file.module_scope !== \"services/auth\") {\n      throw new Error(`Expected module_scope 'services/auth', got '${file?.module_scope}'`);\n    }\n  });\n\n  // Test 2: Cross-module calls detected\n  fs.writeFileSync(\n    path.join(TEST_DIR, \"ui/admin/views.py\"),\n    `\nfrom services.auth.service import AuthService\n\nclass AdminPanel:\n    pass\n`\n  );\n\n  await test(\"Python: Cross-module imports are detected\", async () => {\n    const { stdout } = await execAsync(\n      `python3 ${path.join(SCANNERS_DIR, \"python_scanner.py\")} ${TEST_DIR} ${POLICY_FILE}`\n    );\n    const result = JSON.parse(stdout);\n    const edge = result.module_edges?.find(\n      (e: any) => e.from_module === \"ui/admin\" && e.to_module === \"services/auth\"\n    );\n    if (!edge) {\n      throw new Error(\"Expected cross-module edge not found\");\n    }\n  });\n\n  // Test 3: Feature flag detection\n  fs.writeFileSync(\n    path.join(TEST_DIR, \"web-ui/userAdmin/controller.py\"),\n    `\ndef view(request):\n    if feature_flags.is_enabled('beta_user_admin'):\n        return render_admin()\n`\n  );\n\n  await test(\"Python: Feature flag detection - feature_flags.is_enabled()\", async () => {\n    const { stdout } = await execAsync(\n      `python3 ${path.join(SCANNERS_DIR, \"python_scanner.py\")} ${TEST_DIR} ${POLICY_FILE}`\n    );\n    const result = JSON.parse(stdout);\n    const file = result.files.find((f: any) => f.path.includes(\"controller.py\"));\n    if (!file || !file.feature_flags.includes(\"beta_user_admin\")) {\n      throw new Error(`Expected feature flag 'beta_user_admin' not found`);\n    }\n  });\n\n  // Test 4: Permission checks detected\n  fs.writeFileSync(\n    path.join(TEST_DIR, \"ui/admin/perms.py\"),\n    `\ndef check(user):\n    return user.has_perm('can_manage_users')\n`\n  );\n\n  await test(\"Python: Permission checks are detected\", async () => {\n    const { stdout } = await execAsync(\n      `python3 ${path.join(SCANNERS_DIR, \"python_scanner.py\")} ${TEST_DIR} ${POLICY_FILE}`\n    );\n    const result = JSON.parse(stdout);\n    const file = result.files.find((f: any) => f.path.includes(\"perms.py\"));\n    if (!file || !file.permissions.includes(\"can_manage_users\")) {\n      throw new Error(`Expected permission 'can_manage_users' not found`);\n    }\n  });\n}\n\nasync function testPHPScanner() {\n  console.log(\"\\n--- PHP Scanner Tests ---\\n\");\n\n  // Test 1: File path maps to module\n  fs.writeFileSync(\n    path.join(TEST_DIR, \"services/auth/Service.php\"),\n    `\n<?php\nnamespace App\\\\Services\\\\Auth;\nclass AuthService {}\n`\n  );\n\n  await test(\"PHP: File path maps to module via owns_paths\", async () => {\n    const { stdout } = await execAsync(\n      `python3 ${path.join(SCANNERS_DIR, \"php_scanner.py\")} ${TEST_DIR} ${POLICY_FILE}`\n    );\n    const result = JSON.parse(stdout);\n    const file = result.files.find((f: any) => f.path.includes(\"services/auth\"));\n    if (!file || file.module_scope !== \"services/auth\") {\n      throw new Error(`Expected module_scope 'services/auth', got '${file?.module_scope}'`);\n    }\n  });\n\n  // Test 2: Feature flag detection\n  fs.writeFileSync(\n    path.join(TEST_DIR, \"ui/admin/Controller.php\"),\n    `\n<?php\nclass Controller {\n    public function index() {\n        if (FeatureFlags::enabled('admin_panel')) {\n            return view('admin');\n        }\n    }\n}\n`\n  );\n\n  await test(\"PHP: Feature flag detection - FeatureFlags::enabled()\", async () => {\n    const { stdout } = await execAsync(\n      `python3 ${path.join(SCANNERS_DIR, \"php_scanner.py\")} ${TEST_DIR} ${POLICY_FILE}`\n    );\n    const result = JSON.parse(stdout);\n    const file = result.files.find((f: any) => f.path.includes(\"Controller.php\"));\n    if (!file || !file.feature_flags.includes(\"admin_panel\")) {\n      throw new Error(`Expected feature flag 'admin_panel' not found`);\n    }\n  });\n\n  // Test 3: Permission checks detected\n  fs.writeFileSync(\n    path.join(TEST_DIR, \"ui/admin/Access.php\"),\n    `\n<?php\nclass Access {\n    public function check($user) {\n        return $user->can('can_manage_users');\n    }\n}\n`\n  );\n\n  await test(\"PHP: Permission checks are detected\", async () => {\n    const { stdout } = await execAsync(\n      `python3 ${path.join(SCANNERS_DIR, \"php_scanner.py\")} ${TEST_DIR} ${POLICY_FILE}`\n    );\n    const result = JSON.parse(stdout);\n    const file = result.files.find((f: any) => f.path.includes(\"Access.php\"));\n    if (!file || !file.permissions.includes(\"can_manage_users\")) {\n      throw new Error(`Expected permission 'can_manage_users' not found`);\n    }\n  });\n}\n\nasync function main() {\n  console.log(\"=== LexMap Scanner Test Suite ===\\n\");\n\n  await setup();\n  await testTypeScriptScanner();\n  await testPythonScanner();\n  await testPHPScanner();\n\n  console.log(`\\n=== Results: ${passedTests}/${totalTests} tests passed ===`);\n\n  if (passedTests !== totalTests) {\n    process.exit(1);\n  }\n}\n\nmain().catch((error) => {\n  console.error(\"Test suite error:\", error);\n  process.exit(1);\n});\n","usedDeprecatedRules":[]},{"filePath":"/srv/lex-mcp/lex/src/policy/scanners/ts_scanner.ts","messages":[{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":103,"column":9,"nodeType":"Identifier","messageId":"conditionErrorNullableString","endLine":103,"endColumn":19,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[2297,2307],"text":"(policyPath != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[2297,2307],"text":"(policyPath ?? \"\")"},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[2297,2307],"text":"(Boolean(policyPath))"},"desc":"Explicitly convert value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":1,"message":"Unsafe assignment of an `any` value.","line":106,"column":9,"nodeType":"AssignmentExpression","messageId":"anyAssignment","endLine":106,"endColumn":48},{"ruleId":"@typescript-eslint/restrict-template-expressions","severity":1,"message":"Invalid type \"unknown\" of template literal expression.","line":108,"column":63,"nodeType":"Identifier","messageId":"invalidType","endLine":108,"endColumn":68},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":150,"column":13,"nodeType":"Identifier","messageId":"conditionErrorNullableString","endLine":150,"endColumn":21,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[3819,3827],"text":"moduleId != null"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[3819,3827],"text":"moduleId ?? \"\""},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[3819,3827],"text":"Boolean(moduleId)"},"desc":"Explicitly convert value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":156,"column":17,"nodeType":"Identifier","messageId":"conditionErrorNullableString","endLine":156,"endColumn":31,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[4065,4079],"text":"(targetModuleId != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[4065,4079],"text":"(targetModuleId ?? \"\")"},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[4065,4079],"text":"(Boolean(targetModuleId))"},"desc":"Explicitly convert value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'error' is defined but never used.","line":169,"column":14,"nodeType":null,"messageId":"unusedVar","endLine":169,"endColumn":19},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable boolean value in conditional. Please handle the nullish case explicitly.","line":216,"column":17,"nodeType":"ChainExpression","messageId":"conditionErrorNullableBoolean","endLine":216,"endColumn":79,"suggestions":[{"messageId":"conditionFixDefaultFalse","fix":{"range":[5689,5751],"text":"(modifiers?.some((m) => m.kind === ts.SyntaxKind.ExportKeyword)) ?? false"},"desc":"Explicitly treat nullish value the same as false (`value ?? false`)"},{"messageId":"conditionFixCompareTrue","fix":{"range":[5689,5751],"text":"(modifiers?.some((m) => m.kind === ts.SyntaxKind.ExportKeyword)) === true"},"desc":"Change condition to check if true (`value === true`)"}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":7,"fixableErrorCount":0,"fixableWarningCount":0,"source":"#!/usr/bin/env node\n/**\n * LexMap TypeScript/JavaScript Scanner Plugin\n *\n * Scans TypeScript and JavaScript files and extracts architectural facts.\n *\n * Contract: Outputs JSON conforming to ../docs/schemas/scanner-output.schema.json\n *\n * Usage:\n *     node ts_scanner.ts <directory> > output.json\n *\n * Philosophy:\n *     This scanner is DUMB BY DESIGN.\n *     It observes code and reports facts.\n *     It does NOT make architectural decisions.\n *\n *     - Extracts: classes, functions, interfaces, imports\n *     - Detects: feature flags, permission checks\n *     - Reports: what it sees, nothing more\n *\n *     LexMap (not the scanner) decides:\n *     - Which module a file belongs to\n *     - Whether an import is allowed\n *     - Whether a boundary is violated\n *\n * Output Schema:\n *     {\n *       \"language\": \"typescript\",\n *       \"files\": [\n *         {\n *           \"path\": \"relative/path/to/File.ts\",\n *           \"declarations\": [...],\n *           \"imports\": [...],\n *           \"feature_flags\": [...],\n *           \"permissions\": [...],\n *           \"warnings\": []\n *         }\n *       ]\n *     }\n *\n * Dependencies:\n *     npm install typescript glob\n *\n * Author: LexMap Scanner Plugin\n * License: MIT\n */\n\nimport * as ts from \"typescript\";\nimport * as fs from \"fs\";\nimport * as path from \"path\";\nimport { glob } from \"glob\";\nimport {\n  Policy,\n  ModuleEdge,\n  resolveFileToModule,\n  resolveImportToModule,\n  detectFeatureFlags,\n  detectPermissions,\n} from \"./common.js\";\n\ninterface Declaration {\n  type: string;\n  name: string;\n  namespace?: string;\n}\n\ninterface Import {\n  from: string;\n  type: string;\n  imported?: string[];\n}\n\ninterface FileData {\n  path: string;\n  module_scope?: string;\n  declarations: Declaration[];\n  imports: Import[];\n  feature_flags: string[];\n  permissions: string[];\n  warnings: string[];\n}\n\ninterface ScannerOutput {\n  language: string;\n  files: FileData[];\n  module_edges?: ModuleEdge[];\n}\n\nclass TypeScriptScanner {\n  private rootDir: string;\n  private output: ScannerOutput;\n  private policy?: Policy;\n\n  constructor(rootDir: string, policyPath?: string) {\n    this.rootDir = path.resolve(rootDir);\n    this.output = {\n      language: \"typescript\",\n      files: [],\n      module_edges: [],\n    };\n\n    // Load policy file if provided\n    if (policyPath && fs.existsSync(policyPath)) {\n      try {\n        const policyContent = fs.readFileSync(policyPath, \"utf-8\");\n        this.policy = JSON.parse(policyContent);\n      } catch (error) {\n        console.error(`Warning: Failed to load policy file: ${error}`);\n      }\n    }\n  }\n\n  async scan(): Promise<ScannerOutput> {\n    // Find all .ts and .tsx files (excluding node_modules, .d.ts)\n    const pattern = `${this.rootDir}/**/*.{ts,tsx}`;\n    const files = await glob(pattern, {\n      ignore: [\"**/node_modules/**\", \"**/*.d.ts\"],\n    });\n\n    for (const filePath of files) {\n      const fileData = this.scanFile(filePath);\n      if (fileData) {\n        this.output.files.push(fileData);\n      }\n    }\n\n    return this.output;\n  }\n\n  private scanFile(filePath: string): FileData | null {\n    try {\n      const content = fs.readFileSync(filePath, \"utf-8\");\n      const relativePath = path.relative(this.rootDir, filePath);\n\n      const sourceFile = ts.createSourceFile(filePath, content, ts.ScriptTarget.Latest, true);\n\n      const imports = this.extractImports(sourceFile);\n      const fileData: FileData = {\n        path: relativePath,\n        declarations: this.extractDeclarations(sourceFile),\n        imports,\n        feature_flags: detectFeatureFlags(content),\n        permissions: detectPermissions(content),\n        warnings: [],\n      };\n\n      // Resolve module ownership if policy is available\n      if (this.policy) {\n        const moduleId = resolveFileToModule(relativePath, this.policy);\n        if (moduleId) {\n          fileData.module_scope = moduleId;\n\n          // Detect cross-module calls\n          for (const imp of imports) {\n            const targetModuleId = resolveImportToModule(imp.from, relativePath, this.policy);\n            if (targetModuleId && targetModuleId !== moduleId) {\n              this.output.module_edges!.push({\n                from_module: moduleId,\n                to_module: targetModuleId,\n                from_file: relativePath,\n                import_statement: imp.from,\n              });\n            }\n          }\n        }\n      }\n\n      return fileData;\n    } catch (error) {\n      return null;\n    }\n  }\n\n  private extractDeclarations(sourceFile: ts.SourceFile): Declaration[] {\n    const declarations: Declaration[] = [];\n\n    const visit = (node: ts.Node) => {\n      // Extract classes\n      if (ts.isClassDeclaration(node) && node.name) {\n        declarations.push({\n          type: \"class\",\n          name: node.name.text,\n        });\n      }\n\n      // Extract interfaces\n      if (ts.isInterfaceDeclaration(node)) {\n        declarations.push({\n          type: \"interface\",\n          name: node.name.text,\n        });\n      }\n\n      // Extract type aliases\n      if (ts.isTypeAliasDeclaration(node)) {\n        declarations.push({\n          type: \"type\",\n          name: node.name.text,\n        });\n      }\n\n      // Extract function declarations\n      if (ts.isFunctionDeclaration(node) && node.name) {\n        declarations.push({\n          type: \"function\",\n          name: node.name.text,\n        });\n      }\n\n      // Extract const/let/var declarations (top-level exports)\n      if (ts.isVariableStatement(node)) {\n        node.declarationList.declarations.forEach((decl) => {\n          if (ts.isIdentifier(decl.name)) {\n            // Check if it's exported\n            const modifiers = node.modifiers;\n            if (modifiers?.some((m) => m.kind === ts.SyntaxKind.ExportKeyword)) {\n              declarations.push({\n                type: \"variable\",\n                name: decl.name.text,\n              });\n            }\n          }\n        });\n      }\n\n      ts.forEachChild(node, visit);\n    };\n\n    visit(sourceFile);\n    return declarations;\n  }\n\n  private extractImports(sourceFile: ts.SourceFile): Import[] {\n    const imports: Import[] = [];\n\n    const visit = (node: ts.Node) => {\n      if (ts.isImportDeclaration(node)) {\n        const moduleSpecifier = node.moduleSpecifier;\n        if (ts.isStringLiteral(moduleSpecifier)) {\n          const from = moduleSpecifier.text;\n          const imported: string[] = [];\n\n          if (node.importClause) {\n            const { namedBindings } = node.importClause;\n\n            // import { A, B } from 'module'\n            if (namedBindings && ts.isNamedImports(namedBindings)) {\n              namedBindings.elements.forEach((element) => {\n                imported.push(element.name.text);\n              });\n            }\n\n            // import * as name from 'module'\n            if (namedBindings && ts.isNamespaceImport(namedBindings)) {\n              imported.push(namedBindings.name.text);\n            }\n\n            // import defaultName from 'module'\n            if (node.importClause.name) {\n              imported.push(node.importClause.name.text);\n            }\n          }\n\n          imports.push({\n            from,\n            type: \"import_statement\",\n            imported: imported.length > 0 ? imported : undefined,\n          });\n        }\n      }\n\n      ts.forEachChild(node, visit);\n    };\n\n    visit(sourceFile);\n    return imports;\n  }\n}\n\nasync function main() {\n  const args = process.argv.slice(2);\n\n  if (args.length < 1) {\n    console.error(\"Usage: node ts_scanner.ts <directory> [policy.json]\");\n    console.error(\"\");\n    console.error(\"Outputs JSON conforming to ../docs/schemas/scanner-output.schema.json\");\n    console.error(\"\");\n    console.error(\"Options:\");\n    console.error(\"  policy.json  Optional path to lexmap.policy.json for module resolution\");\n    process.exit(1);\n  }\n\n  const directory = args[0];\n  const policyPath = args[1];\n\n  if (!fs.existsSync(directory) || !fs.statSync(directory).isDirectory()) {\n    console.error(`Error: ${directory} is not a directory`);\n    process.exit(1);\n  }\n\n  const scanner = new TypeScriptScanner(directory, policyPath);\n  const output = await scanner.scan();\n\n  // Output JSON to stdout\n  console.log(JSON.stringify(output, null, 2));\n}\n\nmain().catch((error) => {\n  console.error(\"Error:\", error);\n  process.exit(1);\n});\n","usedDeprecatedRules":[]},{"filePath":"/srv/lex-mcp/lex/src/shared/aliases/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/srv/lex-mcp/lex/src/shared/aliases/resolver.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'AmbiguousSubstringError' is defined but never used. Allowed unused vars must match /^_/u.","line":13,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":13,"endColumn":33},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'NoMatchFoundError' is defined but never used. Allowed unused vars must match /^_/u.","line":13,"column":35,"nodeType":null,"messageId":"unusedVar","endLine":13,"endColumn":52},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":36,"column":7,"nodeType":"Identifier","messageId":"conditionErrorNullableString","endLine":36,"endColumn":21,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[1213,1227],"text":"(aliasTablePath != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[1213,1227],"text":"(aliasTablePath ?? \"\")"},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[1213,1227],"text":"(Boolean(aliasTablePath))"},"desc":"Explicitly convert value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":42,"column":19,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":42,"endColumn":22,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1455,1458],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1455,1458],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":45,"column":9,"nodeType":"MemberExpression","messageId":"conditionErrorNullableString","endLine":45,"endColumn":30,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[1591,1612],"text":"process.env.LEX_DEBUG != null"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[1591,1612],"text":"process.env.LEX_DEBUG ?? \"\""},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[1591,1612],"text":"Boolean(process.env.LEX_DEBUG)"},"desc":"Explicitly convert value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .message on an `any` value.","line":46,"column":64,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":46,"endColumn":71},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected object value in conditional. The condition is always true.","line":154,"column":7,"nodeType":"MemberExpression","messageId":"conditionErrorObject","endLine":154,"endColumn":27}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":7,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Module ID Alias Resolver\n *\n * Provides alias resolution for module IDs with explicit alias table support.\n * This allows humans to use shorthand names during /remember while maintaining\n * vocabulary alignment with lexmap.policy.json.\n */\n\nexport { AmbiguousSubstringError, NoMatchFoundError } from \"./types.js\";\n// @ts-ignore - cross-package import from compiled dist\nimport type { Policy } from \"../types/policy.js\";\nimport type { AliasTable, AliasResolution, ResolverOptions } from \"./types.js\";\nimport { AmbiguousSubstringError, NoMatchFoundError } from \"./types.js\";\nimport { readFileSync } from \"fs\";\nimport { join, dirname } from \"path\";\nimport { fileURLToPath } from \"url\";\n\n// Cache for loaded alias table\nlet aliasTableCache: AliasTable | null = null;\n\n/**\n * Load alias table from aliases.json with caching\n *\n * @param aliasTablePath - Optional path to alias table JSON file\n * @returns Loaded and cached alias table\n */\nexport function loadAliasTable(aliasTablePath?: string): AliasTable {\n  // Return cached table if available\n  if (aliasTableCache) {\n    return aliasTableCache;\n  }\n\n  try {\n    // Default to aliases.json in the same directory as this module\n    const defaultPath =\n      aliasTablePath || join(dirname(fileURLToPath(import.meta.url)), \"aliases.json\");\n\n    const content = readFileSync(defaultPath, \"utf-8\");\n    aliasTableCache = JSON.parse(content) as AliasTable;\n\n    return aliasTableCache;\n  } catch (error: any) {\n    // If alias table doesn't exist or can't be loaded, return empty table\n    // This is expected for new installations\n    if (process.env.LEX_DEBUG) {\n      console.error(`[LEX] Could not load alias table: ${error.message}`);\n      console.error(`[LEX] Using empty alias table`);\n    }\n\n    aliasTableCache = { aliases: {} };\n    return aliasTableCache;\n  }\n}\n\n/**\n * Clear the alias table cache (useful for testing)\n */\nexport function clearAliasTableCache(): void {\n  aliasTableCache = null;\n}\n\n/**\n * Find all module IDs that contain the given substring\n *\n * @param substring - The substring to search for\n * @param availableModules - Set of available module IDs\n * @param minLength - Minimum substring length (default: 3)\n * @returns Array of matching module IDs\n */\nexport function findSubstringMatches(\n  substring: string,\n  availableModules: Set<string>,\n  minLength: number = 3\n): string[] {\n  // Enforce minimum length\n  if (substring.length < minLength) {\n    return [];\n  }\n\n  const matches: string[] = [];\n  const lowerSubstring = substring.toLowerCase();\n\n  for (const moduleId of availableModules) {\n    if (moduleId.toLowerCase().includes(lowerSubstring)) {\n      matches.push(moduleId);\n    }\n  }\n\n  return matches;\n}\n\n/**\n * Resolve a module ID through the alias system\n *\n * Resolution order:\n * 1. Exact match (confidence 1.0)\n * 2. Alias table (confidence 1.0) [Phase 1]\n * 3. Fuzzy typo correction (handled by module_ids/validator) [Phase 2]\n * 4. Unique substring match (confidence 0.9) [Phase 3]\n * 5. Return unknown with confidence 0\n *\n * @param input - The module ID string to resolve (may be an alias or substring)\n * @param policy - The policy containing canonical module IDs\n * @param aliasTable - Optional pre-loaded alias table (will load default if not provided)\n * @param options - Optional resolver options\n * @returns AliasResolution with canonical ID, confidence, and source\n *\n * @example\n * ```typescript\n * // Exact match (fast path)\n * const result1 = await resolveModuleId('services/auth-core', policy);\n * // { canonical: 'services/auth-core', confidence: 1.0, original: 'services/auth-core', source: 'exact' }\n *\n * // Alias lookup\n * const result2 = await resolveModuleId('auth-core', policy);\n * // { canonical: 'services/auth-core', confidence: 1.0, original: 'auth-core', source: 'alias' }\n *\n * // Unique substring\n * const result3 = await resolveModuleId('user-access', policy);\n * // { canonical: 'services/user-access-api', confidence: 0.9, original: 'user-access', source: 'substring' }\n *\n * // Unknown\n * const result4 = await resolveModuleId('unknown-module', policy);\n * // { canonical: 'unknown-module', confidence: 0, original: 'unknown-module', source: 'fuzzy' }\n * ```\n */\nexport async function resolveModuleId(\n  input: string,\n  policy: Policy,\n  aliasTable?: AliasTable,\n  options?: ResolverOptions\n): Promise<AliasResolution> {\n  const policyModuleIds = new Set(Object.keys(policy.modules));\n\n  // Default options\n  const opts: Required<ResolverOptions> = {\n    noSubstring: options?.noSubstring ?? false,\n    minSubstringLength: options?.minSubstringLength ?? 3,\n    maxAmbiguousMatches: options?.maxAmbiguousMatches ?? 5,\n  };\n\n  // Phase 1: Exact match in policy (fast path)\n  if (policyModuleIds.has(input)) {\n    return {\n      canonical: input,\n      confidence: 1.0,\n      original: input,\n      source: \"exact\",\n    };\n  }\n\n  // Phase 2: Alias table lookup\n  const table = aliasTable || loadAliasTable();\n  if (table.aliases[input]) {\n    const aliasEntry = table.aliases[input];\n    return {\n      canonical: aliasEntry.canonical,\n      confidence: aliasEntry.confidence,\n      original: input,\n      source: \"alias\",\n    };\n  }\n\n  // Phase 3: Fuzzy matching (handled by module_ids/validator, not here)\n  // This resolver returns confidence 0 and lets the validator handle fuzzy logic\n\n  // Phase 4: Substring matching (if enabled)\n  if (!opts.noSubstring) {\n    const substringMatches = findSubstringMatches(input, policyModuleIds, opts.minSubstringLength);\n\n    if (substringMatches.length === 1) {\n      // Unique substring match - confidence 0.9\n      return {\n        canonical: substringMatches[0],\n        confidence: 0.9,\n        original: input,\n        source: \"substring\",\n      };\n    } else if (substringMatches.length > 1) {\n      // Ambiguous - return with confidence 0 and mark as fuzzy\n      // The caller can check for substring matches if needed\n      return {\n        canonical: input,\n        confidence: 0,\n        original: input,\n        source: \"fuzzy\",\n      };\n    }\n  }\n\n  // No match found - return original with confidence 0\n  return {\n    canonical: input,\n    confidence: 0,\n    original: input,\n    source: \"fuzzy\",\n  };\n}\n","usedDeprecatedRules":[]},{"filePath":"/srv/lex-mcp/lex/src/shared/aliases/types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/srv/lex-mcp/lex/src/shared/atlas/atlas-frame.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'PolicyModule' is defined but never used. Allowed unused vars must match /^_/u.","line":9,"column":15,"nodeType":null,"messageId":"unusedVar","endLine":9,"endColumn":27},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":1,"message":"Unsafe assignment of an error typed value.","line":70,"column":9,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":70,"endColumn":40},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":1,"message":"Unsafe assignment of an error typed value.","line":81,"column":11,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":81,"endColumn":50},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .modules on an `error` typed value.","line":81,"column":33,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":81,"endColumn":40},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected any value in conditional. An explicit comparison or type conversion is required.","line":83,"column":10,"nodeType":"Identifier","messageId":"conditionErrorAny","endLine":83,"endColumn":22,"suggestions":[{"messageId":"conditionFixCastBoolean","fix":{"range":[2585,2597],"text":"(Boolean(policyModule))"},"desc":"Explicitly convert value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected any value in conditional. An explicit comparison or type conversion is required.","line":99,"column":9,"nodeType":"MemberExpression","messageId":"conditionErrorAny","endLine":99,"endColumn":32,"suggestions":[{"messageId":"conditionFixCastBoolean","fix":{"range":[2982,3005],"text":"Boolean(policyModule.owns_paths)"},"desc":"Explicitly convert value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .owns_paths on an `error` typed value.","line":99,"column":22,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":99,"endColumn":32},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":1,"message":"Unsafe assignment of an error typed value.","line":100,"column":7,"nodeType":"AssignmentExpression","messageId":"anyAssignment","endLine":100,"endColumn":55},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .owns_paths on an `error` typed value.","line":100,"column":45,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":100,"endColumn":55},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected any value in conditional. An explicit comparison or type conversion is required.","line":102,"column":9,"nodeType":"MemberExpression","messageId":"conditionErrorAny","endLine":102,"endColumn":37,"suggestions":[{"messageId":"conditionFixCastBoolean","fix":{"range":[3079,3107],"text":"Boolean(policyModule.owns_namespaces)"},"desc":"Explicitly convert value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .owns_namespaces on an `error` typed value.","line":102,"column":22,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":102,"endColumn":37},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":1,"message":"Unsafe assignment of an error typed value.","line":103,"column":7,"nodeType":"AssignmentExpression","messageId":"anyAssignment","endLine":103,"endColumn":65},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .owns_namespaces on an `error` typed value.","line":103,"column":50,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":103,"endColumn":65},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected any value in conditional. An explicit comparison or type conversion is required.","line":105,"column":9,"nodeType":"MemberExpression","messageId":"conditionErrorAny","endLine":105,"endColumn":37,"suggestions":[{"messageId":"conditionFixCastBoolean","fix":{"range":[3191,3219],"text":"Boolean(policyModule.allowed_callers)"},"desc":"Explicitly convert value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .allowed_callers on an `error` typed value.","line":105,"column":22,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":105,"endColumn":37},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":1,"message":"Unsafe assignment of an error typed value.","line":106,"column":7,"nodeType":"AssignmentExpression","messageId":"anyAssignment","endLine":106,"endColumn":65},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .allowed_callers on an `error` typed value.","line":106,"column":50,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":106,"endColumn":65},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected any value in conditional. An explicit comparison or type conversion is required.","line":108,"column":9,"nodeType":"MemberExpression","messageId":"conditionErrorAny","endLine":108,"endColumn":39,"suggestions":[{"messageId":"conditionFixCastBoolean","fix":{"range":[3303,3333],"text":"Boolean(policyModule.forbidden_callers)"},"desc":"Explicitly convert value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .forbidden_callers on an `error` typed value.","line":108,"column":22,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":108,"endColumn":39},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":1,"message":"Unsafe assignment of an error typed value.","line":109,"column":7,"nodeType":"AssignmentExpression","messageId":"anyAssignment","endLine":109,"endColumn":69},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .forbidden_callers on an `error` typed value.","line":109,"column":52,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":109,"endColumn":69},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected any value in conditional. An explicit comparison or type conversion is required.","line":111,"column":9,"nodeType":"MemberExpression","messageId":"conditionErrorAny","endLine":111,"endColumn":35,"suggestions":[{"messageId":"conditionFixCastBoolean","fix":{"range":[3421,3447],"text":"Boolean(policyModule.feature_flags)"},"desc":"Explicitly convert value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .feature_flags on an `error` typed value.","line":111,"column":22,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":111,"endColumn":35},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":1,"message":"Unsafe assignment of an error typed value.","line":112,"column":7,"nodeType":"AssignmentExpression","messageId":"anyAssignment","endLine":112,"endColumn":61},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .feature_flags on an `error` typed value.","line":112,"column":48,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":112,"endColumn":61},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected any value in conditional. An explicit comparison or type conversion is required.","line":114,"column":9,"nodeType":"MemberExpression","messageId":"conditionErrorAny","endLine":114,"endColumn":42,"suggestions":[{"messageId":"conditionFixCastBoolean","fix":{"range":[3527,3560],"text":"Boolean(policyModule.requires_permissions)"},"desc":"Explicitly convert value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .requires_permissions on an `error` typed value.","line":114,"column":22,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":114,"endColumn":42},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":1,"message":"Unsafe assignment of an error typed value.","line":115,"column":7,"nodeType":"AssignmentExpression","messageId":"anyAssignment","endLine":115,"endColumn":75},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .requires_permissions on an `error` typed value.","line":115,"column":55,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":115,"endColumn":75},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected any value in conditional. An explicit comparison or type conversion is required.","line":117,"column":9,"nodeType":"MemberExpression","messageId":"conditionErrorAny","endLine":117,"endColumn":35,"suggestions":[{"messageId":"conditionFixCastBoolean","fix":{"range":[3654,3680],"text":"Boolean(policyModule.kill_patterns)"},"desc":"Explicitly convert value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .kill_patterns on an `error` typed value.","line":117,"column":22,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":117,"endColumn":35},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":1,"message":"Unsafe assignment of an error typed value.","line":118,"column":7,"nodeType":"AssignmentExpression","messageId":"anyAssignment","endLine":118,"endColumn":61},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .kill_patterns on an `error` typed value.","line":118,"column":48,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":118,"endColumn":61},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected any value in conditional. An explicit comparison or type conversion is required.","line":120,"column":9,"nodeType":"MemberExpression","messageId":"conditionErrorAny","endLine":120,"endColumn":27,"suggestions":[{"messageId":"conditionFixCastBoolean","fix":{"range":[3760,3778],"text":"Boolean(policyModule.notes)"},"desc":"Explicitly convert value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .notes on an `error` typed value.","line":120,"column":22,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":120,"endColumn":27},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":1,"message":"Unsafe assignment of an error typed value.","line":121,"column":7,"nodeType":"AssignmentExpression","messageId":"anyAssignment","endLine":121,"endColumn":45},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .notes on an `error` typed value.","line":121,"column":40,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":121,"endColumn":45},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":160,"column":11,"nodeType":"MemberExpression","messageId":"conditionErrorNullableString","endLine":160,"endColumn":22,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[4980,4991],"text":"edge.reason != null"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[4980,4991],"text":"edge.reason ?? \"\""},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[4980,4991],"text":"Boolean(edge.reason)"},"desc":"Explicitly convert value to a boolean (`Boolean(value)`)"}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":38,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Atlas Frame - Spatial neighborhood extraction from policy graph\n *\n * Computes the \"map page\" around a set of modules with fold radius.\n * Implements full policy graph traversal with N-hop neighborhood extraction.\n */\n\nimport { loadPolicy } from \"../policy/loader.js\";\nimport type { PolicyModule } from \"../types/policy.js\";\nimport { extractNeighborhood, generateCoordinates } from \"./graph.js\";\nexport interface AtlasFrame {\n  atlas_timestamp: string;\n  seed_modules: string[];\n  fold_radius: number;\n  modules: AtlasModule[];\n  edges: AtlasEdge[];\n  critical_rule: string;\n}\n\nexport interface AtlasModule {\n  id: string;\n  coords?: [number, number];\n  owns_paths?: string[];\n  owns_namespaces?: string[];\n  allowed_callers?: string[];\n  forbidden_callers?: string[];\n  feature_flags?: string[];\n  requires_permissions?: string[];\n  kill_patterns?: string[];\n  notes?: string;\n}\n\nexport interface AtlasEdge {\n  from: string;\n  to: string;\n  allowed: boolean;\n  reason?: string;\n}\n\n/**\n * Generate Atlas Frame for a set of seed modules\n *\n * Implements full fold radius algorithm with policy graph traversal:\n * - Loads policy graph from lexmap.policy.json\n * - Starts with seed modules\n * - Expands N hops via allowed_callers/forbidden_callers edges\n * - Includes full policy metadata for all discovered modules\n * - Returns complete neighborhood with edges and coordinates\n *\n * Algorithm:\n * 1. Load policy from lexmap.policy.json\n * 2. Use BFS to extract N-hop neighborhood from seed modules\n * 3. Generate 2D coordinates for visualization\n * 4. Include full PolicyModule metadata for each module\n * 5. Include all edges (allowed + forbidden) between modules\n *\n * @param seedModules - Module IDs from Frame.module_scope\n * @param foldRadius - How many hops to expand (default: 1)\n * @param policyPath - Optional custom policy path\n * @returns Atlas Frame with neighborhood context\n */\nexport function generateAtlasFrame(\n  seedModules: string[],\n  foldRadius: number = 1,\n  policyPath?: string\n): AtlasFrame {\n  const timestamp = new Date().toISOString();\n\n  // Load policy graph\n  const policy = loadPolicy(policyPath);\n\n  // Extract neighborhood using BFS traversal\n  const neighborhood = extractNeighborhood(policy, seedModules, foldRadius);\n\n  // Generate coordinates for visualization\n  const coordinates = generateCoordinates(neighborhood.modules, neighborhood.edges);\n\n  // Build AtlasModule objects with full metadata\n  const modules: AtlasModule[] = [];\n  for (const moduleId of neighborhood.modules) {\n    const policyModule = policy.modules[moduleId];\n\n    if (!policyModule) {\n      // Module not found in policy - include minimal data\n      modules.push({\n        id: moduleId,\n        coords: coordinates.get(moduleId),\n      });\n      continue;\n    }\n\n    // Include full policy metadata\n    const atlasModule: AtlasModule = {\n      id: moduleId,\n      coords: coordinates.get(moduleId),\n    };\n\n    // Copy all PolicyModule fields to AtlasModule\n    if (policyModule.owns_paths) {\n      atlasModule.owns_paths = policyModule.owns_paths;\n    }\n    if (policyModule.owns_namespaces) {\n      atlasModule.owns_namespaces = policyModule.owns_namespaces;\n    }\n    if (policyModule.allowed_callers) {\n      atlasModule.allowed_callers = policyModule.allowed_callers;\n    }\n    if (policyModule.forbidden_callers) {\n      atlasModule.forbidden_callers = policyModule.forbidden_callers;\n    }\n    if (policyModule.feature_flags) {\n      atlasModule.feature_flags = policyModule.feature_flags;\n    }\n    if (policyModule.requires_permissions) {\n      atlasModule.requires_permissions = policyModule.requires_permissions;\n    }\n    if (policyModule.kill_patterns) {\n      atlasModule.kill_patterns = policyModule.kill_patterns;\n    }\n    if (policyModule.notes) {\n      atlasModule.notes = policyModule.notes;\n    }\n\n    modules.push(atlasModule);\n  }\n\n  // Convert edges to AtlasEdge format\n  const edges: AtlasEdge[] = neighborhood.edges.map((edge) => ({\n    from: edge.from,\n    to: edge.to,\n    allowed: edge.type === \"allowed\",\n    reason: edge.type === \"forbidden\" ? \"forbidden_caller\" : undefined,\n  }));\n\n  return {\n    atlas_timestamp: timestamp,\n    seed_modules: seedModules,\n    fold_radius: foldRadius,\n    modules,\n    edges,\n    critical_rule: \"Every module name MUST match the IDs in lexmap.policy.json. No ad hoc naming.\",\n  };\n}\n\n/**\n * Format Atlas Frame for display in MCP response\n */\nexport function formatAtlasFrame(atlasFrame: AtlasFrame): string {\n  const { seed_modules, fold_radius, modules, edges } = atlasFrame;\n\n  let output = `\\n📊 Atlas Frame (fold radius: ${fold_radius})\\n`;\n  output += `🌱 Seed modules: ${seed_modules.join(\", \")}\\n`;\n  output += `📦 Total modules in neighborhood: ${modules.length}\\n`;\n\n  if (edges.length > 0) {\n    output += `\\n🔗 Edges:\\n`;\n    edges.forEach((edge) => {\n      const status = edge.allowed ? \"✅ Allowed\" : \"🚫 Forbidden\";\n      output += `  ${edge.from} → ${edge.to} [${status}]`;\n      if (edge.reason) {\n        output += ` - ${edge.reason}`;\n      }\n      output += \"\\n\";\n    });\n  }\n\n  return output;\n}\n","usedDeprecatedRules":[]},{"filePath":"/srv/lex-mcp/lex/src/shared/atlas/auto-tune.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/srv/lex-mcp/lex/src/shared/atlas/cache.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'CacheKey' is defined but never used. Allowed unused vars must match /^_/u.","line":13,"column":11,"nodeType":null,"messageId":"unusedVar","endLine":13,"endColumn":19}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Atlas Frame Caching\n *\n * Caches computed Atlas Frames by (module_scope, radius) key to avoid\n * redundant graph traversals. Tracks cache hits/misses for performance monitoring.\n */\n\nimport type { AtlasFrame } from \"./types.js\";\n\n/**\n * Cache key for an Atlas Frame computation\n */\ninterface CacheKey {\n  moduleScope: string[]; // Sorted module IDs\n  radius: number;\n}\n\n/**\n * Cache statistics for monitoring\n */\nexport interface CacheStats {\n  hits: number;\n  misses: number;\n  evictions: number;\n  size: number;\n}\n\n/**\n * In-memory cache for Atlas Frames\n *\n * Uses LRU eviction when cache size exceeds maxSize.\n * Cache keys are based on sorted module_scope + radius for consistency.\n */\nexport class AtlasFrameCache {\n  private cache: Map<string, { frame: AtlasFrame; timestamp: number }> = new Map();\n  private accessOrder: string[] = []; // LRU tracking\n  private maxSize: number;\n  private stats: CacheStats = {\n    hits: 0,\n    misses: 0,\n    evictions: 0,\n    size: 0,\n  };\n\n  /**\n   * Create a new Atlas Frame cache\n   *\n   * @param maxSize - Maximum number of entries to cache (default: 100)\n   */\n  constructor(maxSize: number = 100) {\n    this.maxSize = maxSize;\n  }\n\n  /**\n   * Generate cache key from module scope and radius\n   *\n   * Normalizes module_scope by sorting to ensure consistent keys\n   * regardless of input order.\n   */\n  private getCacheKey(moduleScope: string[], radius: number): string {\n    const sortedModules = Array.from(moduleScope).sort();\n    return `${sortedModules.join(\",\")}:${radius}`;\n  }\n\n  /**\n   * Get cached Atlas Frame if available\n   *\n   * @param moduleScope - Module IDs to look up\n   * @param radius - Fold radius\n   * @returns Cached AtlasFrame or undefined if not found\n   */\n  get(moduleScope: string[], radius: number): AtlasFrame | undefined {\n    const key = this.getCacheKey(moduleScope, radius);\n    const entry = this.cache.get(key);\n\n    if (entry) {\n      // Cache hit - update access order\n      this.stats.hits++;\n      this.updateAccessOrder(key);\n      return entry.frame;\n    }\n\n    // Cache miss\n    this.stats.misses++;\n    return undefined;\n  }\n\n  /**\n   * Store Atlas Frame in cache\n   *\n   * @param moduleScope - Module IDs\n   * @param radius - Fold radius\n   * @param frame - Computed Atlas Frame\n   */\n  set(moduleScope: string[], radius: number, frame: AtlasFrame): void {\n    const key = this.getCacheKey(moduleScope, radius);\n\n    // Check if we need to evict entries\n    if (this.cache.size >= this.maxSize && !this.cache.has(key)) {\n      this.evictLRU();\n    }\n\n    // Store frame with timestamp\n    this.cache.set(key, {\n      frame,\n      timestamp: Date.now(),\n    });\n\n    // Update access order\n    this.updateAccessOrder(key);\n    this.stats.size = this.cache.size;\n  }\n\n  /**\n   * Update LRU access order\n   */\n  private updateAccessOrder(key: string): void {\n    // Remove key from current position\n    const index = this.accessOrder.indexOf(key);\n    if (index > -1) {\n      this.accessOrder.splice(index, 1);\n    }\n\n    // Add to end (most recently used)\n    this.accessOrder.push(key);\n  }\n\n  /**\n   * Evict least recently used entry\n   */\n  private evictLRU(): void {\n    if (this.accessOrder.length === 0) {\n      return;\n    }\n\n    const lruKey = this.accessOrder.shift()!;\n    this.cache.delete(lruKey);\n    this.stats.evictions++;\n    this.stats.size = this.cache.size;\n  }\n\n  /**\n   * Clear all cached entries\n   */\n  clear(): void {\n    this.cache.clear();\n    this.accessOrder = [];\n    this.stats.size = 0;\n  }\n\n  /**\n   * Get cache statistics\n   */\n  getStats(): CacheStats {\n    return { ...this.stats };\n  }\n\n  /**\n   * Get cache hit rate\n   */\n  getHitRate(): number {\n    const total = this.stats.hits + this.stats.misses;\n    return total === 0 ? 0 : this.stats.hits / total;\n  }\n\n  /**\n   * Reset statistics (but keep cached entries)\n   */\n  resetStats(): void {\n    this.stats = {\n      hits: 0,\n      misses: 0,\n      evictions: 0,\n      size: this.cache.size,\n    };\n  }\n}\n\n/**\n * Global cache instance\n *\n * Shared across all Atlas Frame generation calls.\n * Can be disabled by setting enableCache = false.\n */\nlet globalCache: AtlasFrameCache | null = new AtlasFrameCache();\nlet enableCache = true;\n\n/**\n * Get the global cache instance\n */\nexport function getCache(): AtlasFrameCache | null {\n  return enableCache ? globalCache : null;\n}\n\n/**\n * Enable or disable caching globally\n */\nexport function setEnableCache(enabled: boolean): void {\n  enableCache = enabled;\n  if (!enabled && globalCache) {\n    globalCache.clear();\n  }\n}\n\n/**\n * Reset the global cache\n */\nexport function resetCache(): void {\n  if (globalCache) {\n    globalCache.clear();\n    globalCache.resetStats();\n  }\n}\n\n/**\n * Get global cache statistics\n */\nexport function getCacheStats(): CacheStats {\n  return globalCache\n    ? globalCache.getStats()\n    : {\n        hits: 0,\n        misses: 0,\n        evictions: 0,\n        size: 0,\n      };\n}\n","usedDeprecatedRules":[]},{"filePath":"/srv/lex-mcp/lex/src/shared/atlas/demo.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/srv/lex-mcp/lex/src/shared/atlas/fold-radius.ts","messages":[{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected object value in conditional. The condition is always true.","line":40,"column":9,"nodeType":"MemberExpression","messageId":"conditionErrorObject","endLine":40,"endColumn":31},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected object value in conditional. The condition is always true.","line":69,"column":67,"nodeType":"MemberExpression","messageId":"conditionErrorObject","endLine":69,"endColumn":93},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected object value in conditional. The condition is always true.","line":84,"column":10,"nodeType":"Identifier","messageId":"conditionErrorObject","endLine":84,"endColumn":22},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected object value in conditional. The condition is always true.","line":119,"column":10,"nodeType":"Identifier","messageId":"conditionErrorObject","endLine":119,"endColumn":22}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Fold radius algorithm - extract spatial neighborhood from policy graph\n *\n * Starting from seed modules, expand N hops via BFS to find adjacent modules\n * through allowed_callers/forbidden_callers relationships.\n */\n\nimport { Policy, AtlasFrame, AtlasModuleData, AtlasEdge } from \"./types.js\";\nimport { buildPolicyGraph, getNeighbors } from \"./graph.js\";\n\n/**\n * Compute the fold radius neighborhood around seed modules\n *\n * Uses BFS to traverse the policy graph up to N hops from seed modules,\n * collecting all modules and edges within the specified radius.\n *\n * @param seedModules - Array of module IDs to start from (from Frame.module_scope)\n * @param radius - Number of hops to expand (0 = only seeds, 1 = seeds + immediate neighbors, etc.)\n * @param policy - The policy object containing module definitions\n * @returns AtlasFrame with the spatial neighborhood\n */\nexport function computeFoldRadius(\n  seedModules: string[],\n  radius: number,\n  policy: Policy\n): AtlasFrame {\n  // Build the policy graph\n  const graph = buildPolicyGraph(policy);\n\n  // Track visited modules and their distance from seeds\n  const visited = new Set<string>();\n  const modulesByDistance = new Map<string, number>();\n  const inQueue = new Set<string>(); // Track modules already in queue\n\n  // BFS queue: [moduleId, distance]\n  const queue: Array<[string, number]> = [];\n\n  // Initialize with seed modules\n  for (const seedId of seedModules) {\n    if (policy.modules[seedId]) {\n      queue.push([seedId, 0]);\n      modulesByDistance.set(seedId, 0);\n      inQueue.add(seedId);\n    }\n  }\n\n  // BFS traversal\n  while (queue.length > 0) {\n    // Using shift() for proper FIFO queue behavior (BFS requirement)\n    // Performance note: O(n) per operation, but acceptable for typical graphs (<100 modules)\n    const [currentId, distance] = queue.shift()!;\n    inQueue.delete(currentId);\n\n    // Skip if already visited\n    if (visited.has(currentId)) {\n      continue;\n    }\n\n    visited.add(currentId);\n\n    // Stop expanding if we've reached the radius limit\n    if (distance >= radius) {\n      continue;\n    }\n\n    // Expand to neighbors\n    const neighbors = getNeighbors(currentId, graph);\n    for (const neighborId of neighbors) {\n      if (!visited.has(neighborId) && !inQueue.has(neighborId) && policy.modules[neighborId]) {\n        // Add to queue only if not already visited or queued\n        modulesByDistance.set(neighborId, distance + 1);\n        queue.push([neighborId, distance + 1]);\n        inQueue.add(neighborId);\n      }\n    }\n  }\n\n  // Collect module data for all visited modules\n  const modules: AtlasModuleData[] = [];\n  const moduleIds = Array.from(visited);\n\n  for (const moduleId of moduleIds) {\n    const policyModule = policy.modules[moduleId];\n    if (!policyModule) continue;\n\n    const atlasModule: AtlasModuleData = {\n      id: moduleId,\n    };\n\n    // Include optional fields if present\n    if (policyModule.coords) {\n      atlasModule.coords = policyModule.coords;\n    }\n    if (policyModule.allowed_callers && policyModule.allowed_callers.length > 0) {\n      atlasModule.allowed_callers = policyModule.allowed_callers;\n    }\n    if (policyModule.forbidden_callers && policyModule.forbidden_callers.length > 0) {\n      atlasModule.forbidden_callers = policyModule.forbidden_callers;\n    }\n    if (policyModule.feature_flags && policyModule.feature_flags.length > 0) {\n      atlasModule.feature_flags = policyModule.feature_flags;\n    }\n    if (policyModule.requires_permissions && policyModule.requires_permissions.length > 0) {\n      atlasModule.requires_permissions = policyModule.requires_permissions;\n    }\n    if (policyModule.kill_patterns && policyModule.kill_patterns.length > 0) {\n      atlasModule.kill_patterns = policyModule.kill_patterns;\n    }\n\n    modules.push(atlasModule);\n  }\n\n  // Build edges between modules in the neighborhood\n  const edges: AtlasEdge[] = [];\n  const edgeSet = new Set<string>(); // Track unique edges\n\n  for (const moduleId of moduleIds) {\n    const policyModule = policy.modules[moduleId];\n    if (!policyModule) continue;\n\n    // Add edges for allowed callers\n    if (policyModule.allowed_callers) {\n      for (const callerId of policyModule.allowed_callers) {\n        // Only include edge if both modules are in the neighborhood\n        if (visited.has(callerId)) {\n          const edgeKey = `${callerId}->${moduleId}:allowed`;\n          if (!edgeSet.has(edgeKey)) {\n            edges.push({\n              from: callerId,\n              to: moduleId,\n              allowed: true,\n            });\n            edgeSet.add(edgeKey);\n          }\n        }\n      }\n    }\n\n    // Add edges for forbidden callers\n    if (policyModule.forbidden_callers) {\n      for (const callerId of policyModule.forbidden_callers) {\n        // Only include edge if both modules are in the neighborhood\n        if (visited.has(callerId)) {\n          const edgeKey = `${callerId}->${moduleId}:forbidden`;\n          if (!edgeSet.has(edgeKey)) {\n            edges.push({\n              from: callerId,\n              to: moduleId,\n              allowed: false,\n              reason: \"forbidden_caller\",\n            });\n            edgeSet.add(edgeKey);\n          }\n        }\n      }\n    }\n  }\n\n  // Create Atlas Frame\n  const atlasFrame: AtlasFrame = {\n    atlas_timestamp: new Date().toISOString(),\n    seed_modules: seedModules,\n    fold_radius: radius,\n    modules,\n    edges,\n    critical_rule: \"Every module name MUST match the IDs in lexmap.policy.json. No ad hoc naming.\",\n  };\n\n  return atlasFrame;\n}\n","usedDeprecatedRules":[]},{"filePath":"/srv/lex-mcp/lex/src/shared/atlas/graph.ts","messages":[{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .modules on an `error` typed value.","line":40,"column":45,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":40,"endColumn":52},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .modules on an `error` typed value.","line":46,"column":62,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":46,"endColumn":69},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":1,"message":"Unsafe assignment of an error typed value.","line":47,"column":11,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":47,"endColumn":46},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected any value in conditional. An explicit comparison or type conversion is required.","line":49,"column":9,"nodeType":"MemberExpression","messageId":"conditionErrorAny","endLine":49,"endColumn":31,"suggestions":[{"messageId":"conditionFixCastBoolean","fix":{"range":[1563,1585],"text":"Boolean(module.allowed_callers)"},"desc":"Explicitly convert value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .allowed_callers on an `error` typed value.","line":49,"column":16,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":49,"endColumn":31},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .allowed_callers on an `error` typed value.","line":50,"column":37,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":50,"endColumn":52},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected any value in conditional. An explicit comparison or type conversion is required.","line":60,"column":9,"nodeType":"MemberExpression","messageId":"conditionErrorAny","endLine":60,"endColumn":33,"suggestions":[{"messageId":"conditionFixCastBoolean","fix":{"range":[1954,1978],"text":"Boolean(module.forbidden_callers)"},"desc":"Explicitly convert value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .forbidden_callers on an `error` typed value.","line":60,"column":16,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":60,"endColumn":33},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .forbidden_callers on an `error` typed value.","line":61,"column":37,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":61,"endColumn":54},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected any value in conditional. An explicit comparison or type conversion is required.","line":106,"column":9,"nodeType":"MemberExpression","messageId":"conditionErrorAny","endLine":106,"endColumn":31,"suggestions":[{"messageId":"conditionFixCastBoolean","fix":{"range":[3606,3628],"text":"Boolean(policy.modules[seedId])"},"desc":"Explicitly convert value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .modules on an `error` typed value.","line":106,"column":16,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":106,"endColumn":23},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .modules on an `error` typed value.","line":330,"column":46,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":330,"endColumn":53},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .modules on an `error` typed value.","line":337,"column":62,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":337,"endColumn":69},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":1,"message":"Unsafe assignment of an error typed value.","line":338,"column":11,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":338,"endColumn":46},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected any value in conditional. An explicit comparison or type conversion is required.","line":339,"column":9,"nodeType":"MemberExpression","messageId":"conditionErrorAny","endLine":339,"endColumn":31,"suggestions":[{"messageId":"conditionFixCastBoolean","fix":{"range":[11079,11101],"text":"Boolean(module.allowed_callers)"},"desc":"Explicitly convert value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .allowed_callers on an `error` typed value.","line":339,"column":16,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":339,"endColumn":31},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .allowed_callers on an `error` typed value.","line":340,"column":35,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":340,"endColumn":50}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":17,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Graph Algorithms for Policy Graph Traversal\n *\n * Provides BFS/DFS traversal with hop limiting for fold radius computation.\n * Used by Atlas Frame generation to extract module neighborhoods.\n */\n\n// @ts-ignore - importing from compiled dist directory\nimport type { Policy, PolicyModule } from \"../../types/policy.js\";\n\nexport interface GraphEdge {\n  from: string;\n  to: string;\n  type: \"allowed\" | \"forbidden\";\n}\n\nexport interface NeighborhoodResult {\n  modules: Set<string>;\n  edges: GraphEdge[];\n}\n\n/**\n * Build adjacency lists from policy graph\n *\n * Creates both allowed and forbidden edge lists from the policy.\n * This enables traversal along allowed paths while tracking forbidden\n * edges for context.\n *\n * @param policy - The policy object containing module definitions\n * @returns Object with allowed and forbidden adjacency lists\n */\nexport function buildAdjacencyLists(policy: Policy): {\n  allowedEdges: Map<string, Set<string>>;\n  forbiddenEdges: Map<string, Set<string>>;\n} {\n  const allowedEdges = new Map<string, Set<string>>();\n  const forbiddenEdges = new Map<string, Set<string>>();\n\n  // Initialize empty sets for all modules\n  for (const moduleId of Object.keys(policy.modules)) {\n    allowedEdges.set(moduleId, new Set());\n    forbiddenEdges.set(moduleId, new Set());\n  }\n\n  // Build edges from allowed_callers and forbidden_callers\n  for (const [moduleId, moduleData] of Object.entries(policy.modules)) {\n    const module = moduleData as PolicyModule;\n    // allowed_callers defines who can call this module (inbound edges)\n    if (module.allowed_callers) {\n      for (const callerId of module.allowed_callers) {\n        // Add edge from caller to this module\n        if (!allowedEdges.has(callerId)) {\n          allowedEdges.set(callerId, new Set());\n        }\n        allowedEdges.get(callerId)!.add(moduleId);\n      }\n    }\n\n    // forbidden_callers defines who cannot call this module (inbound forbidden edges)\n    if (module.forbidden_callers) {\n      for (const callerId of module.forbidden_callers) {\n        // Add forbidden edge from caller to this module\n        if (!forbiddenEdges.has(callerId)) {\n          forbiddenEdges.set(callerId, new Set());\n        }\n        forbiddenEdges.get(callerId)!.add(moduleId);\n      }\n    }\n  }\n\n  return { allowedEdges, forbiddenEdges };\n}\n\n/**\n * Extract N-hop neighborhood from seed modules using BFS\n *\n * Traverses the policy graph starting from seed modules, expanding\n * up to N hops away. Includes both allowed and forbidden edges for context.\n *\n * Algorithm:\n * 1. Start with seed modules at distance 0\n * 2. For each module at distance d < foldRadius:\n *    - Find all neighbors via allowed edges (both inbound and outbound)\n *    - Find all neighbors via forbidden edges (both inbound and outbound)\n *    - Mark neighbors at distance d+1\n * 3. Collect all edges (allowed + forbidden) between discovered modules\n *\n * @param policy - The policy object containing module definitions\n * @param seedModules - Starting module IDs\n * @param foldRadius - Maximum number of hops to expand (default: 1)\n * @returns Set of module IDs and edges in the neighborhood\n */\nexport function extractNeighborhood(\n  policy: Policy,\n  seedModules: string[],\n  foldRadius: number = 1\n): NeighborhoodResult {\n  const { allowedEdges, forbiddenEdges } = buildAdjacencyLists(policy);\n\n  // Track discovered modules and their distance from seeds\n  const discovered = new Map<string, number>();\n  const queue: Array<{ moduleId: string; distance: number }> = [];\n\n  // Initialize with seed modules\n  for (const seedId of seedModules) {\n    if (policy.modules[seedId]) {\n      discovered.set(seedId, 0);\n      queue.push({ moduleId: seedId, distance: 0 });\n    }\n  }\n\n  // BFS traversal\n  while (queue.length > 0) {\n    const { moduleId, distance } = queue.shift()!;\n\n    // Stop if we've reached the fold radius\n    if (distance >= foldRadius) {\n      continue;\n    }\n\n    // Find neighbors via allowed edges (outbound)\n    const outboundNeighbors = allowedEdges.get(moduleId) || new Set();\n    for (const neighborId of outboundNeighbors) {\n      if (!discovered.has(neighborId)) {\n        discovered.set(neighborId, distance + 1);\n        queue.push({ moduleId: neighborId, distance: distance + 1 });\n      }\n    }\n\n    // Find neighbors via allowed edges (inbound - modules that can call this one)\n    for (const [potentialCallerId, targets] of allowedEdges.entries()) {\n      if (targets.has(moduleId) && !discovered.has(potentialCallerId)) {\n        discovered.set(potentialCallerId, distance + 1);\n        queue.push({ moduleId: potentialCallerId, distance: distance + 1 });\n      }\n    }\n\n    // Find neighbors via forbidden edges (outbound)\n    const forbiddenOutbound = forbiddenEdges.get(moduleId) || new Set();\n    for (const neighborId of forbiddenOutbound) {\n      if (!discovered.has(neighborId)) {\n        discovered.set(neighborId, distance + 1);\n        queue.push({ moduleId: neighborId, distance: distance + 1 });\n      }\n    }\n\n    // Find neighbors via forbidden edges (inbound - modules that cannot call this one)\n    for (const [potentialCallerId, targets] of forbiddenEdges.entries()) {\n      if (targets.has(moduleId) && !discovered.has(potentialCallerId)) {\n        discovered.set(potentialCallerId, distance + 1);\n        queue.push({ moduleId: potentialCallerId, distance: distance + 1 });\n      }\n    }\n  }\n\n  // Collect all edges between discovered modules\n  const edges: GraphEdge[] = [];\n  const discoveredModules = new Set(discovered.keys());\n\n  // Collect allowed edges\n  for (const [from, targets] of allowedEdges.entries()) {\n    if (discoveredModules.has(from)) {\n      for (const to of targets) {\n        if (discoveredModules.has(to)) {\n          edges.push({ from, to, type: \"allowed\" });\n        }\n      }\n    }\n  }\n\n  // Collect forbidden edges (for context)\n  for (const [from, targets] of forbiddenEdges.entries()) {\n    if (discoveredModules.has(from)) {\n      for (const to of targets) {\n        if (discoveredModules.has(to)) {\n          edges.push({ from, to, type: \"forbidden\" });\n        }\n      }\n    }\n  }\n\n  return {\n    modules: discoveredModules,\n    edges,\n  };\n}\n\n/**\n * Generate 2D coordinates for modules using a simple force-directed layout\n *\n * Uses a basic spring-embedding algorithm:\n * - Modules repel each other (avoid overlap)\n * - Connected modules attract each other (edges pull them together)\n * - Iteratively adjust positions until stable or max iterations reached\n *\n * @param modules - Module IDs to position\n * @param edges - Edges between modules\n * @param width - Canvas width (default: 1000)\n * @param height - Canvas height (default: 1000)\n * @param iterations - Number of layout iterations (default: 50)\n * @returns Map of module ID to [x, y] coordinates\n */\nexport function generateCoordinates(\n  modules: Set<string>,\n  edges: GraphEdge[],\n  width: number = 1000,\n  height: number = 1000,\n  iterations: number = 50\n): Map<string, [number, number]> {\n  const coords = new Map<string, [number, number]>();\n  const velocities = new Map<string, [number, number]>();\n\n  // Initialize with random positions\n  const moduleList = Array.from(modules);\n  for (const moduleId of moduleList) {\n    coords.set(moduleId, [Math.random() * width, Math.random() * height]);\n    velocities.set(moduleId, [0, 0]);\n  }\n\n  // Spring-embedding parameters\n  const repulsionStrength = 1000;\n  const attractionStrength = 0.01;\n  const damping = 0.8;\n  const minDistance = 50; // Minimum distance between nodes\n\n  // Iterative force-directed layout\n  for (let iter = 0; iter < iterations; iter++) {\n    const forces = new Map<string, [number, number]>();\n\n    // Initialize forces\n    for (const moduleId of moduleList) {\n      forces.set(moduleId, [0, 0]);\n    }\n\n    // Repulsion forces (all pairs)\n    for (let i = 0; i < moduleList.length; i++) {\n      for (let j = i + 1; j < moduleList.length; j++) {\n        const m1 = moduleList[i];\n        const m2 = moduleList[j];\n        const [x1, y1] = coords.get(m1)!;\n        const [x2, y2] = coords.get(m2)!;\n\n        const dx = x2 - x1;\n        const dy = y2 - y1;\n        const distanceSquared = dx * dx + dy * dy;\n        const distance = Math.sqrt(distanceSquared);\n\n        // Prevent division by zero for overlapping nodes\n        if (distance < 0.01) continue;\n\n        // Apply inverse-square repulsion\n        const force = repulsionStrength / distanceSquared;\n        const fx = (dx / distance) * force;\n        const fy = (dy / distance) * force;\n\n        const [f1x, f1y] = forces.get(m1)!;\n        const [f2x, f2y] = forces.get(m2)!;\n        forces.set(m1, [f1x - fx, f1y - fy]);\n        forces.set(m2, [f2x + fx, f2y + fy]);\n      }\n    }\n\n    // Attraction forces (connected nodes)\n    for (const edge of edges) {\n      // Only use allowed edges for attraction (forbidden edges don't pull)\n      if (edge.type !== \"allowed\") continue;\n\n      const [x1, y1] = coords.get(edge.from)!;\n      const [x2, y2] = coords.get(edge.to)!;\n\n      const dx = x2 - x1;\n      const dy = y2 - y1;\n      const distance = Math.sqrt(dx * dx + dy * dy);\n\n      // Skip if nodes are at the same position\n      if (distance < 0.01) continue;\n\n      // Spring force proportional to distance\n      const force = distance * attractionStrength;\n      const fx = (dx / distance) * force;\n      const fy = (dy / distance) * force;\n\n      const [f1x, f1y] = forces.get(edge.from)!;\n      const [f2x, f2y] = forces.get(edge.to)!;\n      forces.set(edge.from, [f1x + fx, f1y + fy]);\n      forces.set(edge.to, [f2x - fx, f2y - fy]);\n    }\n\n    // Update positions with damping\n    for (const moduleId of moduleList) {\n      const [vx, vy] = velocities.get(moduleId)!;\n      const [fx, fy] = forces.get(moduleId)!;\n      const [x, y] = coords.get(moduleId)!;\n\n      // Update velocity with damping\n      const newVx = (vx + fx) * damping;\n      const newVy = (vy + fy) * damping;\n      velocities.set(moduleId, [newVx, newVy]);\n\n      // Update position\n      let newX = x + newVx;\n      let newY = y + newVy;\n\n      // Keep within bounds\n      newX = Math.max(minDistance, Math.min(width - minDistance, newX));\n      newY = Math.max(minDistance, Math.min(height - minDistance, newY));\n\n      coords.set(moduleId, [newX, newY]);\n    }\n  }\n\n  // Round coordinates to integers for cleaner output\n  for (const [moduleId, [x, y]] of coords.entries()) {\n    coords.set(moduleId, [Math.round(x), Math.round(y)]);\n  }\n\n  return coords;\n}\n\n/**\n * Adapter function for backward compatibility with fold-radius.ts\n * Builds a simple graph representation for BFS traversal\n */\nexport interface Graph {\n  modules: Set<string>;\n  adjacency: Map<string, Set<string>>;\n}\n\nexport function buildPolicyGraph(policy: Policy): Graph {\n  const modules = new Set(Object.keys(policy.modules));\n  const adjacency = new Map<string, Set<string>>();\n\n  for (const moduleId of modules) {\n    adjacency.set(moduleId, new Set());\n  }\n\n  for (const [moduleId, moduleData] of Object.entries(policy.modules)) {\n    const module = moduleData as PolicyModule;\n    if (module.allowed_callers) {\n      for (const caller of module.allowed_callers) {\n        if (adjacency.has(caller)) {\n          adjacency.get(caller)!.add(moduleId);\n        }\n      }\n    }\n  }\n\n  return { modules, adjacency };\n}\n\nexport function getNeighbors(moduleId: string, graph: Graph): string[] {\n  const neighbors = graph.adjacency.get(moduleId);\n  return neighbors ? Array.from(neighbors) : [];\n}\n","usedDeprecatedRules":[]},{"filePath":"/srv/lex-mcp/lex/src/shared/atlas/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/srv/lex-mcp/lex/src/shared/atlas/perf-test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/srv/lex-mcp/lex/src/shared/atlas/types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/srv/lex-mcp/lex/src/shared/atlas/verify-format.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/srv/lex-mcp/lex/src/shared/cli/check.ts","messages":[{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":1,"message":"Unsafe assignment of an `any` value.","line":91,"column":11,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":91,"endColumn":74},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":1,"message":"Unsafe assignment of an `any` value.","line":94,"column":11,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":94,"endColumn":53},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable boolean value in conditional. Please handle the nullish case explicitly.","line":100,"column":9,"nodeType":"MemberExpression","messageId":"conditionErrorNullableBoolean","endLine":100,"endColumn":21,"suggestions":[{"messageId":"conditionFixDefaultFalse","fix":{"range":[2405,2417],"text":"options.json ?? false"},"desc":"Explicitly treat nullish value the same as false (`value ?? false`)"},{"messageId":"conditionFixCompareTrue","fix":{"range":[2405,2417],"text":"options.json === true"},"desc":"Change condition to check if true (`value === true`)"}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":122,"column":19,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":122,"endColumn":22,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2857,2860],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2857,2860],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .message on an `any` value.","line":123,"column":39,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":123,"endColumn":46},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":136,"column":22,"nodeType":"MemberExpression","messageId":"conditionErrorNullableString","endLine":136,"endColumn":39,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[3252,3269],"text":"(file.module_scope != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[3252,3269],"text":"(file.module_scope ?? \"\")"},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[3252,3269],"text":"(Boolean(file.module_scope))"},"desc":"Explicitly convert value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":138,"column":10,"nodeType":"Identifier","messageId":"conditionErrorNullableString","endLine":138,"endColumn":18,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[3322,3331],"text":"moduleId == null"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[3323,3331],"text":"(moduleId ?? \"\")"},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[3322,3331],"text":"!Boolean(moduleId)"},"desc":"Explicitly convert value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":147,"column":11,"nodeType":"Identifier","messageId":"conditionErrorNullableString","endLine":147,"endColumn":27,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[3582,3598],"text":"importedModuleId != null"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[3582,3598],"text":"importedModuleId ?? \"\""},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[3582,3598],"text":"Boolean(importedModuleId)"},"desc":"Explicitly convert value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected object value in conditional. The condition is always true.","line":150,"column":13,"nodeType":"Identifier","messageId":"conditionErrorObject","endLine":150,"endColumn":27},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected object value in conditional. The condition is always true.","line":184,"column":11,"nodeType":"Identifier","messageId":"conditionErrorObject","endLine":184,"endColumn":19},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected object value in conditional. The condition is always true.","line":224,"column":7,"nodeType":"MemberExpression","messageId":"conditionErrorObject","endLine":224,"endColumn":33},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":281,"column":58,"nodeType":"Identifier","messageId":"conditionErrorNullableString","endLine":281,"endColumn":64,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[7505,7511],"text":"(ticket != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[7505,7511],"text":"(ticket ?? \"\")"},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[7505,7511],"text":"(Boolean(ticket))"},"desc":"Explicitly convert value to a boolean (`Boolean(value)`)"}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":12,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * CLI Command: lex check\n *\n * Wrapper around policy/check for user-friendly policy violation reporting.\n */\n\nimport { readFileSync, existsSync } from \"fs\";\nimport { resolve } from \"path\";\n\nexport interface CheckOptions {\n  json?: boolean;\n  ticket?: string;\n}\n\ninterface PolicyModule {\n  owns_namespaces?: string[];\n  owns_paths?: string[];\n  exposes?: string[];\n  allowed_callers?: string[];\n  forbidden_callers?: string[];\n  feature_flags?: string[];\n  requires_permissions?: string[];\n  kill_patterns?: string[];\n}\n\ninterface Policy {\n  modules: Record<string, PolicyModule>;\n  global_kill_patterns?: Array<{\n    pattern: string;\n    description: string;\n  }>;\n}\n\ninterface FileData {\n  path: string;\n  module_scope?: string;\n  declarations: Array<{ type: string; name: string; namespace?: string }>;\n  imports: Array<{ from: string; type: string }>;\n  feature_flags: string[];\n  permissions: string[];\n  warnings: string[];\n}\n\ninterface ModuleEdge {\n  from_module: string;\n  to_module: string;\n  from_file: string;\n  import_statement: string;\n}\n\ninterface MergedScannerOutput {\n  sources: string[];\n  files: FileData[];\n  module_edges?: ModuleEdge[];\n}\n\ninterface Violation {\n  file: string;\n  module: string;\n  type: \"forbidden_caller\" | \"kill_pattern\" | \"missing_permission\";\n  message: string;\n  details: string;\n}\n\n/**\n * Execute the 'lex check' command\n * Checks scanner output against policy and reports violations\n */\nexport async function check(\n  mergedJsonPath: string,\n  policyJsonPath: string,\n  options: CheckOptions = {}\n): Promise<void> {\n  try {\n    // Validate file paths\n    const resolvedMergedPath = resolve(mergedJsonPath);\n    const resolvedPolicyPath = resolve(policyJsonPath);\n\n    if (!existsSync(resolvedMergedPath)) {\n      console.error(`\\n❌ Scanner output not found: ${mergedJsonPath}\\n`);\n      process.exit(2);\n    }\n\n    if (!existsSync(resolvedPolicyPath)) {\n      console.error(`\\n❌ Policy file not found: ${policyJsonPath}\\n`);\n      process.exit(2);\n    }\n\n    // Load files\n    const scannerContent = readFileSync(resolvedMergedPath, \"utf-8\");\n    const scannerOutput: MergedScannerOutput = JSON.parse(scannerContent);\n\n    const policyContent = readFileSync(resolvedPolicyPath, \"utf-8\");\n    const policy: Policy = JSON.parse(policyContent);\n\n    // Run policy check\n    const violations = checkPolicy(scannerOutput, policy);\n\n    // Output results\n    if (options.json) {\n      console.log(\n        JSON.stringify(\n          {\n            violations,\n            count: violations.length,\n            ticket: options.ticket,\n          },\n          null,\n          2\n        )\n      );\n    } else {\n      displayViolations(violations, options.ticket);\n    }\n\n    // Exit with appropriate code\n    if (violations.length > 0) {\n      process.exit(1);\n    } else {\n      process.exit(0);\n    }\n  } catch (error: any) {\n    console.error(`\\n❌ Error: ${error.message}\\n`);\n    process.exit(2);\n  }\n}\n\n/**\n * Check scanner output against policy\n */\nfunction checkPolicy(scannerOutput: MergedScannerOutput, policy: Policy): Violation[] {\n  const violations: Violation[] = [];\n\n  for (const file of scannerOutput.files) {\n    // Use module_scope from scanner if available, otherwise resolve\n    const moduleId = file.module_scope || resolveFileToModule(file.path, policy);\n\n    if (!moduleId) {\n      // File doesn't belong to any known module - skip\n      continue;\n    }\n\n    // Check imports against forbidden_callers\n    for (const imp of file.imports) {\n      const importedModuleId = resolveImportToModule(imp.from, policy);\n\n      if (importedModuleId) {\n        const importedModule = policy.modules[importedModuleId];\n\n        if (importedModule && importedModule.forbidden_callers) {\n          // Check if current module matches any forbidden_caller pattern\n          for (const forbidden of importedModule.forbidden_callers) {\n            if (matchPattern(moduleId, forbidden)) {\n              violations.push({\n                file: file.path,\n                module: moduleId,\n                type: \"forbidden_caller\",\n                message: `Module ${moduleId} imports ${importedModuleId} but is forbidden`,\n                details: `Policy forbids: ${forbidden}`,\n              });\n            }\n          }\n        }\n      }\n    }\n\n    // Check for kill patterns\n    for (const warning of file.warnings) {\n      violations.push({\n        file: file.path,\n        module: moduleId,\n        type: \"kill_pattern\",\n        message: `Kill pattern detected: ${warning}`,\n        details: \"\",\n      });\n    }\n  }\n\n  // Check module_edges if available\n  if (scannerOutput.module_edges) {\n    for (const edge of scannerOutput.module_edges) {\n      const toModule = policy.modules[edge.to_module];\n\n      if (toModule && toModule.forbidden_callers) {\n        for (const forbidden of toModule.forbidden_callers) {\n          if (matchPattern(edge.from_module, forbidden)) {\n            violations.push({\n              file: edge.from_file,\n              module: edge.from_module,\n              type: \"forbidden_caller\",\n              message: `Module ${edge.from_module} calls ${edge.to_module} but is forbidden`,\n              details: `Import: ${edge.import_statement}, Policy forbids: ${forbidden}`,\n            });\n          }\n        }\n      }\n    }\n  }\n\n  return violations;\n}\n\n/**\n * Resolve file path to module ID\n */\nfunction resolveFileToModule(filePath: string, policy: Policy): string | null {\n  for (const [moduleId, module] of Object.entries(policy.modules)) {\n    if (module.owns_paths) {\n      for (const pathPattern of module.owns_paths) {\n        if (matchPath(filePath, pathPattern)) {\n          return moduleId;\n        }\n      }\n    }\n  }\n  return null;\n}\n\n/**\n * Resolve import path to module ID\n */\nfunction resolveImportToModule(importPath: string, policy: Policy): string | null {\n  // Try exact module ID match first (for test compatibility)\n  if (policy.modules[importPath]) {\n    return importPath;\n  }\n\n  // Try to match by namespace first (PHP style)\n  for (const [moduleId, module] of Object.entries(policy.modules)) {\n    if (module.owns_namespaces) {\n      for (const namespace of module.owns_namespaces) {\n        if (importPath.startsWith(namespace)) {\n          return moduleId;\n        }\n      }\n    }\n  }\n\n  // Try to match by file path pattern (TypeScript/JS style)\n  for (const [moduleId, module] of Object.entries(policy.modules)) {\n    if (module.owns_paths) {\n      for (const pathPattern of module.owns_paths) {\n        if (matchPath(importPath, pathPattern)) {\n          return moduleId;\n        }\n      }\n    }\n  }\n\n  return null;\n}\n\n/**\n * Match file path against pattern with glob support\n */\nfunction matchPath(filePath: string, pattern: string): boolean {\n  const regexPattern = pattern.replace(/\\*\\*/g, \".*\").replace(/\\*/g, \"[^/]*\").replace(/\\//g, \"\\\\/\");\n  const regex = new RegExp(`^${regexPattern}$`);\n  return regex.test(filePath);\n}\n\n/**\n * Match value against pattern\n */\nfunction matchPattern(value: string, pattern: string): boolean {\n  const regexPattern = pattern.replace(/\\*\\*/g, \".*\").replace(/\\*/g, \"[^/]*\");\n  const regex = new RegExp(`^${regexPattern}$`);\n  return regex.test(value);\n}\n\n/**\n * Display violations in user-friendly format\n */\nfunction displayViolations(violations: Violation[], ticket?: string): void {\n  if (violations.length === 0) {\n    console.log(\"\\n✅ No policy violations found\\n\");\n    return;\n  }\n\n  console.log(\n    `\\n❌ Found ${violations.length} policy violation(s)${ticket ? ` (ticket: ${ticket})` : \"\"}:\\n`\n  );\n\n  for (let i = 0; i < violations.length; i++) {\n    const v = violations[i];\n    console.log(`${i + 1}. ${v.file}`);\n    console.log(`   Module: ${v.module}`);\n    console.log(`   Type: ${v.type}`);\n    console.log(`   ${v.message}`);\n    if (v.details) {\n      console.log(`   ${v.details}`);\n    }\n    console.log(\"\");\n  }\n\n  console.log(`Exit code: 1 (violations found)\\n`);\n}\n","usedDeprecatedRules":[]},{"filePath":"/srv/lex-mcp/lex/src/shared/cli/index.ts","messages":[{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":1,"message":"Unsafe assignment of an `any` value.","line":24,"column":11,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":24,"endColumn":71},{"ruleId":"@typescript-eslint/no-unsafe-return","severity":1,"message":"Unsafe return of a value of type `any`.","line":25,"column":5,"nodeType":"ReturnStatement","messageId":"unsafeReturn","endLine":25,"endColumn":32},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .version on an `any` value.","line":25,"column":24,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":25,"endColumn":31},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":1,"message":"Unsafe assignment of an `any` value.","line":64,"column":9,"nodeType":"Property","messageId":"anyAssignment","endLine":64,"endColumn":30},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .jira on an `any` value.","line":64,"column":26,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":64,"endColumn":30},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":1,"message":"Unsafe assignment of an `any` value.","line":65,"column":9,"nodeType":"Property","messageId":"anyAssignment","endLine":65,"endColumn":50},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .referencePoint on an `any` value.","line":65,"column":36,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":65,"endColumn":50},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":1,"message":"Unsafe assignment of an `any` value.","line":66,"column":9,"nodeType":"Property","messageId":"anyAssignment","endLine":66,"endColumn":36},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .summary on an `any` value.","line":66,"column":29,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":66,"endColumn":36},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":1,"message":"Unsafe assignment of an `any` value.","line":67,"column":9,"nodeType":"Property","messageId":"anyAssignment","endLine":67,"endColumn":30},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .next on an `any` value.","line":67,"column":26,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":67,"endColumn":30},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":1,"message":"Unsafe assignment of an `any` value.","line":68,"column":9,"nodeType":"Property","messageId":"anyAssignment","endLine":68,"endColumn":36},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .modules on an `any` value.","line":68,"column":29,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":68,"endColumn":36},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":1,"message":"Unsafe assignment of an `any` value.","line":69,"column":9,"nodeType":"Property","messageId":"anyAssignment","endLine":69,"endColumn":38},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .blockers on an `any` value.","line":69,"column":30,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":69,"endColumn":38},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":1,"message":"Unsafe assignment of an `any` value.","line":70,"column":9,"nodeType":"Property","messageId":"anyAssignment","endLine":70,"endColumn":48},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .mergeBlockers on an `any` value.","line":70,"column":35,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":70,"endColumn":48},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":1,"message":"Unsafe assignment of an `any` value.","line":71,"column":9,"nodeType":"Property","messageId":"anyAssignment","endLine":71,"endColumn":46},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .testsFailing on an `any` value.","line":71,"column":34,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":71,"endColumn":46},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":1,"message":"Unsafe assignment of an `any` value.","line":72,"column":9,"nodeType":"Property","messageId":"anyAssignment","endLine":72,"endColumn":38},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .keywords on an `any` value.","line":72,"column":30,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":72,"endColumn":38},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":1,"message":"Unsafe assignment of an `any` value.","line":73,"column":9,"nodeType":"Property","messageId":"anyAssignment","endLine":73,"endColumn":46},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .featureFlags on an `any` value.","line":73,"column":34,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":73,"endColumn":46},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":1,"message":"Unsafe assignment of an `any` value.","line":74,"column":9,"nodeType":"Property","messageId":"anyAssignment","endLine":74,"endColumn":44},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .permissions on an `any` value.","line":74,"column":33,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":74,"endColumn":44},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":1,"message":"Unsafe assignment of an `any` value.","line":75,"column":9,"nodeType":"Property","messageId":"anyAssignment","endLine":75,"endColumn":53},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected any value in conditional. An explicit comparison or type conversion is required.","line":75,"column":22,"nodeType":"MemberExpression","messageId":"conditionErrorAny","endLine":75,"endColumn":44,"suggestions":[{"messageId":"conditionFixCastBoolean","fix":{"range":[3005,3027],"text":"(Boolean(cmdOptions.interactive))"},"desc":"Explicitly convert value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .interactive on an `any` value.","line":75,"column":33,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":75,"endColumn":44},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":1,"message":"Unsafe assignment of an `any` value.","line":76,"column":9,"nodeType":"Property","messageId":"anyAssignment","endLine":76,"endColumn":42},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected any value in conditional. An explicit comparison or type conversion is required.","line":76,"column":15,"nodeType":"MemberExpression","messageId":"conditionErrorAny","endLine":76,"endColumn":33,"suggestions":[{"messageId":"conditionFixCastBoolean","fix":{"range":[3052,3070],"text":"(Boolean(globalOptions.json))"},"desc":"Explicitly convert value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":1,"message":"Unsafe assignment of an `any` value.","line":77,"column":9,"nodeType":"Property","messageId":"anyAssignment","endLine":77,"endColumn":43},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected any value in conditional. An explicit comparison or type conversion is required.","line":77,"column":17,"nodeType":"MemberExpression","messageId":"conditionErrorAny","endLine":77,"endColumn":34,"suggestions":[{"messageId":"conditionFixCastBoolean","fix":{"range":[3097,3114],"text":"(Boolean(cmdOptions.strict))"},"desc":"Explicitly convert value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .strict on an `any` value.","line":77,"column":28,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":77,"endColumn":34},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":1,"message":"Unsafe assignment of an `any` value.","line":78,"column":9,"nodeType":"Property","messageId":"anyAssignment","endLine":78,"endColumn":53},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected any value in conditional. An explicit comparison or type conversion is required.","line":78,"column":22,"nodeType":"MemberExpression","messageId":"conditionErrorAny","endLine":78,"endColumn":44,"suggestions":[{"messageId":"conditionFixCastBoolean","fix":{"range":[3146,3168],"text":"(Boolean(cmdOptions.noSubstring))"},"desc":"Explicitly convert value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .noSubstring on an `any` value.","line":78,"column":33,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":78,"endColumn":44},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":1,"message":"Unsafe assignment of an `any` value.","line":98,"column":9,"nodeType":"Property","messageId":"anyAssignment","endLine":98,"endColumn":47},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected any value in conditional. An explicit comparison or type conversion is required.","line":98,"column":21,"nodeType":"MemberExpression","messageId":"conditionErrorAny","endLine":98,"endColumn":42,"suggestions":[{"messageId":"conditionFixCastBoolean","fix":{"range":[3866,3887],"text":"(Boolean(cmdOptions.foldRadius))"},"desc":"Explicitly convert value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .foldRadius on an `any` value.","line":98,"column":32,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":98,"endColumn":42},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":1,"message":"Unsafe assignment of an `any` value.","line":99,"column":9,"nodeType":"Property","messageId":"anyAssignment","endLine":99,"endColumn":51},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected any value in conditional. An explicit comparison or type conversion is required.","line":99,"column":21,"nodeType":"MemberExpression","messageId":"conditionErrorAny","endLine":99,"endColumn":42,"suggestions":[{"messageId":"conditionFixCastBoolean","fix":{"range":[3914,3935],"text":"(Boolean(cmdOptions.autoRadius))"},"desc":"Explicitly convert value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .autoRadius on an `any` value.","line":99,"column":32,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":99,"endColumn":42},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":1,"message":"Unsafe assignment of an `any` value.","line":100,"column":9,"nodeType":"Property","messageId":"anyAssignment","endLine":100,"endColumn":40},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .maxTokens on an `any` value.","line":100,"column":31,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":100,"endColumn":40},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":1,"message":"Unsafe assignment of an `any` value.","line":101,"column":9,"nodeType":"Property","messageId":"anyAssignment","endLine":101,"endColumn":55},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected any value in conditional. An explicit comparison or type conversion is required.","line":101,"column":25,"nodeType":"MemberExpression","messageId":"conditionErrorAny","endLine":101,"endColumn":46,"suggestions":[{"messageId":"conditionFixCastBoolean","fix":{"range":[4011,4032],"text":"(Boolean(cmdOptions.cacheStats))"},"desc":"Explicitly convert value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .cacheStats on an `any` value.","line":101,"column":36,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":101,"endColumn":46},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":1,"message":"Unsafe assignment of an `any` value.","line":102,"column":9,"nodeType":"Property","messageId":"anyAssignment","endLine":102,"endColumn":42},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected any value in conditional. An explicit comparison or type conversion is required.","line":102,"column":15,"nodeType":"MemberExpression","messageId":"conditionErrorAny","endLine":102,"endColumn":33,"suggestions":[{"messageId":"conditionFixCastBoolean","fix":{"range":[4057,4075],"text":"(Boolean(globalOptions.json))"},"desc":"Explicitly convert value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable boolean value in conditional. Please handle the nullish case explicitly.","line":106,"column":11,"nodeType":"MemberExpression","messageId":"conditionErrorNullableBoolean","endLine":106,"endColumn":29,"suggestions":[{"messageId":"conditionFixDefaultFalse","fix":{"range":[4144,4162],"text":"(options.autoRadius ?? false)"},"desc":"Explicitly treat nullish value the same as false (`value ?? false`)"},{"messageId":"conditionFixCompareTrue","fix":{"range":[4144,4162],"text":"(options.autoRadius === true)"},"desc":"Change condition to check if true (`value === true`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.","line":106,"column":34,"nodeType":"MemberExpression","messageId":"conditionErrorNullableNumber","endLine":106,"endColumn":51,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[4166,4184],"text":"(options.maxTokens == null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultZero","fix":{"range":[4167,4184],"text":"(options.maxTokens ?? 0)"},"desc":"Explicitly treat nullish value the same as 0 (`value ?? 0`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[4166,4184],"text":"(!Boolean(options.maxTokens))"},"desc":"Explicitly convert value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":1,"message":"Unsafe assignment of an `any` value.","line":122,"column":9,"nodeType":"Property","messageId":"anyAssignment","endLine":122,"endColumn":34},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .ticket on an `any` value.","line":122,"column":28,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":122,"endColumn":34},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":1,"message":"Unsafe assignment of an `any` value.","line":123,"column":9,"nodeType":"Property","messageId":"anyAssignment","endLine":123,"endColumn":42},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected any value in conditional. An explicit comparison or type conversion is required.","line":123,"column":15,"nodeType":"MemberExpression","messageId":"conditionErrorAny","endLine":123,"endColumn":33,"suggestions":[{"messageId":"conditionFixCastBoolean","fix":{"range":[4736,4754],"text":"(Boolean(globalOptions.json))"},"desc":"Explicitly convert value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":1,"message":"Unsafe assignment of an `any` value.","line":139,"column":9,"nodeType":"Property","messageId":"anyAssignment","endLine":139,"endColumn":32},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .since on an `any` value.","line":139,"column":27,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":139,"endColumn":32},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":1,"message":"Unsafe assignment of an `any` value.","line":140,"column":9,"nodeType":"Property","messageId":"anyAssignment","endLine":140,"endColumn":32},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .until on an `any` value.","line":140,"column":27,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":140,"endColumn":32},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":1,"message":"Unsafe assignment of an `any` value.","line":141,"column":9,"nodeType":"Property","messageId":"anyAssignment","endLine":141,"endColumn":34},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .format on an `any` value.","line":141,"column":28,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":141,"endColumn":34},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":1,"message":"Unsafe assignment of an `any` value.","line":142,"column":9,"nodeType":"Property","messageId":"anyAssignment","endLine":142,"endColumn":34},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .output on an `any` value.","line":142,"column":28,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":142,"endColumn":34},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":1,"message":"Unsafe assignment of an `any` value.","line":143,"column":9,"nodeType":"Property","messageId":"anyAssignment","endLine":143,"endColumn":42},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected any value in conditional. An explicit comparison or type conversion is required.","line":143,"column":15,"nodeType":"MemberExpression","messageId":"conditionErrorAny","endLine":143,"endColumn":33,"suggestions":[{"messageId":"conditionFixCastBoolean","fix":{"range":[5612,5630],"text":"(Boolean(globalOptions.json))"},"desc":"Explicitly convert value to a boolean (`Boolean(value)`)"}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":65,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * CLI Entry Point - Command Routing and Global Flags\n *\n * Routes commands to appropriate handlers and handles global flags.\n */\n\nimport { Command } from \"commander\";\nimport { remember, type RememberOptions } from \"./remember.js\";\nimport { recall, type RecallOptions } from \"./recall.js\";\nimport { check, type CheckOptions } from \"./check.js\";\nimport { timeline, type TimelineCommandOptions } from \"./timeline.js\";\nimport { readFileSync } from \"fs\";\nimport { join, dirname } from \"path\";\nimport { fileURLToPath } from \"url\";\n\nconst __filename = fileURLToPath(import.meta.url);\nconst __dirname = dirname(__filename);\n\n// Read version from package.json\nfunction getVersion(): string {\n  try {\n    // From dist/shared/cli/index.js, package.json is at ../../../package.json (root)\n    const packagePath = join(__dirname, \"..\", \"..\", \"..\", \"package.json\");\n    const packageJson = JSON.parse(readFileSync(packagePath, \"utf-8\"));\n    return packageJson.version;\n  } catch {\n    return \"0.2.0\";\n  }\n}\n\n/**\n * Create and configure the CLI program\n */\nexport function createProgram(): Command {\n  const program = new Command();\n\n  program\n    .name(\"lex\")\n    .description(\"Policy-aware work continuity with receipts\")\n    .version(getVersion())\n    .option(\"--json\", \"Output results in JSON format\");\n\n  // lex remember command\n  program\n    .command(\"remember\")\n    .description(\"Capture a work session Frame\")\n    .option(\"--jira <ticket>\", \"Jira ticket ID\")\n    .option(\"--reference-point <phrase>\", \"Human-memorable anchor phrase\")\n    .option(\"--summary <text>\", \"One-line summary\")\n    .option(\"--next <action>\", \"Next action to take\")\n    .option(\"--modules <list>\", \"Comma-separated module IDs\", parseList)\n    .option(\"--blockers <list>\", \"Comma-separated blockers\", parseList)\n    .option(\"--merge-blockers <list>\", \"Comma-separated merge blockers\", parseList)\n    .option(\"--tests-failing <list>\", \"Comma-separated test names\", parseList)\n    .option(\"--keywords <list>\", \"Comma-separated keywords\", parseList)\n    .option(\"--feature-flags <list>\", \"Comma-separated feature flags\", parseList)\n    .option(\"--permissions <list>\", \"Comma-separated permissions\", parseList)\n    .option(\"-i, --interactive\", \"Interactive mode (prompt for all fields)\")\n    .option(\"--strict\", \"Disable auto-correction for typos (for CI)\")\n    .option(\"--no-substring\", \"Disable substring matching for module IDs (for CI)\")\n    .action(async (cmdOptions) => {\n      const globalOptions = program.opts();\n      const options: RememberOptions = {\n        jira: cmdOptions.jira,\n        referencePoint: cmdOptions.referencePoint,\n        summary: cmdOptions.summary,\n        next: cmdOptions.next,\n        modules: cmdOptions.modules,\n        blockers: cmdOptions.blockers,\n        mergeBlockers: cmdOptions.mergeBlockers,\n        testsFailing: cmdOptions.testsFailing,\n        keywords: cmdOptions.keywords,\n        featureFlags: cmdOptions.featureFlags,\n        permissions: cmdOptions.permissions,\n        interactive: cmdOptions.interactive || false,\n        json: globalOptions.json || false,\n        strict: cmdOptions.strict || false,\n        noSubstring: cmdOptions.noSubstring || false,\n      };\n      await remember(options);\n    });\n\n  // lex recall command\n  program\n    .command(\"recall <query>\")\n    .description(\"Retrieve a Frame by reference point, ticket ID, or Frame ID\")\n    .option(\"--fold-radius <number>\", \"Fold radius for Atlas Frame neighborhood\", parseInt)\n    .option(\"--auto-radius\", \"Auto-tune radius based on token limits\")\n    .option(\n      \"--max-tokens <number>\",\n      \"Maximum tokens for Atlas Frame (use with --auto-radius)\",\n      parseInt\n    )\n    .option(\"--cache-stats\", \"Show cache statistics\")\n    .action(async (query, cmdOptions) => {\n      const globalOptions = program.opts();\n      const options: RecallOptions = {\n        foldRadius: cmdOptions.foldRadius || 1,\n        autoRadius: cmdOptions.autoRadius || false,\n        maxTokens: cmdOptions.maxTokens,\n        showCacheStats: cmdOptions.cacheStats || false,\n        json: globalOptions.json || false,\n      };\n\n      // Validate auto-radius options\n      if (options.autoRadius && !options.maxTokens) {\n        console.error(\"Error: --auto-radius requires --max-tokens to be specified\");\n        process.exit(1);\n      }\n\n      await recall(query, options);\n    });\n\n  // lex check command\n  program\n    .command(\"check <merged-json> <policy-json>\")\n    .description(\"Enforce policy against scanned code\")\n    .option(\"--ticket <id>\", \"Ticket ID for context\")\n    .action(async (mergedJson, policyJson, cmdOptions) => {\n      const globalOptions = program.opts();\n      const options: CheckOptions = {\n        ticket: cmdOptions.ticket,\n        json: globalOptions.json || false,\n      };\n      await check(mergedJson, policyJson, options);\n    });\n\n  // lex timeline command\n  program\n    .command(\"timeline <ticket-or-branch>\")\n    .description(\"Show visual timeline of Frame evolution for a ticket or branch\")\n    .option(\"--since <date>\", \"Filter frames since this date (ISO 8601)\")\n    .option(\"--until <date>\", \"Filter frames until this date (ISO 8601)\")\n    .option(\"--format <type>\", \"Output format: text, json, or html\", /^(text|json|html)$/, \"text\")\n    .option(\"--output <file>\", \"Write output to file instead of stdout\")\n    .action(async (ticketOrBranch, cmdOptions) => {\n      const globalOptions = program.opts();\n      const options: TimelineCommandOptions = {\n        since: cmdOptions.since,\n        until: cmdOptions.until,\n        format: cmdOptions.format,\n        output: cmdOptions.output,\n        json: globalOptions.json || false,\n      };\n      await timeline(ticketOrBranch, options);\n    });\n\n  return program;\n}\n\n/**\n * Parse comma-separated list\n */\nfunction parseList(value: string): string[] | undefined {\n  if (!value || !value.trim()) {\n    return undefined;\n  }\n  return value\n    .split(\",\")\n    .map((item) => item.trim())\n    .filter((item) => item.length > 0);\n}\n\n/**\n * Run the CLI program\n */\nexport async function run(argv: string[] = process.argv): Promise<void> {\n  const program = createProgram();\n  await program.parseAsync(argv);\n}\n","usedDeprecatedRules":[]},{"filePath":"/srv/lex-mcp/lex/src/shared/cli/lex.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/srv/lex-mcp/lex/src/shared/cli/recall.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'generateAtlasFrame' is defined but never used. Allowed unused vars must match /^_/u.","line":11,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":11,"endColumn":21},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":56,"column":11,"nodeType":"Identifier","messageId":"conditionErrorNullableString","endLine":56,"endColumn":21,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[1575,1585],"text":"searchHint != null"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[1575,1585],"text":"searchHint ?? \"\""},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[1575,1585],"text":"Boolean(searchHint)"},"desc":"Explicitly convert value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable boolean value in conditional. Please handle the nullish case explicitly.","line":64,"column":9,"nodeType":"MemberExpression","messageId":"conditionErrorNullableBoolean","endLine":64,"endColumn":21,"suggestions":[{"messageId":"conditionFixDefaultFalse","fix":{"range":[1770,1782],"text":"options.json ?? false"},"desc":"Explicitly treat nullish value the same as false (`value ?? false`)"},{"messageId":"conditionFixCompareTrue","fix":{"range":[1770,1782],"text":"options.json === true"},"desc":"Change condition to check if true (`value === true`)"}]},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":1,"message":"Unsafe assignment of an `any` value.","line":71,"column":11,"nodeType":"Property","messageId":"anyAssignment","endLine":71,"endColumn":45},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable boolean value in conditional. Please handle the nullish case explicitly.","line":88,"column":11,"nodeType":"MemberExpression","messageId":"conditionErrorNullableBoolean","endLine":88,"endColumn":33,"suggestions":[{"messageId":"conditionFixDefaultFalse","fix":{"range":[2560,2582],"text":"options.showCacheStats ?? false"},"desc":"Explicitly treat nullish value the same as false (`value ?? false`)"},{"messageId":"conditionFixCompareTrue","fix":{"range":[2560,2582],"text":"options.showCacheStats === true"},"desc":"Change condition to check if true (`value === true`)"}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":101,"column":19,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":101,"endColumn":22,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3100,3103],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3100,3103],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .message on an `any` value.","line":102,"column":39,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":102,"endColumn":46},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":111,"column":30,"nodeType":"MemberExpression","messageId":"conditionErrorNullableString","endLine":111,"endColumn":40,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[3351,3361],"text":"(frame.jira != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[3351,3361],"text":"(frame.jira ?? \"\")"},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[3351,3361],"text":"(Boolean(frame.jira))"},"desc":"Explicitly convert value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":1,"message":"Unsafe assignment of an `any` value.","line":153,"column":9,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":153,"endColumn":44},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected any value in conditional. An explicit comparison or type conversion is required.","line":162,"column":7,"nodeType":"Identifier","messageId":"conditionErrorAny","endLine":162,"endColumn":17,"suggestions":[{"messageId":"conditionFixCastBoolean","fix":{"range":[5156,5166],"text":"Boolean(atlasFrame)"},"desc":"Explicitly convert value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .modules on an `any` value.","line":163,"column":50,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":163,"endColumn":57},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .modules on an `any` value.","line":166,"column":37,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":166,"endColumn":44},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .id on an `any` value.","line":167,"column":36,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":167,"endColumn":38},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected any value in conditional. An explicit comparison or type conversion is required.","line":171,"column":9,"nodeType":"MemberExpression","messageId":"conditionErrorAny","endLine":171,"endColumn":25,"suggestions":[{"messageId":"conditionFixCastBoolean","fix":{"range":[5434,5450],"text":"(Boolean(atlasFrame.edges))"},"desc":"Explicitly convert value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .edges on an `any` value.","line":171,"column":20,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":171,"endColumn":25},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .edges on an `any` value.","line":171,"column":40,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":171,"endColumn":45},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .edges on an `any` value.","line":172,"column":45,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":172,"endColumn":50},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":1,"message":"Unsafe call of a(n) `any` typed value.","line":173,"column":26,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":173,"endColumn":48},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .edges on an `any` value.","line":173,"column":37,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":173,"endColumn":42},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .reason on an `any` value.","line":175,"column":29,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":175,"endColumn":35},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .from on an `any` value.","line":176,"column":44,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":176,"endColumn":48},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .to on an `any` value.","line":176,"column":59,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":176,"endColumn":61},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .reason on an `any` value.","line":176,"column":71,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":176,"endColumn":77},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .edges on an `any` value.","line":178,"column":22,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":178,"endColumn":27},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .edges on an `any` value.","line":179,"column":48,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":179,"endColumn":53},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable boolean value in conditional. Please handle the nullish case explicitly.","line":184,"column":9,"nodeType":"MemberExpression","messageId":"conditionErrorNullableBoolean","endLine":184,"endColumn":27,"suggestions":[{"messageId":"conditionFixDefaultFalse","fix":{"range":[5949,5967],"text":"(options.autoRadius ?? false)"},"desc":"Explicitly treat nullish value the same as false (`value ?? false`)"},{"messageId":"conditionFixCompareTrue","fix":{"range":[5949,5967],"text":"(options.autoRadius === true)"},"desc":"Change condition to check if true (`value === true`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.","line":184,"column":31,"nodeType":"MemberExpression","messageId":"conditionErrorNullableNumber","endLine":184,"endColumn":48,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[5971,5988],"text":"(options.maxTokens != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultZero","fix":{"range":[5971,5988],"text":"(options.maxTokens ?? 0)"},"desc":"Explicitly treat nullish value the same as 0 (`value ?? 0`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[5971,5988],"text":"(Boolean(options.maxTokens))"},"desc":"Explicitly convert value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":199,"column":15,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":199,"endColumn":18,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6269,6272],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6269,6272],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":1,"message":"Unsafe assignment of an error typed value.","line":206,"column":11,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":206,"endColumn":32},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.","line":213,"column":26,"nodeType":"MemberExpression","messageId":"conditionErrorNullableNumber","endLine":213,"endColumn":44,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[6596,6614],"text":"(options.foldRadius != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultZero","fix":{"range":[6596,6614],"text":"(options.foldRadius ?? 0)"},"desc":"Explicitly treat nullish value the same as 0 (`value ?? 0`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[6596,6614],"text":"(Boolean(options.foldRadius))"},"desc":"Explicitly convert value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.","line":219,"column":29,"nodeType":"MemberExpression","messageId":"conditionErrorNullableNumber","endLine":219,"endColumn":47,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[6710,6728],"text":"(options.foldRadius != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultZero","fix":{"range":[6710,6728],"text":"(options.foldRadius ?? 0)"},"desc":"Explicitly treat nullish value the same as 0 (`value ?? 0`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[6710,6728],"text":"(Boolean(options.foldRadius))"},"desc":"Explicitly convert value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable boolean value in conditional. Please handle the nullish case explicitly.","line":222,"column":9,"nodeType":"MemberExpression","messageId":"conditionErrorNullableBoolean","endLine":222,"endColumn":27,"suggestions":[{"messageId":"conditionFixDefaultFalse","fix":{"range":[6779,6797],"text":"(options.autoRadius ?? false)"},"desc":"Explicitly treat nullish value the same as false (`value ?? false`)"},{"messageId":"conditionFixCompareTrue","fix":{"range":[6779,6797],"text":"(options.autoRadius === true)"},"desc":"Change condition to check if true (`value === true`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.","line":222,"column":31,"nodeType":"MemberExpression","messageId":"conditionErrorNullableNumber","endLine":222,"endColumn":48,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[6801,6818],"text":"(options.maxTokens != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultZero","fix":{"range":[6801,6818],"text":"(options.maxTokens ?? 0)"},"desc":"Explicitly treat nullish value the same as 0 (`value ?? 0`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[6801,6818],"text":"(Boolean(options.maxTokens))"},"desc":"Explicitly convert value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable boolean value in conditional. Please handle the nullish case explicitly.","line":229,"column":16,"nodeType":"MemberExpression","messageId":"conditionErrorNullableBoolean","endLine":229,"endColumn":28,"suggestions":[{"messageId":"conditionFixDefaultFalse","fix":{"range":[7108,7120],"text":"(options.json ?? false)"},"desc":"Explicitly treat nullish value the same as false (`value ?? false`)"},{"messageId":"conditionFixCompareFalse","fix":{"range":[7107,7120],"text":"options.json === false"},"desc":"Change condition to check if false (`value === false`)"}]},{"ruleId":"@typescript-eslint/restrict-template-expressions","severity":1,"message":"Invalid type \"unknown\" of template literal expression.","line":259,"column":65,"nodeType":"Identifier","messageId":"invalidType","endLine":259,"endColumn":70},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.","line":263,"column":24,"nodeType":"MemberExpression","messageId":"conditionErrorNullableNumber","endLine":263,"endColumn":42,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[8091,8109],"text":"(options.foldRadius != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultZero","fix":{"range":[8091,8109],"text":"(options.foldRadius ?? 0)"},"desc":"Explicitly treat nullish value the same as 0 (`value ?? 0`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[8091,8109],"text":"(Boolean(options.foldRadius))"},"desc":"Explicitly convert value to a boolean (`Boolean(value)`)"}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":36,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * CLI Command: lex recall\n *\n * Searches Frames via query, returns Frame + Atlas Frame with pretty output.\n */\n\nimport type { Frame } from \"../types/frame.js\";\nimport { getDb, searchFrames, getFramesByJira, getFrameById } from \"../../memory/store/index.js\";\nimport { loadPolicy } from \"../policy/loader.js\";\nimport {\n  generateAtlasFrame,\n  computeFoldRadius,\n  autoTuneRadius,\n  estimateTokens,\n  getCacheStats,\n} from \"../atlas/index.js\";\n\nexport interface RecallOptions {\n  json?: boolean;\n  foldRadius?: number;\n  autoRadius?: boolean;\n  maxTokens?: number;\n  showCacheStats?: boolean;\n}\n\n/**\n * Execute the 'lex recall' command\n * Searches for Frames and displays results with Atlas Frame context\n */\nexport async function recall(query: string, options: RecallOptions = {}): Promise<void> {\n  try {\n    const db = getDb();\n    let frames: Frame[] = [];\n    let searchHint: string | undefined;\n\n    // Try different search strategies\n    // 1. Try as Frame ID (exact match)\n    const frameById = getFrameById(db, query);\n    if (frameById) {\n      frames = [frameById];\n    } else {\n      // 2. Try as Jira ticket (exact match)\n      const framesByJira = getFramesByJira(db, query);\n      if (framesByJira.length > 0) {\n        frames = framesByJira;\n      } else {\n        // 3. Try as reference point (fuzzy search)\n        const searchResult = searchFrames(db, query);\n        frames = searchResult.frames;\n        searchHint = searchResult.hint;\n      }\n    }\n\n    if (frames.length === 0) {\n      // Print hint to stderr if FTS5 syntax error occurred\n      if (searchHint) {\n        console.error(`\\n⚠️  ${searchHint}\\n`);\n      }\n      console.log(`\\n❌ No frames found matching: \"${query}\"\\n`);\n      process.exit(1);\n    }\n\n    // Output results\n    if (options.json) {\n      // JSON output includes frames and their Atlas Frames\n      const results = [];\n      for (const frame of frames) {\n        const atlasResult = await generateAtlasFrameWithAutoTune(frame, options);\n        results.push({\n          frame,\n          atlasFrame: atlasResult.atlasFrame,\n          foldRadius: atlasResult.actualRadius,\n          autoTuned: atlasResult.autoTuned,\n          tokens: atlasResult.tokens,\n        });\n      }\n      console.log(JSON.stringify(results, null, 2));\n    } else {\n      // Pretty print results\n      for (let i = 0; i < frames.length; i++) {\n        if (i > 0) {\n          console.log(\"\\n\" + \"─\".repeat(80) + \"\\n\");\n        }\n        await displayFrame(frames[i], options);\n      }\n\n      // Show cache stats if requested\n      if (options.showCacheStats) {\n        const stats = getCacheStats();\n        const total = stats.hits + stats.misses;\n        const hitRate = total === 0 ? 0 : (stats.hits / total) * 100;\n\n        console.log(`\\n📊 Cache Statistics:`);\n        console.log(`   Hits: ${stats.hits}`);\n        console.log(`   Misses: ${stats.misses}`);\n        console.log(`   Hit Rate: ${hitRate.toFixed(1)}%`);\n        console.log(`   Cache Size: ${stats.size} entries`);\n        console.log(`   Evictions: ${stats.evictions}`);\n      }\n    }\n  } catch (error: any) {\n    console.error(`\\n❌ Error: ${error.message}\\n`);\n    process.exit(2);\n  }\n}\n\n/**\n * Display a Frame with Atlas Frame context\n */\nasync function displayFrame(frame: Frame, options: RecallOptions): Promise<void> {\n  console.log(`\\n📋 Frame: ${frame.jira || frame.id}`);\n  console.log(`   Timestamp: ${new Date(frame.timestamp).toLocaleString()}`);\n  console.log(`   Branch: ${frame.branch}`);\n  console.log(`\\n   Reference: \"${frame.reference_point}\"`);\n  console.log(`\\n   Summary: ${frame.summary_caption}`);\n\n  console.log(`\\n   Next action: ${frame.status_snapshot.next_action}`);\n\n  if (frame.status_snapshot.blockers && frame.status_snapshot.blockers.length > 0) {\n    console.log(`\\n   Blockers:`);\n    for (const blocker of frame.status_snapshot.blockers) {\n      console.log(`     • ${blocker}`);\n    }\n  }\n\n  if (frame.status_snapshot.merge_blockers && frame.status_snapshot.merge_blockers.length > 0) {\n    console.log(`\\n   Merge blockers:`);\n    for (const blocker of frame.status_snapshot.merge_blockers) {\n      console.log(`     • ${blocker}`);\n    }\n  }\n\n  if (frame.status_snapshot.tests_failing && frame.status_snapshot.tests_failing.length > 0) {\n    console.log(`\\n   Tests failing:`);\n    for (const test of frame.status_snapshot.tests_failing) {\n      console.log(`     • ${test}`);\n    }\n  }\n\n  if (frame.keywords && frame.keywords.length > 0) {\n    console.log(`\\n   Keywords: ${frame.keywords.join(\", \")}`);\n  }\n\n  // Generate Atlas Frame with auto-tuning if enabled\n  const atlasResult = await generateAtlasFrameWithAutoTune(frame, options);\n\n  if (atlasResult.autoTuned) {\n    console.log(\n      `\\n⚙️  Auto-tuned radius: ${atlasResult.requestedRadius} → ${atlasResult.actualRadius} (${atlasResult.tokens} tokens)`\n    );\n  }\n\n  const atlasFrame = atlasResult.atlasFrame;\n  const foldRadius = atlasResult.actualRadius;\n\n  console.log(`\\n🗺️  Atlas Frame (fold radius ${foldRadius}):`);\n  console.log(`\\n   Modules in scope:`);\n  for (const module of frame.module_scope) {\n    console.log(`     • ${module}`);\n  }\n\n  if (atlasFrame) {\n    console.log(`\\n   Neighborhood (${atlasFrame.modules.length} modules within radius):`);\n\n    // Just list all modules in the atlas\n    for (const module of atlasFrame.modules) {\n      console.log(`     • ${module.id}`);\n    }\n\n    // Show edges if any\n    if (atlasFrame.edges && atlasFrame.edges.length > 0) {\n      console.log(`\\n   Edges (${atlasFrame.edges.length}):`);\n      for (const edge of atlasFrame.edges.slice(0, 5)) {\n        // Show max 5 edges\n        const symbol = edge.reason === \"allowed\" ? \"✓\" : \"✗\";\n        console.log(`     ${symbol} ${edge.from} → ${edge.to} (${edge.reason})`);\n      }\n      if (atlasFrame.edges.length > 5) {\n        console.log(`     ... and ${atlasFrame.edges.length - 5} more`);\n      }\n    }\n\n    // Show token estimate\n    if (options.autoRadius || options.maxTokens) {\n      console.log(`\\n   Token estimate: ${atlasResult.tokens} tokens`);\n    }\n  }\n\n  console.log(\"\");\n}\n\n/**\n * Generate Atlas Frame with auto-tuning support\n */\nasync function generateAtlasFrameWithAutoTune(\n  frame: Frame,\n  options: RecallOptions\n): Promise<{\n  atlasFrame: any;\n  actualRadius: number;\n  requestedRadius: number;\n  tokens: number;\n  autoTuned: boolean;\n}> {\n  try {\n    const policy = loadPolicy();\n\n    // For now, use all modules in scope as seeds\n    if (frame.module_scope.length === 0) {\n      return {\n        atlasFrame: null,\n        actualRadius: 0,\n        requestedRadius: options.foldRadius || 1,\n        tokens: 0,\n        autoTuned: false,\n      };\n    }\n\n    const requestedRadius = options.foldRadius || 1;\n\n    // Auto-tune radius if enabled\n    if (options.autoRadius && options.maxTokens) {\n      const result = autoTuneRadius(\n        (radius) => computeFoldRadius(frame.module_scope, radius, policy),\n        requestedRadius,\n        options.maxTokens,\n        (oldRadius, newRadius, tokens, limit) => {\n          // Only log adjustments when not in JSON mode\n          if (!options.json) {\n            console.log(\n              `\\n⚙️  Auto-tuning: radius ${oldRadius} → ${newRadius} (${tokens} tokens exceeded ${limit} limit)`\n            );\n          }\n        }\n      );\n\n      return {\n        atlasFrame: result.atlasFrame,\n        actualRadius: result.radiusUsed,\n        requestedRadius,\n        tokens: result.tokensUsed,\n        autoTuned: result.radiusUsed !== requestedRadius,\n      };\n    }\n\n    // Normal generation without auto-tuning\n    const atlasFrame = computeFoldRadius(frame.module_scope, requestedRadius, policy);\n    const tokens = estimateTokens(atlasFrame);\n\n    return {\n      atlasFrame,\n      actualRadius: requestedRadius,\n      requestedRadius,\n      tokens,\n      autoTuned: false,\n    };\n  } catch (error) {\n    // If Atlas Frame generation fails, continue without it\n    console.warn(`   Warning: Could not generate Atlas Frame: ${error}`);\n    return {\n      atlasFrame: null,\n      actualRadius: 0,\n      requestedRadius: options.foldRadius || 1,\n      tokens: 0,\n      autoTuned: false,\n    };\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/srv/lex-mcp/lex/src/shared/cli/remember.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'ResolutionResult' is defined but never used. Allowed unused vars must match /^_/u.","line":11,"column":15,"nodeType":null,"messageId":"unusedVar","endLine":11,"endColumn":31},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable boolean value in conditional. Please handle the nullish case explicitly.","line":45,"column":7,"nodeType":"MemberExpression","messageId":"conditionErrorNullableBoolean","endLine":45,"endColumn":26,"suggestions":[{"messageId":"conditionFixDefaultFalse","fix":{"range":[1255,1274],"text":"(options.interactive ?? false)"},"desc":"Explicitly treat nullish value the same as false (`value ?? false`)"},{"messageId":"conditionFixCompareTrue","fix":{"range":[1255,1274],"text":"(options.interactive === true)"},"desc":"Change condition to check if true (`value === true`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":45,"column":31,"nodeType":"MemberExpression","messageId":"conditionErrorNullableString","endLine":45,"endColumn":46,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[1278,1294],"text":"(options.summary == null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[1279,1294],"text":"(options.summary ?? \"\")"},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[1278,1294],"text":"(!Boolean(options.summary))"},"desc":"Explicitly convert value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":45,"column":51,"nodeType":"MemberExpression","messageId":"conditionErrorNullableString","endLine":45,"endColumn":63,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[1298,1311],"text":"(options.next == null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[1299,1311],"text":"(options.next ?? \"\")"},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[1298,1311],"text":"(!Boolean(options.next))"},"desc":"Explicitly convert value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":1,"message":"Unsafe assignment of an error typed value.","line":50,"column":11,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":50,"endColumn":32},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":70,"column":24,"nodeType":"MemberExpression","messageId":"conditionErrorNullableString","endLine":70,"endColumn":39,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[2249,2264],"text":"(answers.summary != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[2249,2264],"text":"(answers.summary ?? \"\")"},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[2249,2264],"text":"(Boolean(answers.summary))"},"desc":"Explicitly convert value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":71,"column":24,"nodeType":"MemberExpression","messageId":"conditionErrorNullableString","endLine":71,"endColumn":46,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[2295,2317],"text":"(answers.referencePoint != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[2295,2317],"text":"(answers.referencePoint ?? \"\")"},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[2295,2317],"text":"(Boolean(answers.referencePoint))"},"desc":"Explicitly convert value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":73,"column":22,"nodeType":"MemberExpression","messageId":"conditionErrorNullableString","endLine":73,"endColumn":34,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[2371,2383],"text":"(answers.next != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[2371,2383],"text":"(answers.next ?? \"\")"},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[2371,2383],"text":"(Boolean(answers.next))"},"desc":"Explicitly convert value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable boolean value in conditional. Please handle the nullish case explicitly.","line":89,"column":9,"nodeType":"MemberExpression","messageId":"conditionErrorNullableBoolean","endLine":89,"endColumn":21,"suggestions":[{"messageId":"conditionFixDefaultFalse","fix":{"range":[2789,2801],"text":"options.json ?? false"},"desc":"Explicitly treat nullish value the same as false (`value ?? false`)"},{"messageId":"conditionFixCompareTrue","fix":{"range":[2789,2801],"text":"options.json === true"},"desc":"Change condition to check if true (`value === true`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":96,"column":11,"nodeType":"MemberExpression","messageId":"conditionErrorNullableString","endLine":96,"endColumn":21,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[3116,3126],"text":"frame.jira != null"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[3116,3126],"text":"frame.jira ?? \"\""},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[3116,3126],"text":"Boolean(frame.jira)"},"desc":"Explicitly convert value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":102,"column":19,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":102,"endColumn":22,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3328,3331],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3328,3331],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .message on an `any` value.","line":103,"column":39,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":103,"endColumn":46},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'currentBranch' is defined but never used. Allowed unused args must match /^_/u.","line":113,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":113,"endColumn":16},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":115,"column":20,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":115,"endColumn":23,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3607,3610],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3607,3610],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":117,"column":8,"nodeType":"MemberExpression","messageId":"conditionErrorNullableString","endLine":117,"endColumn":20,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[3626,3639],"text":"options.jira == null"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[3627,3639],"text":"(options.jira ?? \"\")"},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[3626,3639],"text":"!Boolean(options.jira)"},"desc":"Explicitly convert value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":125,"column":8,"nodeType":"MemberExpression","messageId":"conditionErrorNullableString","endLine":125,"endColumn":30,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[3766,3789],"text":"options.referencePoint == null"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[3767,3789],"text":"(options.referencePoint ?? \"\")"},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[3766,3789],"text":"!Boolean(options.referencePoint)"},"desc":"Explicitly convert value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":134,"column":8,"nodeType":"MemberExpression","messageId":"conditionErrorNullableString","endLine":134,"endColumn":23,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[4031,4047],"text":"options.summary == null"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[4032,4047],"text":"(options.summary ?? \"\")"},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[4031,4047],"text":"!Boolean(options.summary)"},"desc":"Explicitly convert value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":143,"column":8,"nodeType":"MemberExpression","messageId":"conditionErrorNullableString","endLine":143,"endColumn":20,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[4270,4283],"text":"options.next == null"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[4271,4283],"text":"(options.next ?? \"\")"},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[4270,4283],"text":"!Boolean(options.next)"},"desc":"Explicitly convert value to a boolean (`Boolean(value)`)"}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":18,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * CLI Command: lex remember\n *\n * Prompts user for Frame metadata, validates module_scope, creates Frame.\n */\n\nimport inquirer from \"inquirer\";\nimport { v4 as uuidv4 } from \"uuid\";\nimport type { Frame } from \"../types/frame.js\";\nimport { validateModuleIds } from \"../module_ids/index.js\";\nimport type { ResolutionResult } from \"../types/validation.js\";\nimport { loadPolicy } from \"../policy/loader.js\";\nimport { getDb, saveFrame } from \"../../memory/store/index.js\";\nimport { getCurrentBranch } from \"../git/branch.js\";\n\nexport interface RememberOptions {\n  jira?: string;\n  referencePoint?: string;\n  summary?: string;\n  next?: string;\n  modules?: string[];\n  blockers?: string[];\n  mergeBlockers?: string[];\n  testsFailing?: string[];\n  keywords?: string[];\n  featureFlags?: string[];\n  permissions?: string[];\n  interactive?: boolean;\n  json?: boolean;\n  strict?: boolean;\n  noSubstring?: boolean;\n}\n\n/**\n * Execute the 'lex remember' command\n * Creates a new Frame with user input\n */\nexport async function remember(options: RememberOptions = {}): Promise<void> {\n  try {\n    // Get current git branch\n    const branch = await getCurrentBranch();\n\n    // If interactive mode or missing required fields, prompt for input\n    const answers =\n      options.interactive || !options.summary || !options.next || !options.modules\n        ? await promptForFrameData(options, branch)\n        : options;\n\n    // Resolve and validate module_scope against policy (THE CRITICAL RULE + auto-correction)\n    const policy = loadPolicy();\n\n    const validationResult = await validateModuleIds(answers.modules || [], policy);\n\n    if (!validationResult.valid) {\n      console.error(`\\n❌ Module validation failed:\\n`);\n      for (const error of validationResult.errors || []) {\n        console.error(`  - ${error.message}`);\n      }\n      console.error(\"\");\n      process.exit(1);\n    }\n\n    // Use canonical (resolved) module IDs from validation\n    const resolvedModules = validationResult.canonical || []; // Build Frame object\n    const frame: Frame = {\n      id: uuidv4(),\n      timestamp: new Date().toISOString(),\n      branch: branch,\n      module_scope: resolvedModules, // Use resolved (potentially auto-corrected) module IDs\n      summary_caption: answers.summary || \"\",\n      reference_point: answers.referencePoint || \"\",\n      status_snapshot: {\n        next_action: answers.next || \"\",\n        blockers: answers.blockers,\n        merge_blockers: answers.mergeBlockers,\n        tests_failing: answers.testsFailing,\n      },\n      jira: answers.jira,\n      keywords: answers.keywords,\n      feature_flags: answers.featureFlags,\n      permissions: answers.permissions,\n    };\n\n    // Save Frame to database\n    const db = getDb();\n    saveFrame(db, frame);\n\n    // Output result\n    if (options.json) {\n      console.log(JSON.stringify({ id: frame.id, timestamp: frame.timestamp }, null, 2));\n    } else {\n      console.log(\"\\n✅ Frame created successfully!\\n\");\n      console.log(`Frame ID: ${frame.id}`);\n      console.log(`Timestamp: ${frame.timestamp}`);\n      console.log(`Branch: ${frame.branch}`);\n      if (frame.jira) {\n        console.log(`Jira: ${frame.jira}`);\n      }\n      console.log(`Reference: ${frame.reference_point}`);\n      console.log(`Modules: ${frame.module_scope.join(\", \")}`);\n    }\n  } catch (error: any) {\n    console.error(`\\n❌ Error: ${error.message}\\n`);\n    process.exit(2);\n  }\n}\n\n/**\n * Prompt user for Frame metadata interactively\n */\nasync function promptForFrameData(\n  options: RememberOptions,\n  currentBranch: string\n): Promise<RememberOptions> {\n  const questions: any[] = [];\n\n  if (!options.jira) {\n    questions.push({\n      type: \"input\",\n      name: \"jira\",\n      message: \"Jira ticket (optional):\",\n    });\n  }\n\n  if (!options.referencePoint) {\n    questions.push({\n      type: \"input\",\n      name: \"referencePoint\",\n      message: \"Reference point (memorable phrase):\",\n      validate: (input: string) => input.trim().length > 0 || \"Reference point is required\",\n    });\n  }\n\n  if (!options.summary) {\n    questions.push({\n      type: \"input\",\n      name: \"summary\",\n      message: \"Summary (one-line description):\",\n      validate: (input: string) => input.trim().length > 0 || \"Summary is required\",\n    });\n  }\n\n  if (!options.next) {\n    questions.push({\n      type: \"input\",\n      name: \"next\",\n      message: \"Next action:\",\n      validate: (input: string) => input.trim().length > 0 || \"Next action is required\",\n    });\n  }\n\n  if (!options.modules) {\n    questions.push({\n      type: \"input\",\n      name: \"modules\",\n      message: \"Module scope (comma-separated):\",\n      filter: (input: string) =>\n        input\n          .split(\",\")\n          .map((m) => m.trim())\n          .filter((m) => m.length > 0),\n      validate: (input: string[]) => input.length > 0 || \"At least one module is required\",\n    });\n  }\n\n  if (!options.blockers) {\n    questions.push({\n      type: \"input\",\n      name: \"blockers\",\n      message: \"Blockers (comma-separated, optional):\",\n      filter: (input: string) => {\n        if (!input.trim()) return undefined;\n        return input\n          .split(\",\")\n          .map((b) => b.trim())\n          .filter((b) => b.length > 0);\n      },\n    });\n  }\n\n  if (!options.mergeBlockers) {\n    questions.push({\n      type: \"input\",\n      name: \"mergeBlockers\",\n      message: \"Merge blockers (comma-separated, optional):\",\n      filter: (input: string) => {\n        if (!input.trim()) return undefined;\n        return input\n          .split(\",\")\n          .map((b) => b.trim())\n          .filter((b) => b.length > 0);\n      },\n    });\n  }\n\n  const answers = questions.length > 0 ? await inquirer.prompt(questions) : {};\n\n  // Merge with provided options (provided options take precedence)\n  return {\n    ...answers,\n    ...options,\n  };\n}\n","usedDeprecatedRules":[]},{"filePath":"/srv/lex-mcp/lex/src/shared/cli/timeline.ts","messages":[{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":72,"column":9,"nodeType":"MemberExpression","messageId":"conditionErrorNullableString","endLine":72,"endColumn":22,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[1932,1945],"text":"options.since != null"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[1932,1945],"text":"options.since ?? \"\""},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[1932,1945],"text":"Boolean(options.since)"},"desc":"Explicitly convert value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":76,"column":9,"nodeType":"MemberExpression","messageId":"conditionErrorNullableString","endLine":76,"endColumn":22,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[2019,2032],"text":"options.until != null"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[2019,2032],"text":"options.until ?? \"\""},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[2019,2032],"text":"Boolean(options.until)"},"desc":"Explicitly convert value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable boolean value in conditional. Please handle the nullish case explicitly.","line":90,"column":39,"nodeType":"MemberExpression","messageId":"conditionErrorNullableBoolean","endLine":90,"endColumn":51,"suggestions":[{"messageId":"conditionFixDefaultFalse","fix":{"range":[2456,2468],"text":"(options.json ?? false)"},"desc":"Explicitly treat nullish value the same as false (`value ?? false`)"},{"messageId":"conditionFixCompareTrue","fix":{"range":[2456,2468],"text":"(options.json === true)"},"desc":"Change condition to check if true (`value === true`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":109,"column":9,"nodeType":"MemberExpression","messageId":"conditionErrorNullableString","endLine":109,"endColumn":23,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[2981,2995],"text":"options.output != null"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[2981,2995],"text":"options.output ?? \"\""},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[2981,2995],"text":"Boolean(options.output)"},"desc":"Explicitly convert value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":115,"column":19,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":115,"endColumn":22,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3184,3187],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3184,3187],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .message on an `any` value.","line":116,"column":39,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":116,"endColumn":46}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":6,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * CLI Command: lex timeline\n *\n * Display a visual timeline showing Frame evolution for a ticket or branch.\n */\n\nimport type { Frame } from \"../types/frame.js\";\nimport { getDb, getFramesByJira, getFramesByBranch } from \"../../memory/store/index.js\";\nimport {\n  buildTimeline,\n  filterTimeline,\n  renderTimelineText,\n  renderModuleScopeEvolution,\n  renderBlockerTracking,\n  renderTimelineJSON,\n  renderTimelineHTML,\n  type TimelineOptions,\n} from \"../../memory/renderer/timeline.js\";\nimport { writeFileSync } from \"fs\";\n\nexport interface TimelineCommandOptions {\n  since?: string;\n  until?: string;\n  format?: \"text\" | \"json\" | \"html\";\n  output?: string;\n  json?: boolean;\n}\n\n/**\n * Execute the 'lex timeline' command\n * Shows Frame evolution for a ticket or branch\n */\nexport async function timeline(\n  ticketOrBranch: string,\n  options: TimelineCommandOptions = {}\n): Promise<void> {\n  try {\n    const db = getDb();\n    let frames: Frame[] = [];\n    let title: string;\n\n    // Try to find frames by Jira ticket first, then by branch\n    const framesByJira = getFramesByJira(db, ticketOrBranch);\n    if (framesByJira.length > 0) {\n      frames = framesByJira;\n      title = `${ticketOrBranch}: Timeline`;\n    } else {\n      const framesByBranch = getFramesByBranch(db, ticketOrBranch);\n      if (framesByBranch.length > 0) {\n        frames = framesByBranch;\n        title = `Branch ${ticketOrBranch}: Timeline`;\n      } else {\n        // No frames found\n        title = `${ticketOrBranch}: Timeline`;\n      }\n    }\n\n    if (frames.length === 0) {\n      console.log(`\\n❌ No frames found for: \"${ticketOrBranch}\"\\n`);\n      console.log(\"Try using a Jira ticket ID (e.g., TICKET-123) or a branch name.\\n\");\n      process.exit(1);\n    }\n\n    // Build timeline\n    let timelineData = buildTimeline(frames);\n\n    // Apply filters\n    const timelineOptions: TimelineOptions = {\n      format: options.format || \"text\",\n    };\n\n    if (options.since) {\n      timelineOptions.since = new Date(options.since);\n    }\n\n    if (options.until) {\n      timelineOptions.until = new Date(options.until);\n    }\n\n    if (timelineOptions.since || timelineOptions.until) {\n      timelineData = filterTimeline(timelineData, timelineOptions);\n\n      if (timelineData.length === 0) {\n        console.log(`\\n❌ No frames found in the specified date range.\\n`);\n        process.exit(1);\n      }\n    }\n\n    // Render timeline based on format\n    const format = options.format || (options.json ? \"json\" : \"text\");\n    let output: string;\n\n    switch (format) {\n      case \"json\":\n        output = renderTimelineJSON(timelineData);\n        break;\n      case \"html\":\n        output = renderTimelineHTML(timelineData, title);\n        break;\n      case \"text\":\n      default:\n        output = renderTimelineText(timelineData, title);\n        output += renderModuleScopeEvolution(timelineData);\n        output += renderBlockerTracking(timelineData);\n        break;\n    }\n\n    // Write to file or stdout\n    if (options.output) {\n      writeFileSync(options.output, output, \"utf-8\");\n      console.log(`\\n✅ Timeline written to: ${options.output}\\n`);\n    } else {\n      console.log(output);\n    }\n  } catch (error: any) {\n    console.error(`\\n❌ Error: ${error.message}\\n`);\n    process.exit(2);\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/srv/lex-mcp/lex/src/shared/git/branch.ts","messages":[{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":35,"column":7,"nodeType":"MemberExpression","messageId":"conditionErrorNullableString","endLine":35,"endColumn":37,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[935,965],"text":"process.env.LEX_DEFAULT_BRANCH != null"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[935,965],"text":"process.env.LEX_DEFAULT_BRANCH ?? \"\""},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[935,965],"text":"Boolean(process.env.LEX_DEFAULT_BRANCH)"},"desc":"Explicitly convert value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'error' is defined but never used.","line":60,"column":12,"nodeType":null,"messageId":"unusedVar","endLine":60,"endColumn":17}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Git branch detection utility\n *\n * Provides auto-detection of current git branch with fallback handling\n * for edge cases like detached HEAD and non-git repositories.\n */\n\nimport { execSync } from \"child_process\";\n\n/**\n * Cache for the current branch to avoid repeated git calls\n */\nlet branchCache: string | null = null;\n\n/**\n * Get the current git branch name\n *\n * @returns Current git branch name, or fallback value for edge cases\n *\n * Behavior:\n * - Returns current branch name in normal git repository\n * - Returns \"detached\" when HEAD is detached\n * - Returns \"unknown\" when not in a git repository\n * - Respects LEX_DEFAULT_BRANCH environment variable as override\n * - Caches result for performance\n *\n * @example\n * ```ts\n * const branch = getCurrentBranch();\n * console.log(`Current branch: ${branch}`);\n * ```\n */\nexport function getCurrentBranch(): string {\n  // Check for environment variable override first\n  if (process.env.LEX_DEFAULT_BRANCH) {\n    return process.env.LEX_DEFAULT_BRANCH;\n  }\n\n  // Return cached value if available\n  if (branchCache !== null) {\n    return branchCache;\n  }\n\n  try {\n    // Execute git command to get current branch\n    const result = execSync(\"git rev-parse --abbrev-ref HEAD\", {\n      encoding: \"utf-8\",\n      stdio: [\"pipe\", \"pipe\", \"pipe\"],\n    }).trim();\n\n    // Check for detached HEAD state\n    if (result === \"HEAD\") {\n      branchCache = \"detached\";\n      return branchCache;\n    }\n\n    // Cache and return the branch name\n    branchCache = result;\n    return branchCache;\n  } catch (error) {\n    // Not a git repository or git command failed\n    branchCache = \"unknown\";\n    return branchCache;\n  }\n}\n\n/**\n * Clear the branch cache\n *\n * Useful for testing or when the branch might have changed\n * (e.g., after a checkout operation)\n */\nexport function clearBranchCache(): void {\n  branchCache = null;\n}\n","usedDeprecatedRules":[]},{"filePath":"/srv/lex-mcp/lex/src/shared/module_ids/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/srv/lex-mcp/lex/src/shared/module_ids/validator.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'ResolutionResult' is defined but never used. Allowed unused vars must match /^_/u.","line":11,"column":48,"nodeType":null,"messageId":"unusedVar","endLine":11,"endColumn":64},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'ResolverOptions' is defined but never used. Allowed unused vars must match /^_/u.","line":12,"column":27,"nodeType":null,"messageId":"unusedVar","endLine":12,"endColumn":42},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'loadAliasTable' is defined but never used. Allowed unused vars must match /^_/u.","line":15,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":15,"endColumn":17},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'findSubstringMatches' is defined but never used. Allowed unused vars must match /^_/u.","line":16,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":16,"endColumn":23},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'AmbiguousSubstringError' is defined but never used. Allowed unused vars must match /^_/u.","line":17,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":17,"endColumn":26},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected object value in conditional. The condition is always true.","line":148,"column":8,"nodeType":"Identifier","messageId":"conditionErrorObject","endLine":148,"endColumn":19},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected object value in conditional. The condition is always true.","line":234,"column":8,"nodeType":"Identifier","messageId":"conditionErrorObject","endLine":234,"endColumn":19}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":7,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Module ID Validation - THE CRITICAL RULE Enforcement\n *\n * Ensures that module IDs used in Frames match the module IDs defined in lexmap.policy.json\n * This prevents vocabulary drift between memory and policy subsystems.\n *\n * Now integrates with alias resolution to support shorthand and historical names.\n */\n\nimport type { Policy } from \"../types/policy.js\";\nimport type { ValidationResult, ModuleIdError, ResolutionResult } from \"../types/validation.js\";\nimport type { AliasTable, ResolverOptions } from \"../aliases/types.js\";\nimport {\n  resolveModuleId,\n  loadAliasTable,\n  findSubstringMatches,\n  AmbiguousSubstringError,\n} from \"../aliases/resolver.js\";\n\n// Re-export for use by other packages\nexport { resolveModuleId };\n\n/**\n * Cache for policy module ID sets\n * Uses WeakMap to avoid memory leaks - entries are garbage collected when policy is no longer referenced\n */\nconst policyModuleIdsCache = new WeakMap<Policy, Set<string>>();\n\n/**\n * Get or create a Set of module IDs from a policy (with caching)\n */\nfunction getPolicyModuleIds(policy: Policy): Set<string> {\n  let moduleIds = policyModuleIdsCache.get(policy);\n  if (!moduleIds) {\n    moduleIds = new Set(Object.keys(policy.modules));\n    policyModuleIdsCache.set(policy, moduleIds);\n  }\n  return moduleIds;\n}\n\n/**\n * Maximum edit distance threshold for fuzzy matching suggestions\n * Only suggest module names if edit distance is within this threshold\n */\nconst MAX_EDIT_DISTANCE_THRESHOLD = 10;\n\n/**\n * Confidence level for exact matches and aliases\n * Only resolutions with this confidence level are accepted as valid\n */\nconst EXACT_MATCH_CONFIDENCE = 1.0;\n\n/**\n * Confidence level for substring matches\n * These are treated as invalid but suggestions are provided\n */\nconst SUBSTRING_MATCH_CONFIDENCE = 0.9;\n\n/**\n * Calculate Levenshtein distance between two strings\n * Used for fuzzy matching to suggest similar module names\n */\nfunction levenshteinDistance(str1: string, str2: string): number {\n  const len1 = str1.length;\n  const len2 = str2.length;\n  const matrix: number[][] = [];\n\n  // Initialize matrix\n  for (let i = 0; i <= len1; i++) {\n    matrix[i] = [i];\n  }\n  for (let j = 0; j <= len2; j++) {\n    matrix[0][j] = j;\n  }\n\n  // Calculate distances\n  for (let i = 1; i <= len1; i++) {\n    for (let j = 1; j <= len2; j++) {\n      const cost = str1[i - 1] === str2[j - 1] ? 0 : 1;\n      matrix[i][j] = Math.min(\n        matrix[i - 1][j] + 1, // deletion\n        matrix[i][j - 1] + 1, // insertion\n        matrix[i - 1][j - 1] + cost // substitution\n      );\n    }\n  }\n\n  return matrix[len1][len2];\n}\n\n/**\n * Find similar module IDs based on edit distance\n * Returns up to 3 suggestions, sorted by similarity\n */\nfunction findSimilarModules(\n  moduleId: string,\n  availableModules: Set<string>,\n  maxSuggestions: number = 3\n): string[] {\n  const suggestions: Array<{ module: string; distance: number }> = [];\n\n  for (const available of availableModules) {\n    const distance = levenshteinDistance(moduleId.toLowerCase(), available.toLowerCase());\n    suggestions.push({ module: available, distance });\n  }\n\n  // Filter by threshold FIRST, then sort and take top N\n  return suggestions\n    .filter((s) => s.distance <= MAX_EDIT_DISTANCE_THRESHOLD)\n    .sort((a, b) => a.distance - b.distance)\n    .slice(0, maxSuggestions)\n    .map((s) => s.module);\n}\n\n/**\n * Validate that all module IDs in moduleScope exist in the policy\n * NOW WITH ALIAS RESOLUTION SUPPORT\n *\n * This function resolves aliases first, then validates canonical IDs against policy.\n * Returns canonical IDs for storage in Frame.module_scope.\n *\n * @param moduleScope - Array of module IDs to validate (may include aliases)\n * @param policy - Policy object containing module definitions\n * @param aliasTable - Optional pre-loaded alias table\n * @returns ValidationResult with errors, suggestions, and canonical IDs for storage\n *\n * @example\n * ```typescript\n * const result = await validateModuleIds(\n *   ['auth-core', 'ui/user-panel'],  // 'auth-core' is an alias\n *   policy\n * );\n *\n * if (result.valid) {\n *   console.log(result.canonical);  // ['services/auth-core', 'ui/user-panel']\n *   // Store result.canonical in Frame.module_scope\n * } else {\n *   console.error(result.errors);\n * }\n * ```\n */\nexport async function validateModuleIds(\n  moduleScope: string[],\n  policy: Policy,\n  aliasTable?: AliasTable\n): Promise<ValidationResult> {\n  // Empty module_scope is allowed\n  if (!moduleScope || moduleScope.length === 0) {\n    return { valid: true, canonical: [] };\n  }\n\n  // Get cached policy module ID set for efficiency\n  const policyModuleIds = getPolicyModuleIds(policy);\n\n  // Fast path: Check if all module IDs are exact matches (common case)\n  // This avoids the overhead of calling resolveModuleId for every module\n  const allExactMatches = moduleScope.every((id) => policyModuleIds.has(id));\n\n  if (allExactMatches) {\n    // All are exact matches - return immediately without alias resolution\n    return { valid: true, canonical: moduleScope };\n  }\n\n  // Step 1: Resolve all aliases (only reached if there are non-exact matches)\n  // Disable substring matching to enforce exact matches only\n  const resolutions = await Promise.all(\n    moduleScope.map((id) => resolveModuleId(id, policy, aliasTable, { noSubstring: true }))\n  );\n\n  // Step 2: Validate all canonical IDs exist in policy\n  // Only accept exact matches (confidence 1.0) and aliases (confidence 1.0)\n  // Substring matches (confidence 0.9) and fuzzy matches (confidence 0) should fail with suggestions\n  const errors: ModuleIdError[] = [];\n  const canonicalIds: string[] = [];\n\n  for (const resolution of resolutions) {\n    // Only accept high-confidence resolutions (exact match or alias)\n    const isValid =\n      resolution.confidence === EXACT_MATCH_CONFIDENCE && policyModuleIds.has(resolution.canonical);\n\n    if (!isValid) {\n      // For substring matches, provide the substring match as a suggestion\n      let suggestions: string[];\n      if (\n        resolution.confidence === SUBSTRING_MATCH_CONFIDENCE &&\n        policyModuleIds.has(resolution.canonical)\n      ) {\n        // Substring match found - suggest it\n        suggestions = [resolution.canonical];\n      } else {\n        // No substring match or invalid - use fuzzy matching for suggestions\n        suggestions = findSimilarModules(resolution.original, policyModuleIds);\n      }\n\n      const suggestionText = suggestions.length > 0 ? ` Did you mean '${suggestions[0]}'?` : \"\";\n\n      // If an alias resolves to a canonical ID that doesn't exist in policy,\n      // include the resolved canonical in the error message for clarity.\n      const message =\n        resolution.confidence === EXACT_MATCH_CONFIDENCE\n          ? `Module '${resolution.original}' resolved to '${resolution.canonical}' which is not found in policy.${suggestionText}`\n          : `Module '${resolution.original}' not found in policy.${suggestionText}`;\n\n      errors.push({\n        module: resolution.original,\n        message,\n        suggestions,\n      });\n    } else {\n      // Valid - add canonical ID to result\n      canonicalIds.push(resolution.canonical);\n    }\n  }\n\n  if (errors.length > 0) {\n    return {\n      valid: false,\n      errors,\n    };\n  }\n\n  return { valid: true, canonical: canonicalIds };\n}\n\n/**\n * DEPRECATED: Use async validateModuleIds instead\n *\n * Synchronous validation without alias resolution (legacy support)\n *\n * @deprecated This function does not support alias resolution. Use async validateModuleIds.\n */\nexport function validateModuleIdsSync(moduleScope: string[], policy: Policy): ValidationResult {\n  // Empty module_scope is allowed\n  if (!moduleScope || moduleScope.length === 0) {\n    return { valid: true };\n  }\n\n  const policyModuleIds = getPolicyModuleIds(policy);\n  const errors: ModuleIdError[] = [];\n\n  for (const moduleId of moduleScope) {\n    // Case-sensitive exact match required\n    if (!policyModuleIds.has(moduleId)) {\n      const suggestions = findSimilarModules(moduleId, policyModuleIds);\n      const suggestionText = suggestions.length > 0 ? ` Did you mean '${suggestions[0]}'?` : \"\";\n\n      errors.push({\n        module: moduleId,\n        message: `Module '${moduleId}' not found in policy.${suggestionText}`,\n        suggestions,\n      });\n    }\n  }\n\n  if (errors.length > 0) {\n    return {\n      valid: false,\n      errors,\n    };\n  }\n\n  return { valid: true };\n}\n","usedDeprecatedRules":[]},{"filePath":"/srv/lex-mcp/lex/src/shared/policy/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/srv/lex-mcp/lex/src/shared/policy/loader.ts","messages":[{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":1,"message":"Unsafe assignment of an `any` value.","line":47,"column":13,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":47,"endColumn":77},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .name on an `any` value.","line":49,"column":23,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":49,"endColumn":27},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":65,"column":37,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":65,"endColumn":40,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1849,1852],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1849,1852],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected any value in conditional. An explicit comparison or type conversion is required.","line":67,"column":7,"nodeType":"MemberExpression","messageId":"conditionErrorAny","endLine":67,"endColumn":24,"suggestions":[{"messageId":"conditionFixCastBoolean","fix":{"range":[1922,1939],"text":"(Boolean(rawPolicy.modules))"},"desc":"Explicitly convert value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .modules on an `any` value.","line":67,"column":17,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":67,"endColumn":24},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected any value in conditional. An explicit comparison or type conversion is required.","line":67,"column":29,"nodeType":"MemberExpression","messageId":"conditionErrorAny","endLine":67,"endColumn":55,"suggestions":[{"messageId":"conditionFixCastBoolean","fix":{"range":[1944,1970],"text":"(Boolean(rawPolicy.modules.patterns))"},"desc":"Explicitly convert value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .modules on an `any` value.","line":67,"column":39,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":67,"endColumn":46},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":72,"column":33,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":72,"endColumn":36,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2092,2095],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2092,2095],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected any value in conditional. An explicit comparison or type conversion is required.","line":74,"column":7,"nodeType":"ChainExpression","messageId":"conditionErrorAny","endLine":74,"endColumn":34,"suggestions":[{"messageId":"conditionFixCastBoolean","fix":{"range":[2110,2137],"text":"Boolean((rawPolicy.modules?.patterns))"},"desc":"Explicitly convert value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .modules on an `any` value.","line":74,"column":17,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":74,"endColumn":24},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .modules on an `any` value.","line":75,"column":37,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":75,"endColumn":44},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Computed name [pattern.name] resolves to an `any` value.","line":76,"column":15,"nodeType":"MemberExpression","messageId":"unsafeComputedMemberAccess","endLine":76,"endColumn":27},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .name on an `any` value.","line":76,"column":23,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":76,"endColumn":27},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .match on an `any` value.","line":77,"column":30,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":77,"endColumn":35},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":1,"message":"Unsafe assignment of an `any` value.","line":89,"column":5,"nodeType":"Property","messageId":"anyAssignment","endLine":92,"endColumn":8},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":1,"message":"Unsafe call of a(n) `any` typed value.","line":89,"column":27,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":89,"endColumn":55},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .kill_patterns on an `any` value.","line":89,"column":37,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":89,"endColumn":50},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":89,"column":61,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":89,"endColumn":64,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2692,2695],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2692,2695],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":1,"message":"Unsafe assignment of an `any` value.","line":90,"column":7,"nodeType":"Property","messageId":"anyAssignment","endLine":90,"endColumn":23},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .kind on an `any` value.","line":90,"column":19,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":90,"endColumn":23},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":1,"message":"Unsafe assignment of an `any` value.","line":91,"column":7,"nodeType":"Property","messageId":"anyAssignment","endLine":91,"endColumn":28},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .match on an `any` value.","line":91,"column":23,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":91,"endColumn":28},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected any value in conditional. An explicit comparison or type conversion is required.","line":129,"column":7,"nodeType":"Identifier","messageId":"conditionErrorAny","endLine":129,"endColumn":19,"suggestions":[{"messageId":"conditionFixCastBoolean","fix":{"range":[3893,3905],"text":"(Boolean(cachedPolicy))"},"desc":"Explicitly convert value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":129,"column":24,"nodeType":"Identifier","messageId":"conditionErrorNullableString","endLine":129,"endColumn":28,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[3909,3914],"text":"(path == null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[3910,3914],"text":"(path ?? \"\")"},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[3909,3914],"text":"(!Boolean(path))"},"desc":"Explicitly convert value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":140,"column":9,"nodeType":"Identifier","messageId":"conditionErrorNullableString","endLine":140,"endColumn":16,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[4123,4130],"text":"envPath != null"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[4123,4130],"text":"envPath ?? \"\""},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[4123,4130],"text":"Boolean(envPath)"},"desc":"Explicitly convert value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":143,"column":16,"nodeType":"Identifier","messageId":"conditionErrorNullableString","endLine":143,"endColumn":20,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[4250,4254],"text":"path != null"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[4250,4254],"text":"path ?? \"\""},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[4250,4254],"text":"Boolean(path)"},"desc":"Explicitly convert value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'usedFallback' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":165,"column":13,"nodeType":null,"messageId":"unusedVar","endLine":165,"endColumn":25},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":1,"message":"Unsafe assignment of an `any` value.","line":181,"column":11,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":181,"endColumn":48},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":1,"message":"Unsafe assignment of an error typed value.","line":184,"column":11,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":184,"endColumn":46},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected any value in conditional. An explicit comparison or type conversion is required.","line":187,"column":10,"nodeType":"MemberExpression","messageId":"conditionErrorAny","endLine":187,"endColumn":24,"suggestions":[{"messageId":"conditionFixCastBoolean","fix":{"range":[5722,5736],"text":"(Boolean(policy.modules))"},"desc":"Explicitly convert value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .modules on an `error` typed value.","line":187,"column":17,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":187,"endColumn":24},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .modules on an `error` typed value.","line":187,"column":42,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":187,"endColumn":49},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":192,"column":10,"nodeType":"Identifier","messageId":"conditionErrorNullableString","endLine":192,"endColumn":17,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[5951,5959],"text":"(envPath == null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[5952,5959],"text":"(envPath ?? \"\")"},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[5951,5959],"text":"(!Boolean(envPath))"},"desc":"Explicitly convert value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":192,"column":22,"nodeType":"Identifier","messageId":"conditionErrorNullableString","endLine":192,"endColumn":26,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[5963,5968],"text":"(path == null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[5964,5968],"text":"(path ?? \"\")"},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[5963,5968],"text":"(!Boolean(path))"},"desc":"Explicitly convert value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":1,"message":"Unsafe assignment of an error typed value.","line":193,"column":7,"nodeType":"AssignmentExpression","messageId":"anyAssignment","endLine":193,"endColumn":28},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":197,"column":19,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":197,"endColumn":22,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6045,6048],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6045,6048],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .code on an `any` value.","line":198,"column":15,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":198,"endColumn":19},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":200,"column":35,"nodeType":"Identifier","messageId":"conditionErrorNullableString","endLine":200,"endColumn":42,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[6144,6151],"text":"(envPath != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[6144,6151],"text":"(envPath ?? \"\")"},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[6144,6151],"text":"(Boolean(envPath))"},"desc":"Explicitly convert value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":200,"column":46,"nodeType":"Identifier","messageId":"conditionErrorNullableString","endLine":200,"endColumn":50,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[6155,6159],"text":"(path != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[6155,6159],"text":"(path ?? \"\")"},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[6155,6159],"text":"(Boolean(path))"},"desc":"Explicitly convert value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":205,"column":37,"nodeType":"Identifier","messageId":"conditionErrorNullableString","endLine":205,"endColumn":44,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[6326,6333],"text":"(envPath != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[6326,6333],"text":"(envPath ?? \"\")"},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[6326,6333],"text":"(Boolean(envPath))"},"desc":"Explicitly convert value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":205,"column":48,"nodeType":"Identifier","messageId":"conditionErrorNullableString","endLine":205,"endColumn":52,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[6337,6341],"text":"(path != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[6337,6341],"text":"(path ?? \"\")"},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[6337,6341],"text":"(Boolean(path))"},"desc":"Explicitly convert value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .message on an `any` value.","line":205,"column":86,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":205,"endColumn":93}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":42,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Policy Loading Utility\n *\n * Loads and caches policy from lexmap.policy.json\n * Supports custom policy path via environment variable\n */\n\nimport { readFileSync, existsSync } from \"fs\";\nimport { resolve, dirname, join } from \"path\";\n// @ts-ignore - importing from compiled dist directory\nimport type { Policy } from \"../../types/policy.js\";\n\n/**\n * Default working policy path (from repository root)\n */\nconst DEFAULT_POLICY_PATH = \".smartergpt.local/lex/lexmap.policy.json\";\n\n/**\n * Fallback example policy path (from repository root)\n */\nconst EXAMPLE_POLICY_PATH = \"src/policy/policy_spec/lexmap.policy.json.example\";\n\n/**\n * Legacy policy path (for backward compatibility during transition)\n */\nconst LEGACY_POLICY_PATH = \"src/policy/policy_spec/lexmap.policy.json\";\n\n/**\n * Environment variable for custom policy path\n */\nconst POLICY_PATH_ENV = \"LEX_POLICY_PATH\";\n\n/**\n * Cached policy to avoid re-reading from disk\n */\nlet cachedPolicy: Policy | null = null;\n\n/**\n * Find repository root by looking for package.json\n */\nfunction findRepoRoot(startPath: string): string {\n  let currentPath = startPath;\n\n  while (currentPath !== dirname(currentPath)) {\n    const packageJsonPath = join(currentPath, \"package.json\");\n    if (existsSync(packageJsonPath)) {\n      const packageJson = JSON.parse(readFileSync(packageJsonPath, \"utf-8\"));\n      // Check if this is the lex root package\n      if (packageJson.name === \"lex\") {\n        return currentPath;\n      }\n    }\n    currentPath = dirname(currentPath);\n  }\n\n  throw new Error('Could not find repository root (looking for package.json with name \"lex\")');\n}\n\n/**\n * Transform lexmap.policy.json format to Policy type format\n *\n * lexmap.policy.json uses a \"patterns\" array, but the Policy type expects\n * modules to be a Record<string, PolicyModule>\n */\nfunction transformPolicy(rawPolicy: any): Policy {\n  // If already in the correct format, return as-is\n  if (rawPolicy.modules && !rawPolicy.modules.patterns) {\n    return rawPolicy as Policy;\n  }\n\n  // Transform patterns format to modules format\n  const modules: Record<string, any> = {};\n\n  if (rawPolicy.modules?.patterns) {\n    for (const pattern of rawPolicy.modules.patterns) {\n      modules[pattern.name] = {\n        owns_paths: [pattern.match],\n        allowed_callers: [],\n        forbidden_callers: [],\n      };\n    }\n  }\n\n  return {\n    modules,\n    // NOTE: global_kill_patterns transformation is not currently used by module validation\n    // The kind/match fields may need verification if this feature is enabled in the future\n    // For now, this maps kind→pattern and match→description as a placeholder\n    global_kill_patterns: rawPolicy.kill_patterns?.map((kp: any) => ({\n      pattern: kp.kind,\n      description: kp.match,\n    })),\n  };\n}\n\n/**\n * Load policy from lexmap.policy.json\n *\n * @param path - Optional custom policy path (defaults to working file with fallback to example)\n * @returns Policy object\n * @throws Error if policy file cannot be read or parsed\n *\n * Policy loading precedence:\n * 1. LEX_POLICY_PATH environment variable (explicit override)\n * 2. Custom path parameter (if provided)\n * 3. .smartergpt.local/lex/lexmap.policy.json (working file)\n * 4. src/policy/policy_spec/lexmap.policy.json.example (example template)\n * 5. src/policy/policy_spec/lexmap.policy.json (legacy location)\n *\n * @example\n * ```typescript\n * const policy = loadPolicy();\n * console.log(Object.keys(policy.modules)); // ['indexer', 'ts', 'php', 'mcp']\n * ```\n *\n * @example With custom path\n * ```typescript\n * const policy = loadPolicy('/custom/path/policy.json');\n * ```\n *\n * @example With environment variable\n * ```typescript\n * process.env.LEX_POLICY_PATH = '/custom/path/policy.json';\n * const policy = loadPolicy();\n * ```\n */\nexport function loadPolicy(path?: string): Policy {\n  // Return cached policy if available and no custom path specified\n  if (cachedPolicy && !path) {\n    return cachedPolicy;\n  }\n\n  // Determine policy path with fallback chain\n  const envPath = process.env[POLICY_PATH_ENV];\n  \n  try {\n    let resolvedPath: string;\n    let usedFallback = false;\n\n    if (envPath) {\n      // Priority 1: Environment variable (explicit override)\n      resolvedPath = resolve(envPath);\n    } else if (path) {\n      // Priority 2: Custom path parameter\n      resolvedPath = resolve(path);\n    } else {\n      // Priority 3-5: Try working file, then example, then legacy\n      const repoRoot = findRepoRoot(process.cwd());\n      \n      // Try working file first\n      const workingPath = join(repoRoot, DEFAULT_POLICY_PATH);\n      if (existsSync(workingPath)) {\n        resolvedPath = workingPath;\n      } else {\n        // Fallback to example file\n        const examplePath = join(repoRoot, EXAMPLE_POLICY_PATH);\n        if (existsSync(examplePath)) {\n          resolvedPath = examplePath;\n          usedFallback = true;\n        } else {\n          // Last resort: try legacy location\n          const legacyPath = join(repoRoot, LEGACY_POLICY_PATH);\n          if (existsSync(legacyPath)) {\n            resolvedPath = legacyPath;\n            usedFallback = true;\n          } else {\n            throw new Error(\n              `Policy file not found. Tried:\\n` +\n              `  1. ${workingPath}\\n` +\n              `  2. ${examplePath}\\n` +\n              `  3. ${legacyPath}\\n\\n` +\n              `Run 'npm run setup-local' to initialize working files.`\n            );\n          }\n        }\n      }\n    }\n\n    // Read and parse policy file\n    const policyContent = readFileSync(resolvedPath, \"utf-8\");\n    const rawPolicy = JSON.parse(policyContent);\n\n    // Transform to expected format\n    const policy = transformPolicy(rawPolicy);\n\n    // Validate basic structure\n    if (!policy.modules || typeof policy.modules !== \"object\") {\n      throw new Error('Invalid policy structure: missing or invalid \"modules\" field');\n    }\n\n    // Cache policy if using default path (not env var or custom path)\n    if (!envPath && !path) {\n      cachedPolicy = policy;\n    }\n\n    return policy;\n  } catch (error: any) {\n    if (error.code === \"ENOENT\") {\n      throw new Error(\n        `Policy file not found: ${envPath || path || DEFAULT_POLICY_PATH}\\n` +\n        `Run 'npm run setup-local' to initialize working files.`\n      );\n    }\n    throw new Error(\n      `Failed to load policy from ${envPath || path || DEFAULT_POLICY_PATH}: ${error.message}`\n    );\n  }\n}\n\n/**\n * Clear cached policy (useful for testing)\n */\nexport function clearPolicyCache(): void {\n  cachedPolicy = null;\n}\n","usedDeprecatedRules":[]},{"filePath":"/srv/lex-mcp/lex/src/shared/types/frame.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/srv/lex-mcp/lex/src/shared/types/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/srv/lex-mcp/lex/src/shared/types/policy.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/srv/lex-mcp/lex/src/shared/types/validation.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/srv/lex-mcp/lex/test/memory/benchmarks.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/srv/lex-mcp/lex/test/memory/integration.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/srv/lex-mcp/lex/test/memory/mcp_server/alias-benchmarks.test.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'after' is defined but never used. Allowed unused vars must match /^_/u.","line":22,"column":34,"nodeType":null,"messageId":"unusedVar","endLine":22,"endColumn":39},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'mkdtempSync' is defined but never used. Allowed unused vars must match /^_/u.","line":26,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":26,"endColumn":21},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'rmSync' is defined but never used. Allowed unused vars must match /^_/u.","line":26,"column":23,"nodeType":null,"messageId":"unusedVar","endLine":26,"endColumn":29},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'writeFileSync' is defined but never used. Allowed unused vars must match /^_/u.","line":26,"column":31,"nodeType":null,"messageId":"unusedVar","endLine":26,"endColumn":44},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'join' is defined but never used. Allowed unused vars must match /^_/u.","line":27,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":27,"endColumn":14},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'tmpdir' is defined but never used. Allowed unused vars must match /^_/u.","line":28,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":28,"endColumn":16},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":32,"column":33,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":32,"endColumn":36,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1045,1048],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1045,1048],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'error' is defined but never used.","line":57,"column":12,"nodeType":null,"messageId":"unusedVar","endLine":57,"endColumn":17},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":98,"column":17,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":98,"endColumn":20,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2865,2868],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2865,2868],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":99,"column":18,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":99,"endColumn":21,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2887,2890],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2887,2890],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":100,"column":19,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":100,"endColumn":22,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2910,2913],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2910,2913],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":11,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Performance Benchmarks for Alias Resolution\n *\n * Measures the performance impact of module ID validation with fuzzy matching.\n *\n * Target: < 5% performance regression on average case\n *\n * Before (Exact Match Only):\n * - Validation time: ~0.5ms per module ID\n * - Atlas Frame generation: ~10ms\n * - Memory overhead: None\n *\n * After (With Fuzzy Matching):\n * - Exact match path: ~0.5ms (unchanged)\n * - Fuzzy fallback: ~2ms worst case (only on mismatch)\n * - Atlas Frame generation: ~10ms (unchanged)\n * - Memory overhead: ~10KB (policy cache)\n *\n * Run with: npm run build && node --test dist/alias-benchmarks.test.js\n */\n\nimport { test, describe, before, after } from \"node:test\";\nimport assert from \"node:assert\";\n// @ts-ignore\nimport { validateModuleIds } from \"@app/shared/module_ids/validator.js\";\nimport { mkdtempSync, rmSync, writeFileSync } from \"fs\";\nimport { join } from \"path\";\nimport { tmpdir } from \"os\";\n\n// Mock policy for benchmarking\nconst createTestPolicy = (moduleCount: number) => {\n  const modules: Record<string, any> = {};\n\n  // Add realistic module names\n  for (let i = 0; i < moduleCount; i++) {\n    modules[`services/module-${i}`] = { owns_paths: [`services/module-${i}/**`] };\n  }\n\n  // Add common modules matching the actual policy structure\n  modules[\"policy/scanners\"] = { owns_paths: [\"src/policy/scanners/**\"] };\n  modules[\"shared/types\"] = { owns_paths: [\"src/shared/types/**\"] };\n  modules[\"memory/mcp\"] = { owns_paths: [\"src/memory/mcp_server/**\"] };\n  modules[\"services/auth-core\"] = { owns_paths: [\"services/auth/**\"] };\n  modules[\"ui/main-panel\"] = { owns_paths: [\"ui/main/**\"] };\n  modules[\"api/user-access\"] = { owns_paths: [\"api/user/**\"] };\n\n  return { modules };\n};\n\n/**\n * Measure execution time for async function\n */\nasync function measureTime(fn: () => Promise<void>): Promise<number> {\n  const start = performance.now();\n  try {\n    await fn();\n  } catch (error) {\n    // Still record timing even if function throws\n    // This ensures we measure actual execution time\n  }\n  const end = performance.now();\n  return end - start;\n}\n\n/**\n * Run benchmark multiple times and return average\n */\nasync function benchmark(\n  name: string,\n  iterations: number,\n  fn: () => Promise<void>\n): Promise<number> {\n  const times: number[] = [];\n\n  // Warmup\n  for (let i = 0; i < 5; i++) {\n    await fn();\n  }\n\n  // Actual measurements\n  for (let i = 0; i < iterations; i++) {\n    times.push(await measureTime(fn));\n  }\n\n  const avg = times.reduce((a, b) => a + b, 0) / times.length;\n  const min = Math.min(...times);\n  const max = Math.max(...times);\n\n  console.log(`  ${name}:`);\n  console.log(`    Average: ${avg.toFixed(3)}ms`);\n  console.log(`    Min: ${min.toFixed(3)}ms`);\n  console.log(`    Max: ${max.toFixed(3)}ms`);\n\n  return avg;\n}\n\ndescribe(\"Alias Resolution Performance Benchmarks\", () => {\n  let policy10: any;\n  let policy100: any;\n  let policy1000: any;\n\n  before(() => {\n    // Create fresh policy objects before each test suite\n    // This ensures consistent performance measurements\n    policy10 = createTestPolicy(10);\n    policy100 = createTestPolicy(100);\n    policy1000 = createTestPolicy(1000);\n  });\n\n  describe(\"Performance Regression Check\", () => {\n    // Run regression test FIRST, before other tests warm up caches\n    test(\"should have reasonable overhead for fuzzy matching support\", async () => {\n      // NOTE: This benchmark compares exact-match validation against a synchronous\n      // Set.has() baseline. The validateModuleIds function is async to support\n      // fuzzy matching and alias resolution on mismatch.\n      //\n      // The \"regression\" here actually represents the cost of:\n      // 1. Async function overhead (~0.1-0.2ms per call)\n      // 2. Promise creation and resolution\n      // 3. Type safety and validation framework\n      //\n      // This is EXPECTED and ACCEPTABLE because:\n      // - Module validation is not in the hot path (happens at Frame store time, not runtime)\n      // - The overhead is negligible for interactive use\n      // - Exact matches take <0.3ms (well below human perception threshold)\n      // - Fuzzy matching fallback is only triggered on mismatches (error cases)\n\n      // WARMUP: Let JIT and caches initialize\n      for (let i = 0; i < 100; i++) {\n        await validateModuleIds([\"policy/scanners\"], policy100);\n      }\n\n      // Measure exact match validation (fast path)\n      const fastPathTime = await benchmark(\"Exact match validation (fast path)\", 1000, async () => {\n        await validateModuleIds([\"policy/scanners\"], policy100);\n      });\n\n      console.log(`  Exact match performance:`);\n      console.log(`    Time per validation: ${fastPathTime.toFixed(3)}ms`);\n      console.log(`    Operations per second: ${(1000 / fastPathTime).toFixed(0)}`);\n\n      // Fast path should complete in under 0.5ms per validation\n      // (negligible overhead for non-hot-path operation)\n      assert.ok(\n        fastPathTime < 0.5,\n        `Exact match validation took ${fastPathTime.toFixed(3)}ms, expected <0.5ms`\n      );\n    });\n  });\n\n  describe(\"Exact Match Path (Best Case)\", () => {\n    test(\"should validate exact matches very quickly (<0.5ms)\", async () => {\n      const avgTime = await benchmark(\n        \"Exact match validation (10 modules policy)\",\n        1000,\n        async () => {\n          await validateModuleIds([\"policy/scanners\", \"shared/types\", \"memory/mcp\"], policy10);\n        }\n      );\n\n      assert.ok(avgTime < 0.5, `Exact match took ${avgTime.toFixed(3)}ms, expected <0.5ms`);\n    });\n\n    test(\"should scale with policy size (O(1) hash lookup)\", async () => {\n      // The scaling test is inherently flaky on first run due to:\n      // 1. JIT warmup of validateModuleIds\n      // 2. Cache initialization in policyModuleIdsCache\n      // 3. Node.js garbage collection timing\n      //\n      // We measure but use generous thresholds on first run\n      // (subsequent runs should be much tighter)\n\n      const time10 = await benchmark(\"Exact match with 10 modules policy\", 1000, async () => {\n        await validateModuleIds([\"policy/scanners\"], policy10);\n      });\n\n      const time100 = await benchmark(\"Exact match with 100 modules policy\", 1000, async () => {\n        await validateModuleIds([\"policy/scanners\"], policy100);\n      });\n\n      const time1000 = await benchmark(\"Exact match with 1000 modules policy\", 1000, async () => {\n        await validateModuleIds([\"policy/scanners\"], policy1000);\n      });\n\n      // Hash table lookup should be O(1), so times should be similar\n      console.log(`  Scaling comparison:`);\n      console.log(`    10 modules: ${time10.toFixed(3)}ms`);\n      console.log(`    100 modules: ${time100.toFixed(3)}ms`);\n      console.log(`    1000 modules: ${time1000.toFixed(3)}ms`);\n\n      // Should not degrade significantly with policy size\n      // Using generous threshold (3x) to account for JIT warmup on first run\n      // Should tighten to 1.2x on subsequent runs once caches are warm\n      assert.ok(\n        time1000 < time10 * 3,\n        `1000-module policy should not be > 3x slower than 10-module (was ${(time1000 / time10).toFixed(1)}x)`\n      );\n    });\n\n    test(\"should handle multiple exact matches efficiently\", async () => {\n      const avgTime = await benchmark(\"Multiple exact matches (6 modules)\", 1000, async () => {\n        await validateModuleIds(\n          [\n            \"policy/scanners\",\n            \"shared/types\",\n            \"shared/policy\",\n            \"memory/mcp\",\n            \"services/auth-core\",\n            \"ui/main-panel\",\n          ],\n          policy100\n        );\n      });\n\n      assert.ok(\n        avgTime < 1.0,\n        `Multiple exact matches took ${avgTime.toFixed(3)}ms, expected <1.0ms`\n      );\n    });\n  });\n\n  describe(\"Fuzzy Match Path (Worst Case)\", () => {\n    test(\"should handle typos with fuzzy matching (<2ms)\", async () => {\n      const avgTime = await benchmark(\"Fuzzy match for typo\", 1000, async () => {\n        await validateModuleIds([\"indexr\"], policy10); // Typo: \"indexr\" instead of \"policy/scanners\"\n      });\n\n      console.log(`  Note: Result is invalid, but fuzzy matching provides suggestions`);\n\n      assert.ok(avgTime < 2.0, `Fuzzy matching took ${avgTime.toFixed(3)}ms, expected <2.0ms`);\n    });\n\n    test(\"should handle completely invalid input (<3ms)\", async () => {\n      const avgTime = await benchmark(\"Fuzzy match for invalid module\", 1000, async () => {\n        await validateModuleIds([\"nonexistent-module-xyz\"], policy10);\n      });\n\n      assert.ok(\n        avgTime < 3.0,\n        `Invalid module handling took ${avgTime.toFixed(3)}ms, expected <3.0ms`\n      );\n    });\n\n    test(\"should not degrade badly with large policy\", async () => {\n      const avgTime = await benchmark(\n        \"Fuzzy match with 1000 module policy\",\n        100, // Fewer iterations since this is slower\n        async () => {\n          await validateModuleIds([\"indexr\"], policy1000);\n        }\n      );\n\n      // Fuzzy matching needs to check all modules, so O(n)\n      // But should still be reasonably fast\n      assert.ok(\n        avgTime < 10.0,\n        `Fuzzy matching with 1000 modules took ${avgTime.toFixed(3)}ms, expected <10ms`\n      );\n    });\n  });\n\n  describe(\"Mixed Case (Realistic Workload)\", () => {\n    test(\"should handle mix of valid and invalid efficiently\", async () => {\n      const avgTime = await benchmark(\"Mixed valid/invalid modules\", 1000, async () => {\n        // 2 valid, 1 invalid - realistic typo scenario\n        await validateModuleIds([\"policy/scanners\", \"shared/types\", \"invalidmodule\"], policy100);\n      });\n\n      assert.ok(avgTime < 2.0, `Mixed validation took ${avgTime.toFixed(3)}ms, expected <2.0ms`);\n    });\n\n    test(\"should validate empty module scope instantly\", async () => {\n      const avgTime = await benchmark(\"Empty module scope validation\", 10000, async () => {\n        await validateModuleIds([], policy100);\n      });\n\n      assert.ok(avgTime < 0.1, `Empty validation took ${avgTime.toFixed(3)}ms, expected <0.1ms`);\n    });\n  });\n\n  describe(\"Memory Overhead\", () => {\n    test(\"should report policy cache size\", () => {\n      const policyJson = JSON.stringify(policy100);\n      const sizeKB = Buffer.byteLength(policyJson) / 1024;\n\n      console.log(`  Policy cache size (100 modules): ${sizeKB.toFixed(2)}KB`);\n\n      assert.ok(sizeKB < 50, `Policy cache of ${sizeKB.toFixed(2)}KB exceeds 50KB limit`);\n    });\n\n    test(\"should report large policy cache size\", () => {\n      const policyJson = JSON.stringify(policy1000);\n      const sizeKB = Buffer.byteLength(policyJson) / 1024;\n\n      console.log(`  Policy cache size (1000 modules): ${sizeKB.toFixed(2)}KB`);\n\n      assert.ok(sizeKB < 500, `Large policy cache of ${sizeKB.toFixed(2)}KB exceeds 500KB limit`);\n    });\n  });\n\n  describe(\"Summary\", () => {\n    test(\"should print performance summary\", () => {\n      console.log(\"\\n  ═══════════════════════════════════════\");\n      console.log(\"  Alias Resolution Performance Summary\");\n      console.log(\"  ═══════════════════════════════════════\");\n      console.log(\"  ✓ Exact match: <0.5ms (unchanged from baseline)\");\n      console.log(\"  ✓ Fuzzy matching: <2ms (only on mismatch)\");\n      console.log(\"  ✓ Large policy (1000 modules): <10ms fuzzy\");\n      console.log(\"  ✓ Performance regression: Minimal on happy path\");\n      console.log(\"  ✓ Memory overhead: <10KB typical, <500KB max\");\n      console.log(\"  ═══════════════════════════════════════\\n\");\n\n      assert.ok(true, \"Summary displayed\");\n    });\n  });\n});\n\nconsole.log(\"\\n✅ Alias Resolution Benchmarks - Performance targets met\\n\");\n","usedDeprecatedRules":[]},{"filePath":"/srv/lex-mcp/lex/test/memory/mcp_server/alias-integration.test.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'before' is defined but never used. Allowed unused vars must match /^_/u.","line":15,"column":26,"nodeType":null,"messageId":"unusedVar","endLine":15,"endColumn":32},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'after' is defined but never used. Allowed unused vars must match /^_/u.","line":15,"column":34,"nodeType":null,"messageId":"unusedVar","endLine":15,"endColumn":39},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'e' is defined but never used.","line":59,"column":16,"nodeType":null,"messageId":"unusedVar","endLine":59,"endColumn":17},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":1,"message":"Unsafe call of a(n) `any` typed value.","line":85,"column":19,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":85,"endColumn":52},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .text on an `any` value.","line":85,"column":39,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":85,"endColumn":43},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":1,"message":"Unsafe call of a(n) `any` typed value.","line":89,"column":12,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":89,"endColumn":59},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":1,"message":"Unsafe call of a(n) `any` typed value.","line":89,"column":12,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":89,"endColumn":48},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .text on an `any` value.","line":89,"column":32,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":89,"endColumn":36},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .includes on an `any` value.","line":89,"column":51,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":89,"endColumn":59},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":1,"message":"Unsafe call of a(n) `any` typed value.","line":116,"column":19,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":116,"endColumn":52},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .text on an `any` value.","line":116,"column":39,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":116,"endColumn":43},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":1,"message":"Unsafe call of a(n) `any` typed value.","line":449,"column":11,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":449,"endColumn":50},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .text on an `any` value.","line":449,"column":37,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":449,"endColumn":41},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":1,"message":"Unsafe call of a(n) `any` typed value.","line":453,"column":11,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":453,"endColumn":50},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .text on an `any` value.","line":453,"column":37,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":453,"endColumn":41}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":15,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Alias Resolution Integration Tests for MCP Server\n *\n * Tests the full MCP /remember flow with module ID validation and fuzzy matching.\n * These tests verify:\n * - Exact matches work without warnings\n * - Typos trigger helpful suggestions\n * - Substring matching (future: could suggest modules)\n * - Ambiguous matches are rejected\n * - Strict mode (CI) only allows exact matches\n *\n * Run with: npm run build && node --test dist/alias-integration.test.js\n */\n\nimport { test, describe, before, after } from \"node:test\";\nimport assert from \"node:assert\";\nimport { MCPServer } from \"@app/memory/mcp_server/server.js\";\nimport { mkdtempSync, mkdirSync, rmSync, writeFileSync } from \"fs\";\nimport { join } from \"path\";\nimport { tmpdir } from \"os\";\n\ndescribe(\"MCP Server Alias Resolution Integration Tests\", () => {\n  let server: MCPServer;\n  let testDbPath: string;\n  let testRepoRoot: string;\n\n  function setup() {\n    const tmpDir = mkdtempSync(join(tmpdir(), \"mcp-alias-test-\"));\n    testDbPath = join(tmpDir, \"alias-test.db\");\n    testRepoRoot = tmpDir;\n\n    // Create minimal test policy structure\n    const policyDir = join(tmpDir, \"policy\", \"policy_spec\");\n    mkdirSync(policyDir, { recursive: true });\n\n    const testPolicy = {\n      modules: {\n        \"policy/scanners\": { owns_paths: [\"src/policy/scanners/**\"] },\n        \"shared/types\": { owns_paths: [\"src/shared/types/**\"] },\n        \"memory/mcp\": { owns_paths: [\"src/memory/mcp_server/**\"] },\n        \"services/auth-core\": { owns_paths: [\"services/auth/**\"] },\n        \"ui/main-panel\": { owns_paths: [\"ui/main/**\"] },\n      },\n    };\n\n    writeFileSync(join(policyDir, \"lexmap.policy.json\"), JSON.stringify(testPolicy, null, 2));\n\n    server = new MCPServer(testDbPath, testRepoRoot);\n    return server;\n  }\n\n  function teardown() {\n    if (server) {\n      server.close();\n    }\n    if (testRepoRoot) {\n      try {\n        rmSync(testRepoRoot, { force: true, recursive: true });\n      } catch (e) {\n        // Ignore cleanup errors\n      }\n    }\n  }\n\n  describe(\"Test 1: Exact Match (Baseline)\", () => {\n    test(\"should accept exact module ID without warnings\", async () => {\n      const srv = setup();\n      try {\n        const response = await srv.handleRequest({\n          method: \"tools/call\",\n          params: {\n            name: \"lex.remember\",\n            arguments: {\n              reference_point: \"Testing exact match\",\n              summary_caption: \"Exact module ID match test\",\n              status_snapshot: {\n                next_action: \"Verify no warnings\",\n              },\n              module_scope: [\"services/auth-core\"], // Exact match\n            },\n          },\n        });\n\n        assert.ok(response.content, \"Should succeed with exact match\");\n        assert.ok(response.content[0].text.includes(\"✅ Frame stored\"), \"Should confirm storage\");\n\n        // Exact matches should not produce warnings\n        assert.ok(\n          !response.content[0].text.toLowerCase().includes(\"warning\"),\n          \"Should not have warnings for exact match\"\n        );\n      } finally {\n        teardown();\n      }\n    });\n\n    test(\"should accept multiple exact matches\", async () => {\n      const srv = setup();\n      try {\n        const response = await srv.handleRequest({\n          method: \"tools/call\",\n          params: {\n            name: \"lex.remember\",\n            arguments: {\n              reference_point: \"Multiple exact modules\",\n              summary_caption: \"Testing multiple exact matches\",\n              status_snapshot: {\n                next_action: \"Continue\",\n              },\n              module_scope: [\"policy/scanners\", \"shared/types\", \"services/auth-core\"],\n            },\n          },\n        });\n\n        assert.ok(response.content, \"Should succeed with multiple exact matches\");\n        assert.ok(response.content[0].text.includes(\"✅ Frame stored\"), \"Should confirm storage\");\n      } finally {\n        teardown();\n      }\n    });\n  });\n\n  describe(\"Test 2: Typo Correction\", () => {\n    test(\"should reject typo with helpful suggestion\", async () => {\n      const srv = setup();\n      try {\n        const response = await srv.handleRequest({\n          method: \"tools/call\",\n          params: {\n            name: \"lex.remember\",\n            arguments: {\n              reference_point: \"Testing typo correction\",\n              summary_caption: \"Typo in module ID\",\n              status_snapshot: {\n                next_action: \"Fix typo\",\n              },\n              module_scope: [\"policy/scannrs\"], // Typo: should be \"policy/scanners\"\n            },\n          },\n        });\n\n        assert.ok(response.error, \"Should return error for typo\");\n        assert.ok(response.error.message.includes(\"scannrs\"), \"Error should mention the typo\");\n        assert.ok(response.error.message.includes(\"Did you mean\"), \"Should provide suggestion\");\n        assert.ok(\n          response.error.message.includes(\"policy/scanners\"),\n          \"Should suggest 'policy/scanners'\"\n        );\n      } finally {\n        teardown();\n      }\n    });\n\n    test(\"should suggest closest match for common typos\", async () => {\n      const srv = setup();\n      try {\n        const response = await srv.handleRequest({\n          method: \"tools/call\",\n          params: {\n            name: \"lex.remember\",\n            arguments: {\n              reference_point: \"Testing fuzzy matching\",\n              summary_caption: \"Common typo test\",\n              status_snapshot: {\n                next_action: \"Use suggested module\",\n              },\n              module_scope: [\"servcies/auth-core\"], // Typo: should be \"services/auth-core\"\n            },\n          },\n        });\n\n        assert.ok(response.error, \"Should return error for typo\");\n        assert.ok(response.error.message.includes(\"Did you mean\"), \"Should provide suggestion\");\n        assert.ok(\n          response.error.message.includes(\"services/auth-core\"),\n          \"Should suggest correct module\"\n        );\n      } finally {\n        teardown();\n      }\n    });\n  });\n\n  describe(\"Test 3: Substring/Shorthand Matching\", () => {\n    test(\"should reject substring without exact match\", async () => {\n      const srv = setup();\n      try {\n        const response = await srv.handleRequest({\n          method: \"tools/call\",\n          params: {\n            name: \"lex.remember\",\n            arguments: {\n              reference_point: \"Testing substring\",\n              summary_caption: \"Substring module reference\",\n              status_snapshot: {\n                next_action: \"Use full module ID\",\n              },\n              module_scope: [\"auth\"], // Substring of \"services/auth-core\"\n            },\n          },\n        });\n\n        assert.ok(response.error, \"Should reject substring match\");\n        assert.ok(response.error.message.includes(\"auth\"), \"Error should mention the input\");\n        // Future: Could suggest \"services/auth-core\" as it contains \"auth\"\n      } finally {\n        teardown();\n      }\n    });\n\n    test(\"should handle shorthand notation as error\", async () => {\n      const srv = setup();\n      try {\n        const response = await srv.handleRequest({\n          method: \"tools/call\",\n          params: {\n            name: \"lex.remember\",\n            arguments: {\n              reference_point: \"Testing shorthand\",\n              summary_caption: \"Shorthand module ID\",\n              status_snapshot: {\n                next_action: \"Use canonical ID\",\n              },\n              module_scope: [\"auth-core\"], // Shorthand, missing \"services/\" prefix\n            },\n          },\n        });\n\n        assert.ok(response.error, \"Should reject shorthand notation\");\n        assert.ok(\n          response.error.message.includes(\"auth-core\"),\n          \"Error should mention shorthand input\"\n        );\n        // May or may not suggest the full path depending on edit distance\n      } finally {\n        teardown();\n      }\n    });\n  });\n\n  describe(\"Test 4: Ambiguous Matches\", () => {\n    test(\"should reject very short ambiguous inputs\", async () => {\n      const srv = setup();\n      try {\n        const response = await srv.handleRequest({\n          method: \"tools/call\",\n          params: {\n            name: \"lex.remember\",\n            arguments: {\n              reference_point: \"Testing ambiguous input\",\n              summary_caption: \"Ambiguous module reference\",\n              status_snapshot: {\n                next_action: \"Be more specific\",\n              },\n              module_scope: [\"t\"], // Could match \"shared/types\" or part of others\n            },\n          },\n        });\n\n        assert.ok(response.error, \"Should reject ambiguous input\");\n        assert.ok(\n          response.error.message.includes(\"Available modules\"),\n          \"Should list available modules\"\n        );\n      } finally {\n        teardown();\n      }\n    });\n\n    test(\"should list available modules on error\", async () => {\n      const srv = setup();\n      try {\n        const response = await srv.handleRequest({\n          method: \"tools/call\",\n          params: {\n            name: \"lex.remember\",\n            arguments: {\n              reference_point: \"Testing module list\",\n              summary_caption: \"Invalid module test\",\n              status_snapshot: {\n                next_action: \"Check available modules\",\n              },\n              module_scope: [\"nonexistent\"],\n            },\n          },\n        });\n\n        assert.ok(response.error, \"Should return error\");\n        assert.ok(\n          response.error.message.includes(\"Available modules\"),\n          \"Should list available modules\"\n        );\n        assert.ok(\n          response.error.message.includes(\"policy/scanners\"),\n          \"Should include 'policy/scanners' in available modules\"\n        );\n        assert.ok(\n          response.error.message.includes(\"services/auth-core\"),\n          \"Should include 'services/auth-core' in available modules\"\n        );\n      } finally {\n        teardown();\n      }\n    });\n  });\n\n  describe(\"Test 5: Mixed Valid/Invalid Modules\", () => {\n    test(\"should report all invalid modules in one error\", async () => {\n      const srv = setup();\n      try {\n        const response = await srv.handleRequest({\n          method: \"tools/call\",\n          params: {\n            name: \"lex.remember\",\n            arguments: {\n              reference_point: \"Testing mixed modules\",\n              summary_caption: \"Mix of valid and invalid\",\n              status_snapshot: {\n                next_action: \"Fix invalid modules\",\n              },\n              module_scope: [\"policy/scanners\", \"invalid1\", \"shared/types\", \"invalid2\"],\n            },\n          },\n        });\n\n        assert.ok(response.error, \"Should return error for invalid modules\");\n        assert.ok(\n          response.error.message.includes(\"invalid1\"),\n          \"Should mention first invalid module\"\n        );\n        assert.ok(\n          response.error.message.includes(\"invalid2\"),\n          \"Should mention second invalid module\"\n        );\n      } finally {\n        teardown();\n      }\n    });\n  });\n\n  describe(\"Performance Validation\", () => {\n    test(\"should validate modules quickly (<10ms)\", async () => {\n      const srv = setup();\n      try {\n        const start = performance.now();\n\n        await srv.handleRequest({\n          method: \"tools/call\",\n          params: {\n            name: \"lex.remember\",\n            arguments: {\n              reference_point: \"Performance test\",\n              summary_caption: \"Testing validation performance\",\n              status_snapshot: {\n                next_action: \"Measure time\",\n              },\n              module_scope: [\"policy/scanners\", \"shared/types\", \"memory/mcp\"],\n            },\n          },\n        });\n\n        const elapsed = performance.now() - start;\n\n        console.log(`  Module validation time: ${elapsed.toFixed(2)}ms`);\n        // Allow up to 50ms (generous threshold for CI/test environments with GC variance)\n        // Typical runs are <10ms, but first runs may be slower due to JIT warmup\n        assert.ok(elapsed < 50, `Validation took ${elapsed.toFixed(2)}ms, expected <50ms`);\n      } finally {\n        teardown();\n      }\n    });\n\n    test(\"should handle large module scopes efficiently\", async () => {\n      const srv = setup();\n      try {\n        const start = performance.now();\n\n        await srv.handleRequest({\n          method: \"tools/call\",\n          params: {\n            name: \"lex.remember\",\n            arguments: {\n              reference_point: \"Large scope test\",\n              summary_caption: \"Testing with many modules\",\n              status_snapshot: {\n                next_action: \"Continue\",\n              },\n              module_scope: [\n                \"policy/scanners\",\n                \"shared/types\",\n                \"shared/policy\",\n                \"memory/mcp\",\n                \"services/auth-core\",\n                \"ui/main-panel\",\n              ],\n            },\n          },\n        });\n\n        const elapsed = performance.now() - start;\n\n        console.log(`  Large scope validation time: ${elapsed.toFixed(2)}ms`);\n        assert.ok(\n          elapsed < 15,\n          `Large scope validation took ${elapsed.toFixed(2)}ms, expected <15ms`\n        );\n      } finally {\n        teardown();\n      }\n    });\n  });\n\n  describe(\"End-to-End Flow\", () => {\n    test(\"should complete full /remember → recall cycle with validation\", async () => {\n      const srv = setup();\n      try {\n        // Step 1: Remember with valid modules\n        const rememberResponse = await srv.handleRequest({\n          method: \"tools/call\",\n          params: {\n            name: \"lex.remember\",\n            arguments: {\n              reference_point: \"E2E test with validation\",\n              summary_caption: \"End-to-end alias flow\",\n              status_snapshot: {\n                next_action: \"Recall and verify\",\n              },\n              module_scope: [\"services/auth-core\", \"ui/main-panel\"],\n              keywords: [\"e2e\", \"validation\"],\n            },\n          },\n        });\n\n        assert.ok(rememberResponse.content, \"Remember should succeed\");\n\n        // Step 2: Recall the frame\n        const recallResponse = await srv.handleRequest({\n          method: \"tools/call\",\n          params: {\n            name: \"lex.recall\",\n            arguments: {\n              reference_point: \"E2E test\",\n            },\n          },\n        });\n\n        assert.ok(recallResponse.content, \"Recall should succeed\");\n        assert.ok(\n          recallResponse.content[0].text.includes(\"E2E test with validation\"),\n          \"Should find the frame\"\n        );\n        assert.ok(\n          recallResponse.content[0].text.includes(\"services/auth-core\"),\n          \"Should include module scope\"\n        );\n      } finally {\n        teardown();\n      }\n    });\n  });\n});\n\nconsole.log(\"\\n✅ Alias Resolution Integration Tests - Module validation flow\\n\");\n","usedDeprecatedRules":[]},{"filePath":"/srv/lex-mcp/lex/test/memory/mcp_server/integration.test.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'before' is defined but never used. Allowed unused vars must match /^_/u.","line":14,"column":26,"nodeType":null,"messageId":"unusedVar","endLine":14,"endColumn":32},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'after' is defined but never used. Allowed unused vars must match /^_/u.","line":14,"column":34,"nodeType":null,"messageId":"unusedVar","endLine":14,"endColumn":39},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'e' is defined but never used.","line":39,"column":16,"nodeType":null,"messageId":"unusedVar","endLine":39,"endColumn":17},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":1,"message":"Unsafe call of a(n) `any` typed value.","line":71,"column":11,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":71,"endColumn":52},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .text on an `any` value.","line":71,"column":39,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":71,"endColumn":43},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":1,"message":"Unsafe call of a(n) `any` typed value.","line":88,"column":11,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":88,"endColumn":50},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .text on an `any` value.","line":88,"column":37,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":88,"endColumn":41},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":1,"message":"Unsafe call of a(n) `any` typed value.","line":92,"column":11,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":92,"endColumn":50},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .text on an `any` value.","line":92,"column":37,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":92,"endColumn":41},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":1,"message":"Unsafe call of a(n) `any` typed value.","line":140,"column":11,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":140,"endColumn":48},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .text on an `any` value.","line":140,"column":35,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":140,"endColumn":39},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":1,"message":"Unsafe call of a(n) `any` typed value.","line":157,"column":11,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":157,"endColumn":50},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .text on an `any` value.","line":157,"column":37,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":157,"endColumn":41},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":1,"message":"Unsafe call of a(n) `any` typed value.","line":241,"column":19,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":241,"endColumn":52},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .text on an `any` value.","line":241,"column":39,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":241,"endColumn":43},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":1,"message":"Unsafe call of a(n) `any` typed value.","line":279,"column":11,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":279,"endColumn":50},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .text on an `any` value.","line":279,"column":37,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":279,"endColumn":41},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":1,"message":"Unsafe call of a(n) `any` typed value.","line":317,"column":11,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":317,"endColumn":49},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .text on an `any` value.","line":317,"column":36,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":317,"endColumn":40},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":1,"message":"Unsafe call of a(n) `any` typed value.","line":334,"column":11,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":334,"endColumn":49},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .text on an `any` value.","line":334,"column":36,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":334,"endColumn":40},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":1,"message":"Unsafe call of a(n) `any` typed value.","line":372,"column":11,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":372,"endColumn":50},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .text on an `any` value.","line":372,"column":37,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":372,"endColumn":41},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":1,"message":"Unsafe call of a(n) `any` typed value.","line":426,"column":11,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":426,"endColumn":50},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .text on an `any` value.","line":426,"column":37,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":426,"endColumn":41},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":1,"message":"Unsafe call of a(n) `any` typed value.","line":430,"column":12,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":430,"endColumn":51},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .text on an `any` value.","line":430,"column":38,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":430,"endColumn":42},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":1,"message":"Unsafe call of a(n) `any` typed value.","line":470,"column":11,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":470,"endColumn":51},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .text on an `any` value.","line":470,"column":38,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":470,"endColumn":42},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":1,"message":"Unsafe call of a(n) `any` typed value.","line":519,"column":11,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":519,"endColumn":44},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .text on an `any` value.","line":519,"column":31,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":519,"endColumn":35},{"ruleId":"@typescript-eslint/no-unsafe-return","severity":1,"message":"Unsafe return of a value of type `any`.","line":595,"column":53,"nodeType":"MemberExpression","messageId":"unsafeReturn","endLine":595,"endColumn":59},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .name on an `any` value.","line":595,"column":55,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":595,"endColumn":59},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":1,"message":"Unsafe assignment of an `any` value.","line":611,"column":15,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":611,"endColumn":84},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .name on an `any` value.","line":611,"column":60,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":611,"endColumn":64},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .inputSchema on an `any` value.","line":613,"column":32,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":613,"endColumn":43},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .inputSchema on an `any` value.","line":614,"column":32,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":614,"endColumn":43}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":37,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Integration tests for MCP Server\n *\n * Tests the full MCP protocol integration:\n * - Full request/response cycle\n * - Real validation and error handling\n * - FTS5 search integration\n * - Frame filtering\n * - Module validation integration\n *\n * Run with: npm run build && node --test dist/integration.test.js\n */\n\nimport { test, describe, before, after } from \"node:test\";\nimport assert from \"node:assert\";\nimport { MCPServer } from \"@app/memory/mcp_server/server.js\";\nimport { mkdtempSync, rmSync } from \"fs\";\nimport { join } from \"path\";\nimport { tmpdir } from \"os\";\n\ndescribe(\"MCP Server Integration Tests\", () => {\n  let server: MCPServer;\n  let testDbPath: string;\n\n  function setup() {\n    const tmpDir = mkdtempSync(join(tmpdir(), \"mcp-integration-\"));\n    testDbPath = join(tmpDir, \"integration-test.db\");\n    server = new MCPServer(testDbPath);\n    return server;\n  }\n\n  function teardown() {\n    if (server) {\n      server.close();\n    }\n    if (testDbPath) {\n      try {\n        rmSync(testDbPath, { force: true });\n      } catch (e) {\n        // Ignore cleanup errors\n      }\n    }\n  }\n\n  describe(\"Full Request/Response Cycle\", () => {\n    test(\"should complete full remember → recall cycle\", async () => {\n      const srv = setup();\n      try {\n        // Step 1: Create a Frame via lex.remember\n        const rememberArgs = {\n          reference_point: \"integration cycle test\",\n          summary_caption: \"Testing full MCP cycle\",\n          status_snapshot: {\n            next_action: \"Verify recall works\",\n            blockers: [],\n          },\n          module_scope: [\"policy/scanners\"],\n          keywords: [\"integration\", \"memory/mcp\", \"cycle\"],\n        };\n\n        const rememberResponse = await srv.handleRequest({\n          method: \"tools/call\",\n          params: {\n            name: \"lex.remember\",\n            arguments: rememberArgs,\n          },\n        });\n\n        assert.ok(rememberResponse.content, \"Remember should succeed\");\n        assert.ok(\n          rememberResponse.content[0].text.includes(\"✅ Frame stored\"),\n          \"Should confirm storage\"\n        );\n\n        // Step 2: Recall the Frame\n        const recallResponse = await srv.handleRequest({\n          method: \"tools/call\",\n          params: {\n            name: \"lex.recall\",\n            arguments: {\n              reference_point: \"integration cycle\",\n            },\n          },\n        });\n\n        assert.ok(recallResponse.content, \"Recall should succeed\");\n        assert.ok(\n          recallResponse.content[0].text.includes(\"Found 1 Frame\"),\n          \"Should find the Frame\"\n        );\n        assert.ok(\n          recallResponse.content[0].text.includes(\"integration cycle test\"),\n          \"Should include reference point\"\n        );\n      } finally {\n        teardown();\n      }\n    });\n\n    test(\"should handle create → list → recall → delete cycle\", async () => {\n      const srv = setup();\n      try {\n        // Create multiple frames\n        const frames = [\n          {\n            reference_point: \"first frame\",\n            summary_caption: \"First test frame\",\n            status_snapshot: { next_action: \"Test\" },\n            module_scope: [\"policy/scanners\"],\n          },\n          {\n            reference_point: \"second frame\",\n            summary_caption: \"Second test frame\",\n            status_snapshot: { next_action: \"Test\" },\n            module_scope: [\"shared/types\"],\n          },\n        ];\n\n        for (const frame of frames) {\n          await srv.handleRequest({\n            method: \"tools/call\",\n            params: {\n              name: \"lex.remember\",\n              arguments: frame,\n            },\n          });\n        }\n\n        // List frames\n        const listResponse = await srv.handleRequest({\n          method: \"tools/call\",\n          params: {\n            name: \"lex.list_frames\",\n            arguments: { limit: 10 },\n          },\n        });\n\n        assert.ok(listResponse.content, \"List should succeed\");\n        assert.ok(\n          listResponse.content[0].text.includes(\"Recent Frames (2)\"),\n          \"Should list both frames\"\n        );\n\n        // Recall specific frame\n        const recallResponse = await srv.handleRequest({\n          method: \"tools/call\",\n          params: {\n            name: \"lex.recall\",\n            arguments: {\n              reference_point: \"first frame\",\n            },\n          },\n        });\n\n        assert.ok(recallResponse.content, \"Response should have content\");\n        assert.ok(\n          recallResponse.content[0].text.includes(\"first frame\"),\n          \"Should find specific frame\"\n        );\n      } finally {\n        teardown();\n      }\n    });\n  });\n\n  describe(\"Module Validation Integration\", () => {\n    test(\"should reject invalid module IDs with helpful error\", async () => {\n      const srv = setup();\n      try {\n        const response = await srv.handleRequest({\n          method: \"tools/call\",\n          params: {\n            name: \"lex.remember\",\n            arguments: {\n              reference_point: \"invalid module test\",\n              summary_caption: \"Testing validation\",\n              status_snapshot: { next_action: \"Should fail\" },\n              module_scope: [\"invalid-module-xyz\"],\n            },\n          },\n        });\n\n        assert.ok(response.error, \"Should return error\");\n        assert.ok(\n          response.error.message.includes(\"Invalid module IDs\"),\n          \"Should indicate invalid modules\"\n        );\n        assert.ok(\n          response.error.message.includes(\"invalid-module-xyz\"),\n          \"Should mention the invalid module\"\n        );\n        assert.ok(\n          response.error.message.includes(\"Available modules\"),\n          \"Should list available modules\"\n        );\n      } finally {\n        teardown();\n      }\n    });\n\n    test(\"should suggest similar modules for typos\", async () => {\n      const srv = setup();\n      try {\n        const response = await srv.handleRequest({\n          method: \"tools/call\",\n          params: {\n            name: \"lex.remember\",\n            arguments: {\n              reference_point: \"typo test\",\n              summary_caption: \"Testing fuzzy matching\",\n              status_snapshot: { next_action: \"Test\" },\n              module_scope: [\"indexr\"], // Typo: should be \"policy/scanners\"\n            },\n          },\n        });\n\n        assert.ok(response.error, \"Should return error\");\n        assert.ok(response.error.message.includes(\"Did you mean\"), \"Should provide suggestions\");\n      } finally {\n        teardown();\n      }\n    });\n\n    test(\"should accept all valid modules\", async () => {\n      const srv = setup();\n      try {\n        const response = await srv.handleRequest({\n          method: \"tools/call\",\n          params: {\n            name: \"lex.remember\",\n            arguments: {\n              reference_point: \"all valid modules\",\n              summary_caption: \"Testing with all valid modules\",\n              status_snapshot: { next_action: \"Test\" },\n              module_scope: [\"policy/scanners\", \"shared/types\", \"memory/mcp\"],\n            },\n          },\n        });\n\n        assert.ok(response.content, \"Should succeed with valid modules\");\n        assert.ok(response.content[0].text.includes(\"✅ Frame stored\"), \"Should confirm storage\");\n      } finally {\n        teardown();\n      }\n    });\n  });\n\n  describe(\"FTS5 Search Integration\", () => {\n    test(\"should find Frames using full-text search on reference_point\", async () => {\n      const srv = setup();\n      try {\n        // Create frames with different content\n        await srv.handleRequest({\n          method: \"tools/call\",\n          params: {\n            name: \"lex.remember\",\n            arguments: {\n              reference_point: \"authentication refactoring work\",\n              summary_caption: \"Refactored auth system\",\n              status_snapshot: { next_action: \"Test\" },\n              module_scope: [\"policy/scanners\"],\n            },\n          },\n        });\n\n        // Search should find it\n        const searchResponse = await srv.handleRequest({\n          method: \"tools/call\",\n          params: {\n            name: \"lex.recall\",\n            arguments: {\n              reference_point: \"authentication refactoring\",\n            },\n          },\n        });\n\n        assert.ok(searchResponse.content, \"Search should succeed\");\n        assert.ok(\n          searchResponse.content[0].text.includes(\"authentication refactoring work\"),\n          \"Should find frame via FTS5\"\n        );\n      } finally {\n        teardown();\n      }\n    });\n\n    test(\"should search across summary_caption and keywords\", async () => {\n      const srv = setup();\n      try {\n        await srv.handleRequest({\n          method: \"tools/call\",\n          params: {\n            name: \"lex.remember\",\n            arguments: {\n              reference_point: \"payment system\",\n              summary_caption: \"Stripe integration for payment processing\",\n              status_snapshot: { next_action: \"Deploy\" },\n              module_scope: [\"policy/scanners\"],\n              keywords: [\"payment\", \"stripe\", \"integration\"],\n            },\n          },\n        });\n\n        // Search by keyword\n        const keywordSearch = await srv.handleRequest({\n          method: \"tools/call\",\n          params: {\n            name: \"lex.recall\",\n            arguments: {\n              reference_point: \"stripe\",\n            },\n          },\n        });\n\n        assert.ok(keywordSearch.content, \"Keyword search should have content\");\n        assert.ok(\n          keywordSearch.content[0].text.includes(\"payment system\"),\n          \"Should find via keyword search\"\n        );\n\n        // Search by summary\n        const summarySearch = await srv.handleRequest({\n          method: \"tools/call\",\n          params: {\n            name: \"lex.recall\",\n            arguments: {\n              reference_point: \"integration processing\",\n            },\n          },\n        });\n\n        assert.ok(summarySearch.content, \"Summary search should have content\");\n        assert.ok(\n          summarySearch.content[0].text.includes(\"payment system\"),\n          \"Should find via summary search\"\n        );\n      } finally {\n        teardown();\n      }\n    });\n\n    test(\"should handle fuzzy search with wildcards\", async () => {\n      const srv = setup();\n      try {\n        await srv.handleRequest({\n          method: \"tools/call\",\n          params: {\n            name: \"lex.remember\",\n            arguments: {\n              reference_point: \"database optimization\",\n              summary_caption: \"Optimized database queries\",\n              status_snapshot: { next_action: \"Benchmark\" },\n              module_scope: [\"policy/scanners\"],\n              keywords: [\"database\", \"performance\"],\n            },\n          },\n        });\n\n        // Wildcard search\n        const wildcardSearch = await srv.handleRequest({\n          method: \"tools/call\",\n          params: {\n            name: \"lex.recall\",\n            arguments: {\n              reference_point: \"datab*\",\n            },\n          },\n        });\n\n        assert.ok(wildcardSearch.content, \"Wildcard search should have content\");\n        assert.ok(\n          wildcardSearch.content[0].text.includes(\"database optimization\"),\n          \"Should support wildcard search\"\n        );\n      } finally {\n        teardown();\n      }\n    });\n  });\n\n  describe(\"Frame Filtering\", () => {\n    test(\"should filter frames by module scope\", async () => {\n      const srv = setup();\n      try {\n        // Create frames with different modules\n        await srv.handleRequest({\n          method: \"tools/call\",\n          params: {\n            name: \"lex.remember\",\n            arguments: {\n              reference_point: \"indexer work\",\n              summary_caption: \"Indexer module\",\n              status_snapshot: { next_action: \"Test\" },\n              module_scope: [\"policy/scanners\"],\n            },\n          },\n        });\n\n        await srv.handleRequest({\n          method: \"tools/call\",\n          params: {\n            name: \"lex.remember\",\n            arguments: {\n              reference_point: \"typescript work\",\n              summary_caption: \"TS module\",\n              status_snapshot: { next_action: \"Test\" },\n              module_scope: [\"shared/types\"],\n            },\n          },\n        });\n\n        // Filter by module\n        const filterResponse = await srv.handleRequest({\n          method: \"tools/call\",\n          params: {\n            name: \"lex.list_frames\",\n            arguments: {\n              module: \"policy/scanners\",\n              limit: 10,\n            },\n          },\n        });\n\n        assert.ok(filterResponse.content, \"Filter response should have content\");\n        assert.ok(\n          filterResponse.content[0].text.includes(\"indexer work\"),\n          \"Should include indexer frame\"\n        );\n        assert.ok(\n          !filterResponse.content[0].text.includes(\"typescript work\"),\n          \"Should not include ts frame\"\n        );\n      } finally {\n        teardown();\n      }\n    });\n\n    test(\"should limit results when requested\", async () => {\n      const srv = setup();\n      try {\n        // Create multiple frames\n        for (let i = 0; i < 5; i++) {\n          await srv.handleRequest({\n            method: \"tools/call\",\n            params: {\n              name: \"lex.remember\",\n              arguments: {\n                reference_point: `frame ${i}`,\n                summary_caption: `Frame ${i}`,\n                status_snapshot: { next_action: \"Test\" },\n                module_scope: [\"policy/scanners\"],\n              },\n            },\n          });\n        }\n\n        // Request limited results\n        const limitedResponse = await srv.handleRequest({\n          method: \"tools/call\",\n          params: {\n            name: \"lex.list_frames\",\n            arguments: {\n              limit: 3,\n            },\n          },\n        });\n\n        assert.ok(limitedResponse.content, \"Limited response should have content\");\n        assert.ok(\n          limitedResponse.content[0].text.includes(\"Recent Frames (3)\"),\n          \"Should respect limit parameter\"\n        );\n      } finally {\n        teardown();\n      }\n    });\n  });\n\n  describe(\"Error Handling\", () => {\n    test(\"should handle missing required fields gracefully\", async () => {\n      const srv = setup();\n      try {\n        const response = await srv.handleRequest({\n          method: \"tools/call\",\n          params: {\n            name: \"lex.remember\",\n            arguments: {\n              reference_point: \"incomplete\",\n              // Missing: summary_caption, status_snapshot, module_scope\n            },\n          },\n        });\n\n        assert.ok(response.error, \"Should return error\");\n        assert.ok(\n          response.error.message.includes(\"Missing required fields\"),\n          \"Should indicate missing fields\"\n        );\n      } finally {\n        teardown();\n      }\n    });\n\n    test(\"should handle empty search results\", async () => {\n      const srv = setup();\n      try {\n        const response = await srv.handleRequest({\n          method: \"tools/call\",\n          params: {\n            name: \"lex.recall\",\n            arguments: {\n              reference_point: \"zzz-nonexistent-query-zzz\",\n            },\n          },\n        });\n\n        assert.ok(response.content, \"Should return content\");\n        assert.ok(\n          response.content[0].text.includes(\"No matching Frames found\"),\n          \"Should indicate no results\"\n        );\n      } finally {\n        teardown();\n      }\n    });\n\n    test(\"should require at least one search parameter\", async () => {\n      const srv = setup();\n      try {\n        const response = await srv.handleRequest({\n          method: \"tools/call\",\n          params: {\n            name: \"lex.recall\",\n            arguments: {},\n          },\n        });\n\n        assert.ok(response.error, \"Should return error\");\n        assert.ok(\n          response.error.message.includes(\"At least one search parameter required\"),\n          \"Should require search parameters\"\n        );\n      } finally {\n        teardown();\n      }\n    });\n\n    test(\"should handle unknown methods\", async () => {\n      const srv = setup();\n      try {\n        const response = await srv.handleRequest({\n          method: \"unknown/method\",\n        });\n\n        assert.ok(response.error, \"Should return error\");\n        assert.ok(\n          response.error.message.includes(\"Unknown method\"),\n          \"Should indicate unknown method\"\n        );\n      } finally {\n        teardown();\n      }\n    });\n\n    test(\"should handle unknown tools\", async () => {\n      const srv = setup();\n      try {\n        const response = await srv.handleRequest({\n          method: \"tools/call\",\n          params: {\n            name: \"lex.unknown_tool\",\n            arguments: {},\n          },\n        });\n\n        assert.ok(response.error, \"Should return error\");\n        assert.ok(response.error.message.includes(\"Unknown tool\"), \"Should indicate unknown tool\");\n      } finally {\n        teardown();\n      }\n    });\n  });\n\n  describe(\"Protocol Compliance\", () => {\n    test(\"should list all available tools\", async () => {\n      const srv = setup();\n      try {\n        const response = await srv.handleRequest({\n          method: \"tools/list\",\n        });\n\n        assert.ok(response.tools, \"Should return tools array\");\n        assert.strictEqual(response.tools.length, 3, \"Should have 3 tools\");\n\n        const toolNames = response.tools.map((t) => t.name);\n        assert.ok(toolNames.includes(\"lex.remember\"));\n        assert.ok(toolNames.includes(\"lex.recall\"));\n        assert.ok(toolNames.includes(\"lex.list_frames\"));\n      } finally {\n        teardown();\n      }\n    });\n\n    test(\"should include tool schemas in tools/list\", async () => {\n      const srv = setup();\n      try {\n        const response = await srv.handleRequest({\n          method: \"tools/list\",\n        });\n\n        const rememberTool = response.tools?.find((t) => t.name === \"lex.remember\");\n        assert.ok(rememberTool, \"Should include lex.remember\");\n        assert.ok(rememberTool.inputSchema, \"Should include input schema\");\n        assert.ok(rememberTool.inputSchema.properties, \"Schema should have properties\");\n      } finally {\n        teardown();\n      }\n    });\n  });\n});\n\nconsole.log(\"\\n✅ MCP Server Integration Tests - Full protocol coverage\\n\");\n","usedDeprecatedRules":[]},{"filePath":"/srv/lex-mcp/lex/test/memory/mcp_server/server.test.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'e' is defined but never used.","line":35,"column":16,"nodeType":null,"messageId":"unusedVar","endLine":35,"endColumn":17},{"ruleId":"@typescript-eslint/no-unsafe-return","severity":1,"message":"Unsafe return of a value of type `any`.","line":49,"column":51,"nodeType":"MemberExpression","messageId":"unsafeReturn","endLine":49,"endColumn":57},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .name on an `any` value.","line":49,"column":53,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":49,"endColumn":57},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":1,"message":"Unsafe call of a(n) `any` typed value.","line":81,"column":9,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":81,"endColumn":42},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .text on an `any` value.","line":81,"column":29,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":81,"endColumn":33},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":1,"message":"Unsafe call of a(n) `any` typed value.","line":84,"column":17,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":84,"endColumn":50},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .text on an `any` value.","line":84,"column":37,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":84,"endColumn":41},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":1,"message":"Unsafe call of a(n) `any` typed value.","line":85,"column":17,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":85,"endColumn":50},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .text on an `any` value.","line":85,"column":37,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":85,"endColumn":41},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":1,"message":"Unsafe call of a(n) `any` typed value.","line":147,"column":17,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":147,"endColumn":50},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .text on an `any` value.","line":147,"column":37,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":147,"endColumn":41},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":1,"message":"Unsafe call of a(n) `any` typed value.","line":149,"column":9,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":149,"endColumn":42},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .text on an `any` value.","line":149,"column":29,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":149,"endColumn":33},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":1,"message":"Unsafe call of a(n) `any` typed value.","line":152,"column":17,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":152,"endColumn":50},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .text on an `any` value.","line":152,"column":37,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":152,"endColumn":41},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":1,"message":"Unsafe call of a(n) `any` typed value.","line":173,"column":9,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":173,"endColumn":42},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .text on an `any` value.","line":173,"column":29,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":173,"endColumn":33},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":1,"message":"Unsafe call of a(n) `any` typed value.","line":242,"column":17,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":242,"endColumn":50},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .text on an `any` value.","line":242,"column":37,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":242,"endColumn":41},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":1,"message":"Unsafe call of a(n) `any` typed value.","line":243,"column":17,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":243,"endColumn":50},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .text on an `any` value.","line":243,"column":37,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":243,"endColumn":41},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":1,"message":"Unsafe call of a(n) `any` typed value.","line":244,"column":17,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":244,"endColumn":50},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .text on an `any` value.","line":244,"column":37,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":244,"endColumn":41},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":1,"message":"Unsafe call of a(n) `any` typed value.","line":245,"column":17,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":245,"endColumn":50},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .text on an `any` value.","line":245,"column":37,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":245,"endColumn":41},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":1,"message":"Unsafe call of a(n) `any` typed value.","line":291,"column":17,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":291,"endColumn":50},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .text on an `any` value.","line":291,"column":37,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":291,"endColumn":41},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":1,"message":"Unsafe call of a(n) `any` typed value.","line":292,"column":17,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":292,"endColumn":50},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .text on an `any` value.","line":292,"column":37,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":292,"endColumn":41},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":1,"message":"Unsafe call of a(n) `any` typed value.","line":293,"column":18,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":293,"endColumn":51},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .text on an `any` value.","line":293,"column":38,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":293,"endColumn":42},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":1,"message":"Unsafe call of a(n) `any` typed value.","line":369,"column":9,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":369,"endColumn":42},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .text on an `any` value.","line":369,"column":29,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":369,"endColumn":33},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":1,"message":"Unsafe call of a(n) `any` typed value.","line":373,"column":9,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":373,"endColumn":42},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .text on an `any` value.","line":373,"column":29,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":373,"endColumn":33},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":1,"message":"Unsafe call of a(n) `any` typed value.","line":410,"column":9,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":410,"endColumn":42},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .text on an `any` value.","line":410,"column":29,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":410,"endColumn":33},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":1,"message":"Unsafe call of a(n) `any` typed value.","line":642,"column":9,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":642,"endColumn":42},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .text on an `any` value.","line":642,"column":29,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":642,"endColumn":33},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":1,"message":"Unsafe call of a(n) `any` typed value.","line":646,"column":9,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":646,"endColumn":42},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .text on an `any` value.","line":646,"column":29,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":646,"endColumn":33},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":1,"message":"Unsafe call of a(n) `any` typed value.","line":647,"column":11,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":647,"endColumn":44},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .text on an `any` value.","line":647,"column":31,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":647,"endColumn":35},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":1,"message":"Unsafe call of a(n) `any` typed value.","line":648,"column":11,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":648,"endColumn":44},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .text on an `any` value.","line":648,"column":31,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":648,"endColumn":35},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":1,"message":"Unsafe assignment of an `any` value.","line":679,"column":13,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":679,"endColumn":44},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .text on an `any` value.","line":679,"column":40,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":679,"endColumn":44},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":1,"message":"Unsafe call of a(n) `any` typed value.","line":680,"column":17,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":680,"endColumn":30},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .includes on an `any` value.","line":680,"column":22,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":680,"endColumn":30},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":1,"message":"Unsafe call of a(n) `any` typed value.","line":681,"column":18,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":681,"endColumn":31},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .includes on an `any` value.","line":681,"column":23,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":681,"endColumn":31},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":1,"message":"Unsafe call of a(n) `any` typed value.","line":711,"column":9,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":711,"endColumn":42},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .text on an `any` value.","line":711,"column":29,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":711,"endColumn":33}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":53,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Tests for Frame MCP Server\n *\n * Tests the MCP protocol implementation for Frame storage and recall.\n * Uses Node.js built-in test runner (node:test) - no external dependencies.\n */\n\nimport { test, describe } from \"node:test\";\nimport assert from \"node:assert\";\nimport { MCPServer } from \"@app/memory/mcp_server/server.js\";\nimport { mkdtempSync, rmSync } from \"fs\";\nimport { join } from \"path\";\nimport { tmpdir } from \"os\";\n\ndescribe(\"MCP Server - Protocol\", () => {\n  let server: MCPServer;\n  let testDbPath: string;\n\n  // Setup: create test database in temp directory\n  function setup() {\n    const tmpDir = mkdtempSync(join(tmpdir(), \"lex-test-\"));\n    testDbPath = join(tmpDir, \"test-frames.db\");\n    server = new MCPServer(testDbPath);\n    return server;\n  }\n\n  // Teardown: close database and cleanup\n  function teardown() {\n    if (server) {\n      server.close();\n    }\n    if (testDbPath) {\n      try {\n        rmSync(testDbPath, { force: true });\n      } catch (e) {\n        // Ignore cleanup errors\n      }\n    }\n  }\n\n  test(\"tools/list returns all available tools\", async () => {\n    const srv = setup();\n    try {\n      const response = await srv.handleRequest({ method: \"tools/list\" });\n\n      assert.ok(response.tools, \"Response should have tools array\");\n      assert.strictEqual(response.tools.length, 3, \"Should have 3 tools\");\n\n      const toolNames = response.tools.map((t) => t.name);\n      assert.ok(toolNames.includes(\"lex.remember\"), \"Should include lex.remember\");\n      assert.ok(toolNames.includes(\"lex.recall\"), \"Should include lex.recall\");\n      assert.ok(toolNames.includes(\"lex.list_frames\"), \"Should include lex.list_frames\");\n    } finally {\n      teardown();\n    }\n  });\n\n  test(\"lex.remember creates a Frame with valid data\", async () => {\n    const srv = setup();\n    try {\n      const args = {\n        reference_point: \"test memory\",\n        summary_caption: \"Testing Frame creation\",\n        status_snapshot: {\n          next_action: \"Verify storage\",\n          blockers: [],\n        },\n        module_scope: [\"policy/scanners\"],\n      };\n\n      const response = await srv.handleRequest({\n        method: \"tools/call\",\n        params: {\n          name: \"lex.remember\",\n          arguments: args,\n        },\n      });\n\n      assert.ok(response.content, \"Response should have content\");\n      assert.ok(\n        response.content[0].text.includes(\"✅ Frame stored\"),\n        \"Should confirm Frame storage\"\n      );\n      assert.ok(response.content[0].text.includes(\"test memory\"), \"Should include reference point\");\n      assert.ok(response.content[0].text.includes(\"Atlas Frame\"), \"Should include Atlas Frame\");\n    } finally {\n      teardown();\n    }\n  });\n\n  test(\"lex.remember fails with missing required fields\", async () => {\n    const srv = setup();\n    try {\n      const response = await srv.handleRequest({\n        method: \"tools/call\",\n        params: {\n          name: \"lex.remember\",\n          arguments: {\n            reference_point: \"incomplete data\",\n            // Missing: summary_caption, status_snapshot, module_scope\n          },\n        },\n      });\n\n      assert.ok(response.error, \"Should return error\");\n      assert.ok(\n        response.error.message.includes(\"Missing required fields\"),\n        \"Error should mention missing fields\"\n      );\n    } finally {\n      teardown();\n    }\n  });\n\n  test(\"lex.recall finds stored Frames by reference_point\", async () => {\n    const srv = setup();\n    try {\n      // First, create a Frame\n      await srv.handleRequest({\n        method: \"tools/call\",\n        params: {\n          name: \"lex.remember\",\n          arguments: {\n            reference_point: \"authentication refactoring\",\n            summary_caption: \"Extracted password validation\",\n            status_snapshot: {\n              next_action: \"Add unit tests\",\n              blockers: [],\n            },\n            module_scope: [\"shared/types\"],\n          },\n        },\n      });\n\n      // Then, recall it\n      const response = await srv.handleRequest({\n        method: \"tools/call\",\n        params: {\n          name: \"lex.recall\",\n          arguments: {\n            reference_point: \"authentication\",\n          },\n        },\n      });\n\n      assert.ok(response.content, \"Response should have content\");\n      assert.ok(response.content[0].text.includes(\"Found 1 Frame\"), \"Should find 1 Frame\");\n      assert.ok(\n        response.content[0].text.includes(\"authentication refactoring\"),\n        \"Should include reference point\"\n      );\n      assert.ok(response.content[0].text.includes(\"Atlas Frame\"), \"Should include Atlas Frame\");\n    } finally {\n      teardown();\n    }\n  });\n\n  test(\"lex.recall returns empty result for non-existent query\", async () => {\n    const srv = setup();\n    try {\n      const response = await srv.handleRequest({\n        method: \"tools/call\",\n        params: {\n          name: \"lex.recall\",\n          arguments: {\n            reference_point: \"nonexistent work\",\n          },\n        },\n      });\n\n      assert.ok(response.content, \"Response should have content\");\n      assert.ok(\n        response.content[0].text.includes(\"No matching Frames found\"),\n        \"Should indicate no results\"\n      );\n    } finally {\n      teardown();\n    }\n  });\n\n  test(\"lex.recall fails without search parameters\", async () => {\n    const srv = setup();\n    try {\n      const response = await srv.handleRequest({\n        method: \"tools/call\",\n        params: {\n          name: \"lex.recall\",\n          arguments: {}, // No search parameters\n        },\n      });\n\n      assert.ok(response.error, \"Should return error\");\n      assert.ok(\n        response.error.message.includes(\"At least one search parameter required\"),\n        \"Error should mention missing parameters\"\n      );\n    } finally {\n      teardown();\n    }\n  });\n\n  test(\"lex.list_frames returns recent Frames\", async () => {\n    const srv = setup();\n    try {\n      // Create two Frames\n      await srv.handleRequest({\n        method: \"tools/call\",\n        params: {\n          name: \"lex.remember\",\n          arguments: {\n            reference_point: \"frame one\",\n            summary_caption: \"First test frame\",\n            status_snapshot: { next_action: \"Test\" },\n            module_scope: [\"policy/scanners\"],\n          },\n        },\n      });\n\n      await srv.handleRequest({\n        method: \"tools/call\",\n        params: {\n          name: \"lex.remember\",\n          arguments: {\n            reference_point: \"frame two\",\n            summary_caption: \"Second test frame\",\n            status_snapshot: { next_action: \"Test\" },\n            module_scope: [\"shared/types\"],\n          },\n        },\n      });\n\n      // List frames\n      const response = await srv.handleRequest({\n        method: \"tools/call\",\n        params: {\n          name: \"lex.list_frames\",\n          arguments: { limit: 10 },\n        },\n      });\n\n      assert.ok(response.content, \"Response should have content\");\n      assert.ok(response.content[0].text.includes(\"Recent Frames (2)\"), \"Should list 2 frames\");\n      assert.ok(response.content[0].text.includes(\"frame one\"), \"Should include first frame\");\n      assert.ok(response.content[0].text.includes(\"frame two\"), \"Should include second frame\");\n      assert.ok(response.content[0].text.includes(\"Atlas Frame\"), \"Should include Atlas Frames\");\n    } finally {\n      teardown();\n    }\n  });\n\n  test(\"lex.list_frames filters by module\", async () => {\n    const srv = setup();\n    try {\n      // Create two Frames with different modules\n      await srv.handleRequest({\n        method: \"tools/call\",\n        params: {\n          name: \"lex.remember\",\n          arguments: {\n            reference_point: \"auth work\",\n            summary_caption: \"Auth module work\",\n            status_snapshot: { next_action: \"Test\" },\n            module_scope: [\"policy/scanners\"],\n          },\n        },\n      });\n\n      await srv.handleRequest({\n        method: \"tools/call\",\n        params: {\n          name: \"lex.remember\",\n          arguments: {\n            reference_point: \"ui work\",\n            summary_caption: \"UI module work\",\n            status_snapshot: { next_action: \"Test\" },\n            module_scope: [\"memory/mcp\"],\n          },\n        },\n      });\n\n      // List only auth module frames\n      const response = await srv.handleRequest({\n        method: \"tools/call\",\n        params: {\n          name: \"lex.list_frames\",\n          arguments: { module: \"policy/scanners\", limit: 10 },\n        },\n      });\n\n      assert.ok(response.content, \"Response should have content\");\n      assert.ok(response.content[0].text.includes(\"Recent Frames (1)\"), \"Should list 1 frame\");\n      assert.ok(response.content[0].text.includes(\"auth work\"), \"Should include auth frame\");\n      assert.ok(!response.content[0].text.includes(\"ui work\"), \"Should not include ui frame\");\n    } finally {\n      teardown();\n    }\n  });\n\n  test(\"unknown method returns error\", async () => {\n    const srv = setup();\n    try {\n      const response = await srv.handleRequest({\n        method: \"unknown/method\",\n      });\n\n      assert.ok(response.error, \"Should return error\");\n      assert.ok(\n        response.error.message.includes(\"Unknown method\"),\n        \"Error should mention unknown method\"\n      );\n    } finally {\n      teardown();\n    }\n  });\n\n  test(\"unknown tool returns error\", async () => {\n    const srv = setup();\n    try {\n      const response = await srv.handleRequest({\n        method: \"tools/call\",\n        params: {\n          name: \"lex.unknown_tool\",\n          arguments: {},\n        },\n      });\n\n      assert.ok(response.error, \"Should return error\");\n      assert.ok(\n        response.error.message.includes(\"Unknown tool\"),\n        \"Error should mention unknown tool\"\n      );\n    } finally {\n      teardown();\n    }\n  });\n\n  // Image attachment tests (PR #27)\n  test(\"lex.remember stores Frame with image attachments\", async () => {\n    const srv = setup();\n    try {\n      // Create a small test image (base64-encoded PNG)\n      const testImageData = Buffer.from(\"fake-png-data\").toString(\"base64\");\n\n      const args = {\n        reference_point: \"test with images\",\n        summary_caption: \"Testing image attachment\",\n        status_snapshot: {\n          next_action: \"Verify image storage\",\n        },\n        module_scope: [\"policy/scanners\"], // Use valid module from policy\n        images: [\n          {\n            data: testImageData,\n            mime_type: \"image/png\",\n          },\n        ],\n      };\n\n      const response = await srv.handleRequest({\n        method: \"tools/call\",\n        params: {\n          name: \"lex.remember\",\n          arguments: args,\n        },\n      });\n\n      assert.ok(response.content, \"Response should have content\");\n      assert.ok(\n        response.content[0].text.includes(\"✅ Frame stored\"),\n        \"Should confirm Frame storage\"\n      );\n      assert.ok(\n        response.content[0].text.includes(\"🖼️  Images: 1 attached\"),\n        \"Should indicate image attachment\"\n      );\n    } finally {\n      teardown();\n    }\n  });\n\n  test(\"lex.remember stores Frame with multiple image attachments\", async () => {\n    const srv = setup();\n    try {\n      const image1 = Buffer.from(\"png-data\").toString(\"base64\");\n      const image2 = Buffer.from(\"jpeg-data\").toString(\"base64\");\n\n      const args = {\n        reference_point: \"test with multiple images\",\n        summary_caption: \"Testing multiple image attachments\",\n        status_snapshot: {\n          next_action: \"Verify multi-image storage\",\n        },\n        module_scope: [\"shared/types\"], // Use valid module from policy\n        images: [\n          { data: image1, mime_type: \"image/png\" },\n          { data: image2, mime_type: \"image/jpeg\" },\n        ],\n      };\n\n      const response = await srv.handleRequest({\n        method: \"tools/call\",\n        params: {\n          name: \"lex.remember\",\n          arguments: args,\n        },\n      });\n\n      assert.ok(response.content, \"Response should have content\");\n      assert.ok(\n        response.content[0].text.includes(\"🖼️  Images: 2 attached\"),\n        \"Should indicate 2 images attached\"\n      );\n    } finally {\n      teardown();\n    }\n  });\n\n  test(\"lex.remember fails with invalid image MIME type\", async () => {\n    const srv = setup();\n    try {\n      const testImageData = Buffer.from(\"fake-data\").toString(\"base64\");\n\n      const args = {\n        reference_point: \"test with invalid image\",\n        summary_caption: \"Testing invalid image type\",\n        status_snapshot: {\n          next_action: \"Should fail\",\n        },\n        module_scope: [\"policy/scanners\"], // Use valid module from policy\n        images: [\n          {\n            data: testImageData,\n            mime_type: \"application/pdf\", // Invalid MIME type\n          },\n        ],\n      };\n\n      const response = await srv.handleRequest({\n        method: \"tools/call\",\n        params: {\n          name: \"lex.remember\",\n          arguments: args,\n        },\n      });\n\n      assert.ok(response.error, \"Should return error\");\n      assert.ok(\n        response.error.message.includes(\"Failed to store image\"),\n        \"Error should mention image storage failure\"\n      );\n    } finally {\n      teardown();\n    }\n  });\n\n  test(\"lex.remember fails with oversized image\", async () => {\n    const srv = setup();\n    try {\n      // Create base64 of a buffer larger than 10MB\n      const largeBuffer = Buffer.alloc(11 * 1024 * 1024);\n      const testImageData = largeBuffer.toString(\"base64\");\n\n      const args = {\n        reference_point: \"test with oversized image\",\n        summary_caption: \"Testing oversized image\",\n        status_snapshot: {\n          next_action: \"Should fail\",\n        },\n        module_scope: [\"memory/mcp\"], // Use valid module from policy\n        images: [\n          {\n            data: testImageData,\n            mime_type: \"image/png\",\n          },\n        ],\n      };\n\n      const response = await srv.handleRequest({\n        method: \"tools/call\",\n        params: {\n          name: \"lex.remember\",\n          arguments: args,\n        },\n      });\n\n      assert.ok(response.error, \"Should return error\");\n      assert.ok(\n        response.error.message.includes(\"exceeds maximum\"),\n        \"Error should mention size limit\"\n      );\n    } finally {\n      teardown();\n    }\n  });\n\n  // Integration tests for module ID validation (THE CRITICAL RULE) - PR #28\n  test(\"lex.remember validates module IDs - rejects invalid module\", async () => {\n    const srv = setup();\n    try {\n      const response = await srv.handleRequest({\n        method: \"tools/call\",\n        params: {\n          name: \"lex.remember\",\n          arguments: {\n            reference_point: \"invalid module test\",\n            summary_caption: \"Testing validation\",\n            status_snapshot: { next_action: \"Test\" },\n            module_scope: [\"invalid-module\"],\n          },\n        },\n      });\n\n      assert.ok(response.error, \"Should return error for invalid module\");\n      assert.ok(\n        response.error.message.includes(\"Invalid module IDs\"),\n        \"Error should mention invalid module IDs\"\n      );\n      assert.ok(\n        response.error.message.includes(\"invalid-module\"),\n        \"Error should mention the specific invalid module\"\n      );\n      assert.ok(\n        response.error.message.includes(\"Available modules\"),\n        \"Error should list available modules\"\n      );\n    } finally {\n      teardown();\n    }\n  });\n\n  test(\"lex.remember validates module IDs - suggests similar modules\", async () => {\n    const srv = setup();\n    try {\n      const response = await srv.handleRequest({\n        method: \"tools/call\",\n        params: {\n          name: \"lex.remember\",\n          arguments: {\n            reference_point: \"typo test\",\n            summary_caption: \"Testing fuzzy matching\",\n            status_snapshot: { next_action: \"Test\" },\n            module_scope: [\"indexr\"], // Typo: should be \"policy/scanners\"\n          },\n        },\n      });\n\n      assert.ok(response.error, \"Should return error for typo\");\n      assert.ok(response.error.message.includes(\"indexr\"), \"Error should mention the typo\");\n      assert.ok(\n        response.error.message.includes(\"Did you mean\"),\n        \"Error should provide suggestions\"\n      );\n    } finally {\n      teardown();\n    }\n  });\n\n  test(\"lex.remember validates module IDs - reports multiple invalid modules\", async () => {\n    const srv = setup();\n    try {\n      const response = await srv.handleRequest({\n        method: \"tools/call\",\n        params: {\n          name: \"lex.remember\",\n          arguments: {\n            reference_point: \"multiple errors test\",\n            summary_caption: \"Testing multiple validation errors\",\n            status_snapshot: { next_action: \"Test\" },\n            module_scope: [\"invalid1\", \"invalid2\", \"invalid3\"],\n          },\n        },\n      });\n\n      assert.ok(response.error, \"Should return error for invalid modules\");\n      assert.ok(\n        response.error.message.includes(\"invalid1\"),\n        \"Error should mention first invalid module\"\n      );\n      assert.ok(\n        response.error.message.includes(\"invalid2\"),\n        \"Error should mention second invalid module\"\n      );\n      assert.ok(\n        response.error.message.includes(\"invalid3\"),\n        \"Error should mention third invalid module\"\n      );\n    } finally {\n      teardown();\n    }\n  });\n\n  test(\"lex.remember validates module IDs - mix of valid and invalid\", async () => {\n    const srv = setup();\n    try {\n      const response = await srv.handleRequest({\n        method: \"tools/call\",\n        params: {\n          name: \"lex.remember\",\n          arguments: {\n            reference_point: \"mixed validity test\",\n            summary_caption: \"Testing mixed valid/invalid modules\",\n            status_snapshot: { next_action: \"Test\" },\n            module_scope: [\"policy/scanners\", \"invalid-module\", \"shared/types\"],\n          },\n        },\n      });\n\n      assert.ok(response.error, \"Should return error when any module is invalid\");\n      assert.ok(\n        response.error.message.includes(\"invalid-module\"),\n        \"Error should mention the invalid module\"\n      );\n      // Valid modules should only appear in \"Available modules\" list, not as errors\n      const errorLines = response.error.message.split(\"\\n\").filter((line) => line.includes(\"•\"));\n      const hasValidModuleError = errorLines.some(\n        (line) => line.includes(\"policy/scanners\") || line.includes(\"shared/types\")\n      );\n      assert.ok(!hasValidModuleError, \"Error should not flag valid modules as invalid\");\n    } finally {\n      teardown();\n    }\n  });\n\n  test(\"lex.remember validates module IDs - accepts all valid modules\", async () => {\n    const srv = setup();\n    try {\n      const response = await srv.handleRequest({\n        method: \"tools/call\",\n        params: {\n          name: \"lex.remember\",\n          arguments: {\n            reference_point: \"all valid modules\",\n            summary_caption: \"Testing with all policy modules\",\n            status_snapshot: { next_action: \"Test\" },\n            module_scope: [\"policy/scanners\", \"shared/types\", \"memory/mcp\"],\n          },\n        },\n      });\n\n      assert.ok(response.content, \"Should succeed with all valid modules\");\n      assert.ok(\n        response.content[0].text.includes(\"✅ Frame stored\"),\n        \"Should confirm Frame storage\"\n      );\n      assert.ok(\n        response.content[0].text.includes(\"policy/scanners\") &&\n          response.content[0].text.includes(\"shared/types\") &&\n          response.content[0].text.includes(\"memory/mcp\"),\n        \"Should include all modules\"\n      );\n    } finally {\n      teardown();\n    }\n  });\n\n  // Branch detection tests (PR #29)\n  test(\"lex.remember auto-detects git branch when not provided\", async () => {\n    const srv = setup();\n    try {\n      const args = {\n        reference_point: \"branch detection test\",\n        summary_caption: \"Testing auto-detection\",\n        status_snapshot: {\n          next_action: \"Verify branch detection\",\n          blockers: [],\n        },\n        module_scope: [\"policy/scanners\"],\n      };\n\n      const response = await srv.handleRequest({\n        method: \"tools/call\",\n        params: {\n          name: \"lex.remember\",\n          arguments: args,\n        },\n      });\n\n      assert.ok(response.content, \"Response should have content\");\n      const text = response.content[0].text;\n      assert.ok(text.includes(\"🌿 Branch:\"), \"Should include branch info\");\n      assert.ok(!text.includes(\"Branch: main\"), \"Should not hardcode main\");\n    } finally {\n      teardown();\n    }\n  });\n\n  test(\"lex.remember respects provided branch over auto-detection\", async () => {\n    const srv = setup();\n    try {\n      const args = {\n        reference_point: \"manual branch test\",\n        summary_caption: \"Testing manual branch override\",\n        status_snapshot: {\n          next_action: \"Verify manual branch\",\n          blockers: [],\n        },\n        module_scope: [\"policy/scanners\"],\n        branch: \"custom-branch-name\",\n      };\n\n      const response = await srv.handleRequest({\n        method: \"tools/call\",\n        params: {\n          name: \"lex.remember\",\n          arguments: args,\n        },\n      });\n\n      assert.ok(response.content, \"Response should have content\");\n      assert.ok(\n        response.content[0].text.includes(\"🌿 Branch: custom-branch-name\"),\n        \"Should use provided branch name\"\n      );\n    } finally {\n      teardown();\n    }\n  });\n});\n","usedDeprecatedRules":[]},{"filePath":"/srv/lex-mcp/lex/test/memory/renderer/card.test.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'err' is defined but never used.","line":237,"column":12,"nodeType":null,"messageId":"unusedVar","endLine":237,"endColumn":15}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Test suite for memory card rendering\n * Run with: node --loader tsx memory/renderer/card.test.ts\n */\n\nimport { renderMemoryCard, renderMemoryCardWithOptions } from \"@app/memory/renderer/card.js\";\nimport type { Frame } from \"@app/memory/frames/types.js\";\nimport { writeFileSync, mkdirSync } from \"fs\";\nimport { join } from \"path\";\n\n// Test output directory\nconst TEST_OUTPUT_DIR = \"/tmp/memory-card-tests\";\n\n/**\n * Test helper to create a minimal Frame\n */\nfunction createMinimalFrame(): Frame {\n  return {\n    id: \"frame-minimal-001\",\n    timestamp: new Date().toISOString(),\n    branch: \"main\",\n    module_scope: [\"memory/renderer\"],\n    summary_caption: \"Minimal test frame\",\n    reference_point: \"Basic rendering test\",\n    status_snapshot: {\n      next_action: \"Verify minimal frame renders correctly\",\n    },\n  };\n}\n\n/**\n * Test helper to create a full Frame with all optional fields\n */\nfunction createFullFrame(): Frame {\n  return {\n    id: \"frame-full-002\",\n    timestamp: new Date().toISOString(),\n    branch: \"feature/memory-card-rendering\",\n    jira: \"LEX-123\",\n    module_scope: [\"memory/renderer\", \"memory/frames\", \"memory/store\"],\n    summary_caption:\n      \"Full featured test frame with all optional fields populated to test rendering capabilities\",\n    reference_point: \"Complete frame with blockers, keywords, and atlas reference\",\n    status_snapshot: {\n      next_action:\n        \"Continue implementing memory card visual rendering with canvas library and ensure all fields are properly displayed\",\n      blockers: [\"Canvas library installation pending\", \"Test infrastructure needs setup\"],\n      merge_blockers: [\"PR review required\", \"Integration tests failing\"],\n      tests_failing: [\n        \"test_memory_card_minimal\",\n        \"test_memory_card_full\",\n        \"test_long_text_handling\",\n      ],\n    },\n    keywords: [\"memory\", \"rendering\", \"canvas\", \"visual\", \"testing\", \"frames\"],\n    atlas_frame_id: \"atlas-frame-xyz789\",\n    feature_flags: [\"enable-visual-rendering\"],\n    permissions: [\"read\", \"write\"],\n  };\n}\n\n/**\n * Test helper to create a Frame with very long text\n */\nfunction createLongTextFrame(): Frame {\n  return {\n    id: \"frame-longtext-003\",\n    timestamp: new Date().toISOString(),\n    branch: \"test/long-text-handling\",\n    module_scope: [\"memory/renderer\"],\n    summary_caption:\n      \"This is a very long summary caption that should be truncated or wrapped properly to fit within the card boundaries without overflowing or breaking the layout. It contains many words and should demonstrate text handling capabilities.\",\n    reference_point:\n      \"Testing extremely long reference point text that needs to be handled gracefully with either truncation or wrapping mechanisms\",\n    status_snapshot: {\n      next_action:\n        \"Test the memory card renderer with various edge cases including very long text strings that might exceed the normal display boundaries and need to be wrapped across multiple lines or truncated with ellipsis to maintain readability and visual consistency throughout the rendered card image.\",\n      blockers: [\n        \"This is a very long blocker description that should be truncated because it exceeds the maximum allowed length for a single blocker item in the display\",\n      ],\n    },\n    keywords: Array(15)\n      .fill(\"keyword\")\n      .map((k, i) => `${k}${i}`),\n  };\n}\n\n/**\n * Test 1: Render minimal Frame\n */\nasync function testMinimalFrame() {\n  console.log(\"Test 1: Rendering minimal Frame...\");\n  const frame = createMinimalFrame();\n  const buffer = await renderMemoryCard(frame);\n\n  // Verify buffer is valid\n  if (!Buffer.isBuffer(buffer)) {\n    throw new Error(\"Output is not a Buffer\");\n  }\n\n  // Check PNG signature\n  const pngSignature = Buffer.from([0x89, 0x50, 0x4e, 0x47, 0x0d, 0x0a, 0x1a, 0x0a]);\n  if (!buffer.subarray(0, 8).equals(pngSignature)) {\n    throw new Error(\"Output is not a valid PNG\");\n  }\n\n  // Save for manual inspection\n  const outputPath = join(TEST_OUTPUT_DIR, \"test-minimal-frame.png\");\n  writeFileSync(outputPath, buffer);\n\n  console.log(`✓ Minimal frame rendered successfully (${buffer.length} bytes)`);\n  console.log(`  Saved to: ${outputPath}`);\n}\n\n/**\n * Test 2: Render full Frame with all optional fields\n */\nasync function testFullFrame() {\n  console.log(\"Test 2: Rendering full Frame...\");\n  const frame = createFullFrame();\n  const buffer = await renderMemoryCard(frame);\n\n  // Verify buffer is valid\n  if (!Buffer.isBuffer(buffer)) {\n    throw new Error(\"Output is not a Buffer\");\n  }\n\n  // Check PNG signature\n  const pngSignature = Buffer.from([0x89, 0x50, 0x4e, 0x47, 0x0d, 0x0a, 0x1a, 0x0a]);\n  if (!buffer.subarray(0, 8).equals(pngSignature)) {\n    throw new Error(\"Output is not a valid PNG\");\n  }\n\n  // Should be larger than minimal due to more content\n  const outputPath = join(TEST_OUTPUT_DIR, \"test-full-frame.png\");\n  writeFileSync(outputPath, buffer);\n\n  console.log(`✓ Full frame rendered successfully (${buffer.length} bytes)`);\n  console.log(`  Saved to: ${outputPath}`);\n}\n\n/**\n * Test 3: Handle long text (truncation/wrapping)\n */\nasync function testLongTextHandling() {\n  console.log(\"Test 3: Testing long text handling...\");\n  const frame = createLongTextFrame();\n  const buffer = await renderMemoryCard(frame);\n\n  // Verify buffer is valid\n  if (!Buffer.isBuffer(buffer)) {\n    throw new Error(\"Output is not a Buffer\");\n  }\n\n  const outputPath = join(TEST_OUTPUT_DIR, \"test-long-text.png\");\n  writeFileSync(outputPath, buffer);\n\n  console.log(`✓ Long text handled successfully (${buffer.length} bytes)`);\n  console.log(`  Saved to: ${outputPath}`);\n}\n\n/**\n * Test 4: Render with raw context\n */\nasync function testRawContext() {\n  console.log(\"Test 4: Testing raw context rendering...\");\n  const frame = createMinimalFrame();\n  const rawContext = `\nRecent logs:\n[2024-11-02 17:00:00] Starting memory card rendering\n[2024-11-02 17:00:01] Canvas initialized\n[2024-11-02 17:00:02] Frame data loaded\n[2024-11-02 17:00:03] Rendering complete\n\nRecent changes:\n+ Added renderMemoryCard function to card.ts\n+ Implemented canvas-based image generation\n+ Created test suite with 5+ test cases\n  `;\n\n  const buffer = await renderMemoryCard(frame, rawContext);\n\n  // Verify buffer is valid\n  if (!Buffer.isBuffer(buffer)) {\n    throw new Error(\"Output is not a Buffer\");\n  }\n\n  const outputPath = join(TEST_OUTPUT_DIR, \"test-raw-context.png\");\n  writeFileSync(outputPath, buffer);\n\n  console.log(`✓ Raw context rendered successfully (${buffer.length} bytes)`);\n  console.log(`  Saved to: ${outputPath}`);\n}\n\n/**\n * Test 5: Verify output is readable at various sizes\n */\nasync function testReadabilityAtSizes() {\n  console.log(\"Test 5: Testing readability at various sizes...\");\n  const frame = createFullFrame();\n\n  // Test with custom dimensions\n  const sizes = [\n    { width: 600, height: 800, name: \"small\" },\n    { width: 800, height: 1000, name: \"medium\" },\n    { width: 1000, height: 1200, name: \"large\" },\n  ];\n\n  for (const size of sizes) {\n    const buffer = await renderMemoryCardWithOptions(frame, {\n      dimensions: {\n        width: size.width,\n        height: size.height,\n        padding: 40,\n        lineHeight: 24,\n      },\n    });\n\n    const outputPath = join(TEST_OUTPUT_DIR, `test-size-${size.name}.png`);\n    writeFileSync(outputPath, buffer);\n\n    console.log(`  ✓ ${size.name} size (${size.width}x${size.height}): ${buffer.length} bytes`);\n  }\n\n  console.log(\"✓ All size variations rendered successfully\");\n}\n\n/**\n * Run all tests\n */\nasync function runTests() {\n  console.log(\"=== Memory Card Renderer Test Suite ===\\n\");\n\n  // Create output directory\n  try {\n    mkdirSync(TEST_OUTPUT_DIR, { recursive: true });\n  } catch (err) {\n    // Directory already exists\n  }\n\n  try {\n    await testMinimalFrame();\n    console.log();\n\n    await testFullFrame();\n    console.log();\n\n    await testLongTextHandling();\n    console.log();\n\n    await testRawContext();\n    console.log();\n\n    await testReadabilityAtSizes();\n    console.log();\n\n    console.log(\"=== All Tests Passed ✓ ===\");\n    console.log(`\\nTest outputs saved to: ${TEST_OUTPUT_DIR}`);\n    console.log(\"Open the PNG files to visually verify rendering quality.\");\n  } catch (error) {\n    console.error(\"\\n=== Test Failed ✗ ===\");\n    console.error(error);\n    process.exit(1);\n  }\n}\n\n// Run tests if this file is executed directly\nrunTests();\n","usedDeprecatedRules":[]},{"filePath":"/srv/lex-mcp/lex/test/memory/renderer/diff.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/srv/lex-mcp/lex/test/memory/renderer/graph.test.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'err' is defined but never used.","line":355,"column":12,"nodeType":null,"messageId":"unusedVar","endLine":355,"endColumn":15}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Test suite for graph rendering\n * Run with: node --test memory/renderer/dist/renderer/graph.test.js\n */\n\nimport { renderAtlasFrameGraph, exportGraphAsPNG, type AtlasFrame } from \"@app/memory/renderer/graph.js\";\nimport { writeFileSync, mkdirSync } from \"fs\";\nimport { join } from \"path\";\n\n// Test output directory\nconst TEST_OUTPUT_DIR = \"/tmp/graph-renderer-tests\";\n\n// Performance test constants\nconst PERFORMANCE_TARGET_MS = 500;\nconst LARGE_GRAPH_SIZE = 50;\n\n/**\n * Create a test Atlas Frame with sample data\n */\nfunction createTestAtlasFrame(): AtlasFrame {\n  return {\n    atlas_timestamp: new Date().toISOString(),\n    seed_modules: [\"ui/admin-panel\"],\n    fold_radius: 1,\n    modules: [\n      {\n        id: \"ui/admin-panel\",\n        coords: [400, 300],\n        owns_paths: [\"ui/admin/**\"],\n        forbidden_callers: [\"backend/auth\"],\n        feature_flags: [\"admin_ui\"],\n        requires_permissions: [\"admin_access\"],\n      },\n      {\n        id: \"api/user-service\",\n        coords: [200, 200],\n        owns_paths: [\"api/users/**\"],\n        allowed_callers: [\"ui/admin-panel\"],\n      },\n      {\n        id: \"api/admin-service\",\n        coords: [600, 200],\n        owns_paths: [\"api/admin/**\"],\n        allowed_callers: [\"ui/admin-panel\"],\n        requires_permissions: [\"admin_access\"],\n      },\n      {\n        id: \"backend/auth\",\n        coords: [400, 100],\n        owns_paths: [\"backend/auth/**\"],\n        allowed_callers: [\"api/user-service\", \"api/admin-service\"],\n        forbidden_callers: [\"ui/admin-panel\"],\n      },\n    ],\n    edges: [\n      {\n        from: \"ui/admin-panel\",\n        to: \"api/user-service\",\n        allowed: true,\n      },\n      {\n        from: \"ui/admin-panel\",\n        to: \"api/admin-service\",\n        allowed: true,\n      },\n      {\n        from: \"ui/admin-panel\",\n        to: \"backend/auth\",\n        allowed: false,\n        reason: \"forbidden_caller\",\n      },\n      {\n        from: \"api/user-service\",\n        to: \"backend/auth\",\n        allowed: true,\n      },\n      {\n        from: \"api/admin-service\",\n        to: \"backend/auth\",\n        allowed: true,\n      },\n    ],\n    critical_rule: \"Every module name MUST match the IDs in lexmap.policy.json\",\n  };\n}\n\n/**\n * Create a larger test frame for performance testing\n */\nfunction createLargeTestAtlasFrame(): AtlasFrame {\n  const modules = [];\n  const edges = [];\n\n  // Create modules in a grid\n  for (let i = 0; i < LARGE_GRAPH_SIZE; i++) {\n    modules.push({\n      id: `module-${i}`,\n      coords: [100 + (i % 10) * 90, 100 + Math.floor(i / 10) * 90] as [number, number],\n    });\n  }\n\n  // Create edges (each module connects to next few modules)\n  for (let i = 0; i < LARGE_GRAPH_SIZE - 1; i++) {\n    edges.push({\n      from: `module-${i}`,\n      to: `module-${i + 1}`,\n      allowed: true,\n    });\n\n    // Add some forbidden edges\n    if (i % 5 === 0 && i + 2 < LARGE_GRAPH_SIZE) {\n      edges.push({\n        from: `module-${i}`,\n        to: `module-${i + 2}`,\n        allowed: false,\n        reason: \"forbidden_caller\",\n      });\n    }\n  }\n\n  return {\n    atlas_timestamp: new Date().toISOString(),\n    seed_modules: [\"module-0\", \"module-25\"],\n    fold_radius: 2,\n    modules,\n    edges,\n    critical_rule: \"Every module name MUST match the IDs in lexmap.policy.json\",\n  };\n}\n\n/**\n * Test 1: Render basic SVG graph\n */\nasync function testBasicSVGRendering() {\n  console.log(\"Test 1: Rendering basic SVG graph...\");\n\n  const atlasFrame = createTestAtlasFrame();\n  const svg = renderAtlasFrameGraph(atlasFrame);\n\n  // Verify SVG structure\n  if (!svg.includes(\"<svg\")) {\n    throw new Error(\"Output does not contain SVG element\");\n  }\n\n  if (!svg.includes(\"</svg>\")) {\n    throw new Error(\"SVG is not properly closed\");\n  }\n\n  // Check for nodes\n  if (!svg.includes(\"circle\")) {\n    throw new Error(\"SVG does not contain node circles\");\n  }\n\n  // Check for edges\n  if (!svg.includes(\"line\")) {\n    throw new Error(\"SVG does not contain edge lines\");\n  }\n\n  // Check for markers (arrows)\n  if (!svg.includes(\"marker\")) {\n    throw new Error(\"SVG does not contain arrow markers\");\n  }\n\n  // Save output\n  const outputPath = join(TEST_OUTPUT_DIR, \"test-basic-graph.svg\");\n  writeFileSync(outputPath, svg);\n\n  console.log(`✓ Basic SVG rendered successfully (${svg.length} bytes)`);\n  console.log(`  Saved to: ${outputPath}`);\n\n  return svg;\n}\n\n/**\n * Test 2: Render with force-directed layout\n */\nasync function testForceDirectedLayout() {\n  console.log(\"Test 2: Testing force-directed layout...\");\n\n  const atlasFrame = createTestAtlasFrame();\n  const svg = renderAtlasFrameGraph(atlasFrame, {\n    layout: \"force-directed\",\n    layoutConfig: {\n      iterations: 50,\n    },\n  });\n\n  if (!svg.includes(\"<svg\")) {\n    throw new Error(\"Force-directed layout failed to generate SVG\");\n  }\n\n  const outputPath = join(TEST_OUTPUT_DIR, \"test-force-directed.svg\");\n  writeFileSync(outputPath, svg);\n\n  console.log(`✓ Force-directed layout rendered successfully`);\n  console.log(`  Saved to: ${outputPath}`);\n}\n\n/**\n * Test 3: Render with hierarchical layout\n */\nasync function testHierarchicalLayout() {\n  console.log(\"Test 3: Testing hierarchical layout...\");\n\n  const atlasFrame = createTestAtlasFrame();\n  const svg = renderAtlasFrameGraph(atlasFrame, {\n    layout: \"hierarchical\",\n  });\n\n  if (!svg.includes(\"<svg\")) {\n    throw new Error(\"Hierarchical layout failed to generate SVG\");\n  }\n\n  const outputPath = join(TEST_OUTPUT_DIR, \"test-hierarchical.svg\");\n  writeFileSync(outputPath, svg);\n\n  console.log(`✓ Hierarchical layout rendered successfully`);\n  console.log(`  Saved to: ${outputPath}`);\n}\n\n/**\n * Test 4: Export as PNG\n */\nasync function testPNGExport() {\n  console.log(\"Test 4: Testing PNG export...\");\n\n  const atlasFrame = createTestAtlasFrame();\n  const svg = renderAtlasFrameGraph(atlasFrame);\n  const png = await exportGraphAsPNG(svg, { width: 800, height: 600 });\n\n  // Verify PNG signature\n  const pngSignature = Buffer.from([0x89, 0x50, 0x4e, 0x47, 0x0d, 0x0a, 0x1a, 0x0a]);\n  if (!png.subarray(0, 8).equals(pngSignature)) {\n    throw new Error(\"Output is not a valid PNG\");\n  }\n\n  const outputPath = join(TEST_OUTPUT_DIR, \"test-export.png\");\n  writeFileSync(outputPath, png);\n\n  console.log(`✓ PNG export successful (${png.length} bytes)`);\n  console.log(`  Saved to: ${outputPath}`);\n}\n\n/**\n * Test 5: Test with custom colors\n */\nasync function testCustomColors() {\n  console.log(\"Test 5: Testing custom node colors...\");\n\n  const atlasFrame = createTestAtlasFrame();\n  const svg = renderAtlasFrameGraph(atlasFrame, {\n    nodeColors: {\n      \"ui/admin-panel\": \"#FF6B6B\",\n      \"api/user-service\": \"#4ECDC4\",\n      \"api/admin-service\": \"#45B7D1\",\n      \"backend/auth\": \"#96CEB4\",\n    },\n  });\n\n  if (!svg.includes(\"#FF6B6B\")) {\n    throw new Error(\"Custom colors were not applied\");\n  }\n\n  const outputPath = join(TEST_OUTPUT_DIR, \"test-custom-colors.svg\");\n  writeFileSync(outputPath, svg);\n\n  console.log(`✓ Custom colors applied successfully`);\n  console.log(`  Saved to: ${outputPath}`);\n}\n\n/**\n * Test 6: Performance test with large graph\n */\nasync function testLargeGraphPerformance() {\n  console.log(`Test 6: Testing performance with large graph (${LARGE_GRAPH_SIZE} nodes)...`);\n\n  const atlasFrame = createLargeTestAtlasFrame();\n  const startTime = Date.now();\n\n  const svg = renderAtlasFrameGraph(atlasFrame, {\n    layout: \"force-directed\",\n    layoutConfig: {\n      iterations: 100,\n    },\n  });\n\n  const renderTime = Date.now() - startTime;\n\n  if (!svg.includes(\"<svg\")) {\n    throw new Error(\"Large graph rendering failed\");\n  }\n\n  const outputPath = join(TEST_OUTPUT_DIR, \"test-large-graph.svg\");\n  writeFileSync(outputPath, svg);\n\n  console.log(`✓ Large graph rendered in ${renderTime}ms`);\n  console.log(`  Saved to: ${outputPath}`);\n\n  // Check performance requirement (< 500ms for < 100 nodes)\n  if (renderTime > PERFORMANCE_TARGET_MS) {\n    console.warn(`  ⚠ Render time ${renderTime}ms exceeds target of ${PERFORMANCE_TARGET_MS}ms`);\n  } else {\n    console.log(`  ✓ Performance requirement met (${renderTime}ms < ${PERFORMANCE_TARGET_MS}ms)`);\n  }\n}\n\n/**\n * Test 7: Test edge cases\n */\nasync function testEdgeCases() {\n  console.log(\"Test 7: Testing edge cases...\");\n\n  // Empty graph\n  const emptyFrame: AtlasFrame = {\n    atlas_timestamp: new Date().toISOString(),\n    seed_modules: [],\n    fold_radius: 0,\n    modules: [],\n    edges: [],\n    critical_rule: \"Test\",\n  };\n\n  const emptySvg = renderAtlasFrameGraph(emptyFrame);\n  if (!emptySvg.includes(\"<svg\")) {\n    throw new Error(\"Empty graph should still render SVG container\");\n  }\n\n  // Single node\n  const singleNodeFrame: AtlasFrame = {\n    atlas_timestamp: new Date().toISOString(),\n    seed_modules: [\"single\"],\n    fold_radius: 0,\n    modules: [{ id: \"single\", coords: [400, 300] }],\n    edges: [],\n    critical_rule: \"Test\",\n  };\n\n  const singleSvg = renderAtlasFrameGraph(singleNodeFrame);\n  if (!singleSvg.includes(\"circle\")) {\n    throw new Error(\"Single node graph should render a circle\");\n  }\n\n  console.log(`✓ Edge cases handled correctly`);\n}\n\n/**\n * Run all tests\n */\nasync function runTests() {\n  console.log(\"=== Graph Renderer Test Suite ===\\n\");\n\n  // Create output directory\n  try {\n    mkdirSync(TEST_OUTPUT_DIR, { recursive: true });\n  } catch (err) {\n    // Directory already exists\n  }\n\n  try {\n    await testBasicSVGRendering();\n    console.log();\n\n    await testForceDirectedLayout();\n    console.log();\n\n    await testHierarchicalLayout();\n    console.log();\n\n    await testPNGExport();\n    console.log();\n\n    await testCustomColors();\n    console.log();\n\n    await testLargeGraphPerformance();\n    console.log();\n\n    await testEdgeCases();\n    console.log();\n\n    console.log(\"=== All Tests Passed ✓ ===\");\n    console.log(`\\nTest outputs saved to: ${TEST_OUTPUT_DIR}`);\n    console.log(\"Open the SVG and PNG files to visually verify rendering quality.\");\n  } catch (error) {\n    console.error(\"\\n=== Test Failed ✗ ===\");\n    console.error(error);\n    process.exit(1);\n  }\n}\n\n// Run tests if this file is executed directly\nrunTests();\n","usedDeprecatedRules":[]},{"filePath":"/srv/lex-mcp/lex/test/memory/renderer/syntax.test.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":35,"column":64,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":35,"endColumn":67,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1148,1151],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1148,1151],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Test suite for syntax highlighting\n */\n\nimport { describe, test } from \"node:test\";\nimport assert from \"node:assert\";\nimport {\n  highlightCode,\n  highlightDiff,\n  detectLanguageFromExtension,\n  isLanguageSupported,\n  SUPPORTED_LANGUAGES,\n} from \"@app/memory/renderer/syntax.js\";\n\ndescribe(\"Syntax Highlighting\", () => {\n  test(\"highlightCode - TypeScript\", async () => {\n    const code = 'function hello() {\\n  console.log(\"world\");\\n}';\n    const result = await highlightCode(code, \"typescript\");\n\n    assert.ok(result.includes(\"<pre\"), \"Should contain pre tag\");\n    assert.ok(result.includes(\"function\"), \"Should contain the code\");\n  });\n\n  test(\"highlightCode - Python\", async () => {\n    const code = 'def hello():\\n    print(\"world\")';\n    const result = await highlightCode(code, \"python\");\n\n    assert.ok(result.includes(\"<pre\"), \"Should contain pre tag\");\n    assert.ok(result.includes(\"def\"), \"Should contain the code\");\n  });\n\n  test(\"highlightCode - fallback on error\", async () => {\n    const code = \"test code\";\n    // Use an invalid language to trigger fallback\n    const result = await highlightCode(code, \"invalid-lang\" as any);\n\n    assert.ok(result.includes(\"test code\"), \"Should contain the code in fallback\");\n  });\n\n  test(\"highlightDiff - additions and deletions\", async () => {\n    const diff = '+ function hello() {\\n+   console.log(\"world\");\\n+ }';\n    const result = await highlightDiff(diff, \"typescript\");\n\n    assert.ok(result.includes(\"diff-addition\"), \"Should mark additions\");\n    assert.ok(result.includes(\"function\"), \"Should contain the code\");\n  });\n\n  test(\"detectLanguageFromExtension - TypeScript\", () => {\n    assert.strictEqual(detectLanguageFromExtension(\"file.ts\"), \"typescript\");\n    assert.strictEqual(detectLanguageFromExtension(\"file.tsx\"), \"typescript\");\n  });\n\n  test(\"detectLanguageFromExtension - JavaScript\", () => {\n    assert.strictEqual(detectLanguageFromExtension(\"file.js\"), \"javascript\");\n    assert.strictEqual(detectLanguageFromExtension(\"file.jsx\"), \"javascript\");\n  });\n\n  test(\"detectLanguageFromExtension - Python\", () => {\n    assert.strictEqual(detectLanguageFromExtension(\"file.py\"), \"python\");\n  });\n\n  test(\"detectLanguageFromExtension - default\", () => {\n    assert.strictEqual(detectLanguageFromExtension(\"file.unknown\"), \"typescript\");\n    assert.strictEqual(detectLanguageFromExtension(\"noextension\"), \"typescript\");\n  });\n\n  test(\"isLanguageSupported - valid languages\", () => {\n    assert.ok(isLanguageSupported(\"typescript\"));\n    assert.ok(isLanguageSupported(\"javascript\"));\n    assert.ok(isLanguageSupported(\"python\"));\n  });\n\n  test(\"isLanguageSupported - invalid language\", () => {\n    assert.ok(!isLanguageSupported(\"not-a-language\"));\n  });\n\n  test(\"SUPPORTED_LANGUAGES - contains common languages\", () => {\n    assert.ok(SUPPORTED_LANGUAGES.includes(\"typescript\"));\n    assert.ok(SUPPORTED_LANGUAGES.includes(\"javascript\"));\n    assert.ok(SUPPORTED_LANGUAGES.includes(\"python\"));\n    assert.ok(SUPPORTED_LANGUAGES.includes(\"java\"));\n    assert.ok(SUPPORTED_LANGUAGES.includes(\"go\"));\n  });\n});\n","usedDeprecatedRules":[]},{"filePath":"/srv/lex-mcp/lex/test/memory/renderer/timeline.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/srv/lex-mcp/lex/test/memory/store/images.perf.test.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'e' is defined but never used.","line":35,"column":16,"nodeType":null,"messageId":"unusedVar","endLine":35,"endColumn":17},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'frameStore' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":58,"column":13,"nodeType":null,"messageId":"unusedVar","endLine":58,"endColumn":23},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'frameStore' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":106,"column":13,"nodeType":null,"messageId":"unusedVar","endLine":106,"endColumn":23},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'frameStore' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":158,"column":13,"nodeType":null,"messageId":"unusedVar","endLine":158,"endColumn":23},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'frameStore' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":197,"column":13,"nodeType":null,"messageId":"unusedVar","endLine":197,"endColumn":23}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Performance Tests for Image Storage\n *\n * Tests image storage and retrieval performance with large datasets.\n */\n\nimport { test, describe } from \"node:test\";\nimport assert from \"node:assert\";\nimport { FrameStore } from \"@app/memory/store/framestore.js\";\nimport { ImageManager } from \"@app/memory/store/images.js\";\nimport { mkdtempSync, rmSync } from \"fs\";\nimport { join } from \"path\";\nimport { tmpdir } from \"os\";\n\ndescribe(\"Image Manager - Performance\", () => {\n  let frameStore: FrameStore;\n  let imageManager: ImageManager;\n  let testDbPath: string;\n\n  function setup() {\n    const tmpDir = mkdtempSync(join(tmpdir(), \"lex-perf-test-\"));\n    testDbPath = join(tmpDir, \"test-perf.db\");\n    frameStore = new FrameStore(testDbPath);\n    imageManager = new ImageManager(frameStore.getDatabase());\n    return { frameStore, imageManager };\n  }\n\n  function teardown() {\n    if (frameStore) {\n      frameStore.close();\n    }\n    if (testDbPath) {\n      try {\n        rmSync(testDbPath, { force: true });\n      } catch (e) {\n        // Ignore cleanup errors\n      }\n    }\n  }\n\n  function createTestFrame(id: string) {\n    const frame = {\n      id,\n      timestamp: new Date().toISOString(),\n      branch: \"main\",\n      module_scope: [\"test/module\"],\n      summary_caption: \"Test frame\",\n      reference_point: \"test reference\",\n      status_snapshot: {\n        next_action: \"Test action\",\n      },\n    };\n    frameStore.insertFrame(frame);\n    return frame;\n  }\n\n  test(\"store and retrieve 100 images efficiently\", () => {\n    const { frameStore, imageManager } = setup();\n    try {\n      const imageCount = 100;\n      const imageSize = 1024; // 1KB per image\n      const imageIds: string[] = [];\n\n      // Create 10 frames with 10 images each\n      const startStore = Date.now();\n      for (let f = 0; f < 10; f++) {\n        const frame = createTestFrame(`frame-${f}`);\n\n        for (let i = 0; i < 10; i++) {\n          const imageData = Buffer.alloc(imageSize, `img-${f}-${i}`);\n          const imageId = imageManager.storeImage(frame.id, imageData, \"image/png\");\n          imageIds.push(imageId);\n        }\n      }\n      const storeTime = Date.now() - startStore;\n\n      console.log(\n        `  Stored ${imageCount} images in ${storeTime}ms (${(storeTime / imageCount).toFixed(2)}ms per image)`\n      );\n\n      // Verify all images were stored\n      const totalCount = imageManager.getImageCount();\n      assert.strictEqual(totalCount, imageCount, `Should have ${imageCount} images`);\n\n      // Retrieve all images\n      const startRetrieve = Date.now();\n      for (const imageId of imageIds) {\n        const retrieved = imageManager.getImage(imageId);\n        assert.ok(retrieved, `Image ${imageId} should be retrievable`);\n      }\n      const retrieveTime = Date.now() - startRetrieve;\n\n      console.log(\n        `  Retrieved ${imageCount} images in ${retrieveTime}ms (${(retrieveTime / imageCount).toFixed(2)}ms per image)`\n      );\n\n      // Performance assertions\n      assert.ok(storeTime < 5000, \"Storing 100 images should take less than 5 seconds\");\n      assert.ok(retrieveTime < 2000, \"Retrieving 100 images should take less than 2 seconds\");\n    } finally {\n      teardown();\n    }\n  });\n\n  test(\"list images for frames with many attachments\", () => {\n    const { frameStore, imageManager } = setup();\n    try {\n      const imagesPerFrame = 20;\n      const frameCount = 10;\n\n      // Create frames with many images\n      const startSetup = Date.now();\n      for (let f = 0; f < frameCount; f++) {\n        const frame = createTestFrame(`frame-${f}`);\n\n        for (let i = 0; i < imagesPerFrame; i++) {\n          const imageData = Buffer.alloc(512, `data-${f}-${i}`);\n          imageManager.storeImage(frame.id, imageData, \"image/png\");\n        }\n      }\n      const setupTime = Date.now() - startSetup;\n      console.log(\n        `  Setup ${frameCount} frames with ${imagesPerFrame} images each in ${setupTime}ms`\n      );\n\n      // List images for each frame\n      const startList = Date.now();\n      for (let f = 0; f < frameCount; f++) {\n        const images = imageManager.listFrameImages(`frame-${f}`);\n        assert.strictEqual(\n          images.length,\n          imagesPerFrame,\n          `Frame ${f} should have ${imagesPerFrame} images`\n        );\n\n        // Verify metadata\n        for (const img of images) {\n          assert.strictEqual(img.frame_id, `frame-${f}`, \"Frame ID should match\");\n          assert.strictEqual(img.mime_type, \"image/png\", \"MIME type should match\");\n          assert.ok(img.size > 0, \"Size should be positive\");\n          assert.ok(img.created_at > 0, \"Created timestamp should be set\");\n        }\n      }\n      const listTime = Date.now() - startList;\n\n      console.log(\n        `  Listed images for ${frameCount} frames in ${listTime}ms (${(listTime / frameCount).toFixed(2)}ms per frame)`\n      );\n\n      // Performance assertion\n      assert.ok(listTime < 1000, \"Listing images for 10 frames should take less than 1 second\");\n    } finally {\n      teardown();\n    }\n  });\n\n  test(\"delete operations with large datasets\", () => {\n    const { frameStore, imageManager } = setup();\n    try {\n      const imageCount = 50;\n      const frame = createTestFrame(\"delete-test-frame\");\n      const imageIds: string[] = [];\n\n      // Store images\n      for (let i = 0; i < imageCount; i++) {\n        const imageData = Buffer.alloc(256, `data-${i}`);\n        const imageId = imageManager.storeImage(frame.id, imageData, \"image/png\");\n        imageIds.push(imageId);\n      }\n\n      assert.strictEqual(imageManager.getImageCount(), imageCount, \"Should have all images\");\n\n      // Delete images individually\n      const startDelete = Date.now();\n      let deleteCount = 0;\n      for (const imageId of imageIds) {\n        const deleted = imageManager.deleteImage(imageId);\n        if (deleted) deleteCount++;\n      }\n      const deleteTime = Date.now() - startDelete;\n\n      console.log(\n        `  Deleted ${deleteCount} images in ${deleteTime}ms (${(deleteTime / deleteCount).toFixed(2)}ms per image)`\n      );\n\n      assert.strictEqual(deleteCount, imageCount, \"Should have deleted all images\");\n      assert.strictEqual(imageManager.getImageCount(), 0, \"Should have no images left\");\n\n      // Performance assertion\n      assert.ok(deleteTime < 2000, \"Deleting 50 images should take less than 2 seconds\");\n    } finally {\n      teardown();\n    }\n  });\n\n  test(\"total storage size calculation with many images\", () => {\n    const { frameStore, imageManager } = setup();\n    try {\n      const imageSize = 2048; // 2KB per image\n      const imageCount = 100;\n      let expectedTotal = 0;\n\n      // Store images of varying sizes\n      for (let i = 0; i < imageCount; i++) {\n        const frameId = `size-frame-${i}`;\n        const frame = createTestFrame(frameId);\n        const size = imageSize + i * 10; // Gradually increasing size\n        const imageData = Buffer.alloc(size, `data-${i}`);\n        imageManager.storeImage(frame.id, imageData, \"image/png\");\n        expectedTotal += size;\n      }\n\n      const actualTotal = imageManager.getTotalImageSize();\n      assert.strictEqual(actualTotal, expectedTotal, \"Total size should match sum of all images\");\n\n      console.log(\n        `  Total storage: ${(actualTotal / 1024 / 1024).toFixed(2)} MB for ${imageCount} images`\n      );\n      console.log(`  Average size: ${(actualTotal / imageCount / 1024).toFixed(2)} KB per image`);\n    } finally {\n      teardown();\n    }\n  });\n\n  test(\"cascading delete performance with many images\", () => {\n    const { frameStore, imageManager } = setup();\n    try {\n      const framesCount = 5;\n      const imagesPerFrame = 20;\n\n      // Create frames with images\n      for (let f = 0; f < framesCount; f++) {\n        const frame = createTestFrame(`cascade-frame-${f}`);\n\n        for (let i = 0; i < imagesPerFrame; i++) {\n          const imageData = Buffer.alloc(128, `data-${f}-${i}`);\n          imageManager.storeImage(frame.id, imageData, \"image/png\");\n        }\n      }\n\n      const totalImages = framesCount * imagesPerFrame;\n      assert.strictEqual(imageManager.getImageCount(), totalImages, \"Should have all images\");\n\n      // Delete frames (should cascade to images)\n      const startCascade = Date.now();\n      for (let f = 0; f < framesCount; f++) {\n        frameStore.deleteFrame(`cascade-frame-${f}`);\n      }\n      const cascadeTime = Date.now() - startCascade;\n\n      console.log(\n        `  Cascading delete of ${framesCount} frames (${totalImages} images) in ${cascadeTime}ms`\n      );\n\n      // Verify all images were deleted\n      assert.strictEqual(imageManager.getImageCount(), 0, \"All images should be deleted\");\n\n      // Performance assertion\n      assert.ok(cascadeTime < 1000, \"Cascading delete should take less than 1 second\");\n    } finally {\n      teardown();\n    }\n  });\n});\n","usedDeprecatedRules":[]},{"filePath":"/srv/lex-mcp/lex/test/memory/store/images.test.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'e' is defined but never used.","line":38,"column":16,"nodeType":null,"messageId":"unusedVar","endLine":38,"endColumn":17},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'frameStore' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":62,"column":13,"nodeType":null,"messageId":"unusedVar","endLine":62,"endColumn":23},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'frameStore' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":78,"column":13,"nodeType":null,"messageId":"unusedVar","endLine":78,"endColumn":23},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'frameStore' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":93,"column":13,"nodeType":null,"messageId":"unusedVar","endLine":93,"endColumn":23},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'frameStore' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":111,"column":13,"nodeType":null,"messageId":"unusedVar","endLine":111,"endColumn":23},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'frameStore' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":128,"column":13,"nodeType":null,"messageId":"unusedVar","endLine":128,"endColumn":23},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'frameStore' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":146,"column":13,"nodeType":null,"messageId":"unusedVar","endLine":146,"endColumn":23},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'frameStore' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":163,"column":13,"nodeType":null,"messageId":"unusedVar","endLine":163,"endColumn":23},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'frameStore' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":179,"column":13,"nodeType":null,"messageId":"unusedVar","endLine":179,"endColumn":23},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'frameStore' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":208,"column":13,"nodeType":null,"messageId":"unusedVar","endLine":208,"endColumn":23},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'frameStore' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":220,"column":13,"nodeType":null,"messageId":"unusedVar","endLine":220,"endColumn":23},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'frameStore' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":238,"column":13,"nodeType":null,"messageId":"unusedVar","endLine":238,"endColumn":23},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'frameStore' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":248,"column":13,"nodeType":null,"messageId":"unusedVar","endLine":248,"endColumn":23},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'frameStore' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":278,"column":13,"nodeType":null,"messageId":"unusedVar","endLine":278,"endColumn":23},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'imageId' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":284,"column":13,"nodeType":null,"messageId":"unusedVar","endLine":284,"endColumn":20},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'frameStore' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":302,"column":13,"nodeType":null,"messageId":"unusedVar","endLine":302,"endColumn":23},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'frameStore' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":320,"column":13,"nodeType":null,"messageId":"unusedVar","endLine":320,"endColumn":23},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'frameStore' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":338,"column":13,"nodeType":null,"messageId":"unusedVar","endLine":338,"endColumn":23},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'frameStore' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":354,"column":13,"nodeType":null,"messageId":"unusedVar","endLine":354,"endColumn":23}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":19,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Tests for Image Manager\n *\n * Tests image storage, retrieval, validation, and management operations.\n * Uses Node.js built-in test runner (node:test) - no external dependencies.\n */\n\nimport { test, describe } from \"node:test\";\nimport assert from \"node:assert\";\nimport { FrameStore } from \"@app/memory/store/framestore.js\";\nimport { ImageManager, MAX_IMAGE_SIZE } from \"@app/memory/store/images.js\";\nimport { mkdtempSync, rmSync } from \"fs\";\nimport { join } from \"path\";\nimport { tmpdir } from \"os\";\n\ndescribe(\"Image Manager\", () => {\n  let frameStore: FrameStore;\n  let imageManager: ImageManager;\n  let testDbPath: string;\n\n  // Setup: create test database in temp directory\n  function setup() {\n    const tmpDir = mkdtempSync(join(tmpdir(), \"lex-img-test-\"));\n    testDbPath = join(tmpDir, \"test-images.db\");\n    frameStore = new FrameStore(testDbPath);\n    imageManager = new ImageManager(frameStore.getDatabase());\n    return { frameStore, imageManager };\n  }\n\n  // Teardown: close database and cleanup\n  function teardown() {\n    if (frameStore) {\n      frameStore.close();\n    }\n    if (testDbPath) {\n      try {\n        rmSync(testDbPath, { force: true });\n      } catch (e) {\n        // Ignore cleanup errors\n      }\n    }\n  }\n\n  // Helper to create a test Frame\n  function createTestFrame(frameId: string = \"test-frame-001\") {\n    const frame = {\n      id: frameId,\n      timestamp: new Date().toISOString(),\n      branch: \"main\",\n      module_scope: [\"test/module\"],\n      summary_caption: \"Test frame\",\n      reference_point: \"test reference\",\n      status_snapshot: {\n        next_action: \"Test action\",\n      },\n    };\n    frameStore.insertFrame(frame);\n    return frame;\n  }\n\n  test(\"storeImage stores a PNG image successfully\", () => {\n    const { frameStore, imageManager } = setup();\n    try {\n      const frame = createTestFrame();\n      const imageData = Buffer.from(\"fake-png-data\");\n      const mimeType = \"image/png\";\n\n      const imageId = imageManager.storeImage(frame.id, imageData, mimeType);\n\n      assert.ok(imageId, \"Image ID should be returned\");\n      assert.ok(imageId.startsWith(\"img-\"), \"Image ID should have correct prefix\");\n    } finally {\n      teardown();\n    }\n  });\n\n  test(\"storeImage stores a JPEG image successfully\", () => {\n    const { frameStore, imageManager } = setup();\n    try {\n      const frame = createTestFrame();\n      const imageData = Buffer.from(\"fake-jpeg-data\");\n      const mimeType = \"image/jpeg\";\n\n      const imageId = imageManager.storeImage(frame.id, imageData, mimeType);\n\n      assert.ok(imageId, \"Image ID should be returned\");\n    } finally {\n      teardown();\n    }\n  });\n\n  test(\"getImage retrieves stored PNG image\", () => {\n    const { frameStore, imageManager } = setup();\n    try {\n      const frame = createTestFrame();\n      const imageData = Buffer.from(\"fake-png-data\");\n      const mimeType = \"image/png\";\n\n      const imageId = imageManager.storeImage(frame.id, imageData, mimeType);\n      const retrieved = imageManager.getImage(imageId);\n\n      assert.ok(retrieved, \"Image should be retrieved\");\n      assert.strictEqual(retrieved!.mimeType, mimeType, \"MIME type should match\");\n      assert.deepStrictEqual(retrieved!.data, imageData, \"Image data should match\");\n    } finally {\n      teardown();\n    }\n  });\n\n  test(\"getImage retrieves stored JPEG image\", () => {\n    const { frameStore, imageManager } = setup();\n    try {\n      const frame = createTestFrame();\n      const imageData = Buffer.from(\"fake-jpeg-data\");\n      const mimeType = \"image/jpeg\";\n\n      const imageId = imageManager.storeImage(frame.id, imageData, mimeType);\n      const retrieved = imageManager.getImage(imageId);\n\n      assert.ok(retrieved, \"Image should be retrieved\");\n      assert.strictEqual(retrieved!.mimeType, mimeType, \"MIME type should match\");\n    } finally {\n      teardown();\n    }\n  });\n\n  test(\"storeImage rejects image exceeding 10MB size limit\", () => {\n    const { frameStore, imageManager } = setup();\n    try {\n      const frame = createTestFrame();\n      // Create buffer larger than 10MB\n      const imageData = Buffer.alloc(MAX_IMAGE_SIZE + 1);\n      const mimeType = \"image/png\";\n\n      assert.throws(\n        () => imageManager.storeImage(frame.id, imageData, mimeType),\n        /exceeds maximum/,\n        \"Should reject oversized image\"\n      );\n    } finally {\n      teardown();\n    }\n  });\n\n  test(\"storeImage rejects invalid MIME type\", () => {\n    const { frameStore, imageManager } = setup();\n    try {\n      const frame = createTestFrame();\n      const imageData = Buffer.from(\"fake-data\");\n      const invalidMimeType = \"application/pdf\";\n\n      assert.throws(\n        () => imageManager.storeImage(frame.id, imageData, invalidMimeType),\n        /Invalid MIME type/,\n        \"Should reject invalid MIME type\"\n      );\n    } finally {\n      teardown();\n    }\n  });\n\n  test(\"storeImage rejects image for non-existent Frame\", () => {\n    const { frameStore, imageManager } = setup();\n    try {\n      const imageData = Buffer.from(\"fake-png-data\");\n      const mimeType = \"image/png\";\n\n      assert.throws(\n        () => imageManager.storeImage(\"nonexistent-frame\", imageData, mimeType),\n        /Frame not found/,\n        \"Should reject image for non-existent frame\"\n      );\n    } finally {\n      teardown();\n    }\n  });\n\n  test(\"listFrameImages returns all images for a Frame\", () => {\n    const { frameStore, imageManager } = setup();\n    try {\n      const frame = createTestFrame();\n      const imageData1 = Buffer.from(\"image-1\");\n      const imageData2 = Buffer.from(\"image-2\");\n\n      const imageId1 = imageManager.storeImage(frame.id, imageData1, \"image/png\");\n      const imageId2 = imageManager.storeImage(frame.id, imageData2, \"image/jpeg\");\n\n      const images = imageManager.listFrameImages(frame.id);\n\n      assert.strictEqual(images.length, 2, \"Should return 2 images\");\n      assert.ok(\n        images.some((img) => img.image_id === imageId1),\n        \"Should include first image\"\n      );\n      assert.ok(\n        images.some((img) => img.image_id === imageId2),\n        \"Should include second image\"\n      );\n      assert.strictEqual(images[0].frame_id, frame.id, \"Frame ID should match\");\n      assert.strictEqual(images[0].mime_type, \"image/png\", \"First MIME type should be PNG\");\n      assert.strictEqual(images[1].mime_type, \"image/jpeg\", \"Second MIME type should be JPEG\");\n    } finally {\n      teardown();\n    }\n  });\n\n  test(\"listFrameImages returns empty array for Frame with no images\", () => {\n    const { frameStore, imageManager } = setup();\n    try {\n      const frame = createTestFrame();\n      const images = imageManager.listFrameImages(frame.id);\n\n      assert.strictEqual(images.length, 0, \"Should return empty array\");\n    } finally {\n      teardown();\n    }\n  });\n\n  test(\"deleteImage removes image from storage\", () => {\n    const { frameStore, imageManager } = setup();\n    try {\n      const frame = createTestFrame();\n      const imageData = Buffer.from(\"fake-png-data\");\n\n      const imageId = imageManager.storeImage(frame.id, imageData, \"image/png\");\n\n      const deleted = imageManager.deleteImage(imageId);\n      assert.strictEqual(deleted, true, \"Should return true for successful deletion\");\n\n      const retrieved = imageManager.getImage(imageId);\n      assert.strictEqual(retrieved, null, \"Image should no longer exist\");\n    } finally {\n      teardown();\n    }\n  });\n\n  test(\"deleteImage returns false for non-existent image\", () => {\n    const { frameStore, imageManager } = setup();\n    try {\n      const deleted = imageManager.deleteImage(\"nonexistent-image-id\");\n      assert.strictEqual(deleted, false, \"Should return false for non-existent image\");\n    } finally {\n      teardown();\n    }\n  });\n\n  test(\"multiple images per Frame are supported\", () => {\n    const { frameStore, imageManager } = setup();\n    try {\n      const frame = createTestFrame();\n      const imageIds: string[] = [];\n\n      // Store 5 images\n      for (let i = 0; i < 5; i++) {\n        const imageData = Buffer.from(`image-data-${i}`);\n        const imageId = imageManager.storeImage(\n          frame.id,\n          imageData,\n          i % 2 === 0 ? \"image/png\" : \"image/jpeg\"\n        );\n        imageIds.push(imageId);\n      }\n\n      const images = imageManager.listFrameImages(frame.id);\n      assert.strictEqual(images.length, 5, \"Should have 5 images\");\n\n      // Verify all images can be retrieved\n      for (const imageId of imageIds) {\n        const retrieved = imageManager.getImage(imageId);\n        assert.ok(retrieved, `Image ${imageId} should be retrievable`);\n      }\n    } finally {\n      teardown();\n    }\n  });\n\n  test(\"image metadata includes size and created_at\", () => {\n    const { frameStore, imageManager } = setup();\n    try {\n      const frame = createTestFrame();\n      const imageData = Buffer.from(\"test-image-data\");\n\n      const beforeTime = Date.now();\n      const imageId = imageManager.storeImage(frame.id, imageData, \"image/png\");\n      const afterTime = Date.now();\n\n      const images = imageManager.listFrameImages(frame.id);\n      assert.strictEqual(images.length, 1, \"Should have 1 image\");\n\n      const metadata = images[0];\n      assert.strictEqual(metadata.size, imageData.length, \"Size should match\");\n      assert.ok(\n        metadata.created_at >= beforeTime && metadata.created_at <= afterTime,\n        \"created_at should be within expected range\"\n      );\n    } finally {\n      teardown();\n    }\n  });\n\n  test(\"getImageCount returns total number of images\", () => {\n    const { frameStore, imageManager } = setup();\n    try {\n      const frame1 = createTestFrame(\"frame-1\");\n      const frame2 = createTestFrame(\"frame-2\");\n\n      assert.strictEqual(imageManager.getImageCount(), 0, \"Should start with 0 images\");\n\n      imageManager.storeImage(frame1.id, Buffer.from(\"img1\"), \"image/png\");\n      assert.strictEqual(imageManager.getImageCount(), 1, \"Should have 1 image\");\n\n      imageManager.storeImage(frame2.id, Buffer.from(\"img2\"), \"image/jpeg\");\n      assert.strictEqual(imageManager.getImageCount(), 2, \"Should have 2 images\");\n    } finally {\n      teardown();\n    }\n  });\n\n  test(\"getTotalImageSize returns sum of all image sizes\", () => {\n    const { frameStore, imageManager } = setup();\n    try {\n      const frame = createTestFrame();\n\n      const img1 = Buffer.from(\"image-1\"); // 7 bytes\n      const img2 = Buffer.from(\"image-22\"); // 8 bytes\n\n      imageManager.storeImage(frame.id, img1, \"image/png\");\n      imageManager.storeImage(frame.id, img2, \"image/jpeg\");\n\n      const totalSize = imageManager.getTotalImageSize();\n      assert.strictEqual(totalSize, img1.length + img2.length, \"Total size should match\");\n    } finally {\n      teardown();\n    }\n  });\n\n  test(\"SVG images are supported\", () => {\n    const { frameStore, imageManager } = setup();\n    try {\n      const frame = createTestFrame();\n      const svgData = Buffer.from('<svg><circle r=\"10\"/></svg>');\n\n      const imageId = imageManager.storeImage(frame.id, svgData, \"image/svg+xml\");\n      const retrieved = imageManager.getImage(imageId);\n\n      assert.ok(retrieved, \"SVG should be stored and retrieved\");\n      assert.strictEqual(retrieved!.mimeType, \"image/svg+xml\", \"MIME type should be SVG\");\n    } finally {\n      teardown();\n    }\n  });\n\n  test(\"image with exactly 10MB is accepted\", () => {\n    const { frameStore, imageManager } = setup();\n    try {\n      const frame = createTestFrame();\n      const imageData = Buffer.alloc(MAX_IMAGE_SIZE); // Exactly 10MB\n\n      const imageId = imageManager.storeImage(frame.id, imageData, \"image/png\");\n      assert.ok(imageId, \"10MB image should be accepted\");\n    } finally {\n      teardown();\n    }\n  });\n\n  test(\"cascading delete removes images when Frame is deleted\", () => {\n    const { frameStore, imageManager } = setup();\n    try {\n      const frame = createTestFrame();\n      const imageData = Buffer.from(\"test-image\");\n\n      const imageId = imageManager.storeImage(frame.id, imageData, \"image/png\");\n\n      // Verify image exists\n      let retrieved = imageManager.getImage(imageId);\n      assert.ok(retrieved, \"Image should exist\");\n\n      // Delete the Frame (this should cascade to images via foreign key)\n      frameStore.deleteFrame(frame.id);\n\n      // Verify image was deleted\n      retrieved = imageManager.getImage(imageId);\n      assert.strictEqual(retrieved, null, \"Image should be deleted with Frame\");\n    } finally {\n      teardown();\n    }\n  });\n});\n","usedDeprecatedRules":[]},{"filePath":"/srv/lex-mcp/lex/test/memory/store/store.test.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'createDatabase' is defined but never used. Allowed unused vars must match /^_/u.","line":25,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":25,"endColumn":17},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .id on an `error` typed value.","line":135,"column":48,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":135,"endColumn":50},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .reference_point on an `error` typed value.","line":136,"column":61,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":136,"endColumn":76},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .module_scope on an `error` typed value.","line":137,"column":62,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":137,"endColumn":74},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .keywords on an `error` typed value.","line":138,"column":58,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":138,"endColumn":66},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":1,"message":"Unsafe assignment of an `any` value.","line":147,"column":13,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":150,"endColumn":8},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .id on an `error` typed value.","line":312,"column":31,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":312,"endColumn":33},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":1,"message":"Unsafe assignment of an `any` value.","line":516,"column":13,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":524,"endColumn":8}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":8,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Tests for Frame storage\n *\n * Run with: npm test\n * Or directly with tsx: npx tsx --test store.test.ts\n */\n\nimport { test, describe, before, after } from \"node:test\";\nimport assert from \"node:assert\";\nimport { unlinkSync, existsSync } from \"fs\";\nimport { tmpdir } from \"os\";\nimport { join } from \"path\";\nimport {\n  getDb,\n  closeDb,\n  saveFrame,\n  getFrameById,\n  searchFrames,\n  getFramesByBranch,\n  getFramesByJira,\n  getFramesByModuleScope,\n  getAllFrames,\n  deleteFrame,\n  getFrameCount,\n  createDatabase,\n} from \"@app/memory/store/index.js\";\nimport type { Frame } from \"../frames/types.js\";\n\n// Test database path\nconst TEST_DB_PATH = join(tmpdir(), `test-frames-${Date.now()}.db`);\n\n// Sample test frames\nconst testFrame1: Frame = {\n  id: \"frame-001\",\n  timestamp: \"2025-11-01T16:04:12-05:00\",\n  branch: \"feature/auth-fix\",\n  jira: \"TICKET-123\",\n  module_scope: [\"ui/user-admin-panel\", \"services/auth-core\"],\n  summary_caption: \"Auth handshake timeout; Add User button disabled\",\n  reference_point: \"that auth deadlock\",\n  status_snapshot: {\n    next_action: \"Reroute user-admin-panel to call user-access-api\",\n    merge_blockers: [\"Direct call to auth-core forbidden by policy\"],\n  },\n  keywords: [\"auth\", \"timeout\", \"policy-violation\"],\n  atlas_frame_id: \"atlas-001\",\n  feature_flags: [\"beta_user_admin\"],\n  permissions: [\"can_manage_users\"],\n};\n\nconst testFrame2: Frame = {\n  id: \"frame-002\",\n  timestamp: \"2025-11-02T10:30:00-05:00\",\n  branch: \"feature/payment-integration\",\n  jira: \"TICKET-456\",\n  module_scope: [\"services/payment-gateway\", \"ui/checkout\"],\n  summary_caption: \"Payment gateway integration with Stripe\",\n  reference_point: \"stripe webhook handler\",\n  status_snapshot: {\n    next_action: \"Add webhook signature verification\",\n    blockers: [\"Missing Stripe API keys in env\"],\n  },\n  keywords: [\"payment\", \"stripe\", \"webhook\"],\n};\n\nconst testFrame3: Frame = {\n  id: \"frame-003\",\n  timestamp: \"2025-11-03T14:15:00-05:00\",\n  branch: \"feature/auth-fix\",\n  module_scope: [\"services/auth-core\", \"lib/crypto\"],\n  summary_caption: \"Fixed auth token expiration bug\",\n  reference_point: \"token expiration issue\",\n  status_snapshot: {\n    next_action: \"Deploy to staging\",\n  },\n  keywords: [\"auth\", \"bug-fix\", \"tokens\"],\n};\n\ndescribe(\"Frame Storage Tests\", () => {\n  let db: ReturnType<typeof getDb>;\n\n  before(() => {\n    // Clean up any existing test database\n    if (existsSync(TEST_DB_PATH)) {\n      unlinkSync(TEST_DB_PATH);\n    }\n    db = getDb(TEST_DB_PATH);\n  });\n\n  after(() => {\n    closeDb();\n    // Clean up test database\n    if (existsSync(TEST_DB_PATH)) {\n      unlinkSync(TEST_DB_PATH);\n    }\n  });\n\n  describe(\"Database Initialization\", () => {\n    test(\"should create database file on first use\", () => {\n      assert.ok(existsSync(TEST_DB_PATH), \"Database file should exist\");\n    });\n\n    test(\"should have frames table\", () => {\n      const tables = db\n        .prepare(\"SELECT name FROM sqlite_master WHERE type='table' AND name='frames'\")\n        .all();\n      assert.strictEqual(tables.length, 1, \"frames table should exist\");\n    });\n\n    test(\"should have FTS5 virtual table\", () => {\n      const tables = db\n        .prepare(\"SELECT name FROM sqlite_master WHERE type='table' AND name='frames_fts'\")\n        .all();\n      assert.strictEqual(tables.length, 1, \"frames_fts table should exist\");\n    });\n\n    test(\"should have schema_version table for migrations\", () => {\n      const tables = db\n        .prepare(\"SELECT name FROM sqlite_master WHERE type='table' AND name='schema_version'\")\n        .all();\n      assert.strictEqual(tables.length, 1, \"schema_version table should exist\");\n    });\n  });\n\n  describe(\"CRUD Operations\", () => {\n    test(\"should save a Frame successfully\", async () => {\n      saveFrame(db, testFrame1);\n      const count = getFrameCount(db);\n      assert.strictEqual(count, 1, \"Frame count should be 1 after insert\");\n    });\n\n    test(\"should retrieve Frame by ID\", async () => {\n      const frame = getFrameById(db, \"frame-001\");\n      assert.ok(frame, \"Frame should be found\");\n      assert.strictEqual(frame!.id, testFrame1.id);\n      assert.strictEqual(frame!.reference_point, testFrame1.reference_point);\n      assert.deepStrictEqual(frame!.module_scope, testFrame1.module_scope);\n      assert.deepStrictEqual(frame!.keywords, testFrame1.keywords);\n    });\n\n    test(\"should return null for non-existent Frame ID\", async () => {\n      const frame = getFrameById(db, \"non-existent\");\n      assert.strictEqual(frame, null, \"Should return null for non-existent ID\");\n    });\n\n    test(\"should update existing Frame (upsert)\", async () => {\n      const updatedFrame = {\n        ...testFrame1,\n        summary_caption: \"Updated caption\",\n      };\n      saveFrame(db, updatedFrame);\n      const frame = getFrameById(db, \"frame-001\");\n      assert.strictEqual(frame!.summary_caption, \"Updated caption\");\n      const count = getFrameCount(db);\n      assert.strictEqual(count, 1, \"Frame count should still be 1 after update\");\n    });\n\n    test(\"should delete Frame by ID\", async () => {\n      saveFrame(db, testFrame2);\n      const deleted = deleteFrame(db, \"frame-002\");\n      assert.strictEqual(deleted, true, \"Delete should return true\");\n      const frame = getFrameById(db, \"frame-002\");\n      assert.strictEqual(frame, null, \"Frame should not exist after delete\");\n    });\n\n    test(\"should handle all optional fields correctly\", async () => {\n      const minimalFrame: Frame = {\n        id: \"frame-minimal\",\n        timestamp: \"2025-11-04T12:00:00Z\",\n        branch: \"main\",\n        module_scope: [\"core\"],\n        summary_caption: \"Minimal frame\",\n        reference_point: \"minimal test\",\n        status_snapshot: {\n          next_action: \"nothing\",\n        },\n      };\n      saveFrame(db, minimalFrame);\n      const retrieved = getFrameById(db, \"frame-minimal\");\n      assert.ok(retrieved);\n      assert.strictEqual(retrieved!.jira, undefined);\n      assert.strictEqual(retrieved!.keywords, undefined);\n      assert.strictEqual(retrieved!.atlas_frame_id, undefined);\n      deleteFrame(db, \"frame-minimal\");\n    });\n  });\n\n  describe(\"Search and Query Operations\", () => {\n    before(async () => {\n      // Clean slate for search tests\n      const frames = getAllFrames(db);\n      for (const frame of frames) {\n        deleteFrame(db, frame.id);\n      }\n      // Insert test frames\n      saveFrame(db, testFrame1);\n      saveFrame(db, testFrame2);\n      saveFrame(db, testFrame3);\n    });\n\n    test(\"should search Frames with FTS5 (reference_point match)\", async () => {\n      const result = searchFrames(db, \"auth deadlock\");\n      assert.ok(result.frames.length > 0, \"Should find frames matching 'auth deadlock'\");\n      assert.ok(\n        result.frames.some((f) => f.id === \"frame-001\"),\n        \"Should find frame-001\"\n      );\n    });\n\n    test(\"should search Frames with FTS5 (keywords match)\", async () => {\n      const result = searchFrames(db, \"payment\");\n      assert.ok(result.frames.length > 0, \"Should find frames matching 'payment'\");\n      assert.ok(\n        result.frames.some((f) => f.id === \"frame-002\"),\n        \"Should find frame-002\"\n      );\n    });\n\n    test(\"should search Frames with FTS5 (summary_caption match)\", async () => {\n      const result = searchFrames(db, \"Stripe\");\n      assert.ok(result.frames.length > 0, \"Should find frames matching 'Stripe'\");\n      assert.ok(\n        result.frames.some((f) => f.id === \"frame-002\"),\n        \"Should find frame-002\"\n      );\n    });\n\n    test(\"should get Frames by branch\", async () => {\n      const results = getFramesByBranch(db, \"feature/auth-fix\");\n      assert.strictEqual(results.length, 2, \"Should find 2 frames on feature/auth-fix\");\n      assert.ok(\n        results.some((f) => f.id === \"frame-001\"),\n        \"Should include frame-001\"\n      );\n      assert.ok(\n        results.some((f) => f.id === \"frame-003\"),\n        \"Should include frame-003\"\n      );\n    });\n\n    test(\"should get Frames by Jira ID\", async () => {\n      const results = getFramesByJira(db, \"TICKET-123\");\n      assert.strictEqual(results.length, 1, \"Should find 1 frame for TICKET-123\");\n      assert.strictEqual(results[0].id, \"frame-001\");\n    });\n\n    test(\"should get Frames by module scope\", async () => {\n      const results = getFramesByModuleScope(db, \"services/auth-core\");\n      assert.ok(results.length >= 2, \"Should find at least 2 frames touching services/auth-core\");\n      assert.ok(\n        results.some((f) => f.id === \"frame-001\"),\n        \"Should include frame-001\"\n      );\n      assert.ok(\n        results.some((f) => f.id === \"frame-003\"),\n        \"Should include frame-003\"\n      );\n    });\n\n    test(\"should get all Frames in descending timestamp order\", async () => {\n      const results = getAllFrames(db);\n      assert.strictEqual(results.length, 3, \"Should get all 3 frames\");\n      // Frames should be ordered newest first\n      assert.ok(\n        results[0].timestamp >= results[1].timestamp,\n        \"Results should be in descending timestamp order\"\n      );\n      assert.ok(\n        results[1].timestamp >= results[2].timestamp,\n        \"Results should be in descending timestamp order\"\n      );\n    });\n\n    test(\"should limit results when requested\", async () => {\n      const results = getAllFrames(db, 2);\n      assert.strictEqual(results.length, 2, \"Should return only 2 frames\");\n    });\n\n    test(\"should return empty array for non-matching searches\", async () => {\n      const result = searchFrames(db, \"zzzznonexistent\");\n      assert.strictEqual(result.frames.length, 0, \"Should return empty array for no matches\");\n      assert.strictEqual(\n        result.hint,\n        undefined,\n        \"Should not have hint for normal non-matching search\"\n      );\n    });\n  });\n\n  describe(\"Concurrent Access\", () => {\n    test(\"should handle concurrent writes\", async () => {\n      const concurrentFrames: Frame[] = Array.from({ length: 10 }, (_, i) => ({\n        id: `concurrent-${i}`,\n        timestamp: new Date().toISOString(),\n        branch: \"test-branch\",\n        module_scope: [\"test\"],\n        summary_caption: `Concurrent frame ${i}`,\n        reference_point: `concurrent ${i}`,\n        status_snapshot: {\n          next_action: `action ${i}`,\n        },\n      }));\n\n      // Save all frames concurrently\n      await Promise.all(concurrentFrames.map((f) => saveFrame(db, f)));\n\n      const count = getFrameCount(db);\n      assert.ok(count >= 10, \"All concurrent frames should be saved\");\n\n      // Clean up\n      for (const frame of concurrentFrames) {\n        deleteFrame(db, frame.id);\n      }\n    });\n  });\n\n  describe(\"FTS5 Fuzzy Search\", () => {\n    test(\"should support fuzzy matching with wildcards\", async () => {\n      const result = searchFrames(db, \"auth*\");\n      assert.ok(result.frames.length > 0, \"Should find frames with auth prefix\");\n    });\n\n    test(\"should support multiple search terms\", async () => {\n      const result = searchFrames(db, \"auth timeout\");\n      assert.ok(result.frames.length > 0, \"Should find frames matching multiple terms\");\n    });\n  });\n\n  describe(\"FTS5 Special Character Handling\", () => {\n    test(\"should handle period (.) without throwing error\", async () => {\n      const result = searchFrames(db, \"0.3.0\");\n      assert.strictEqual(result.frames.length, 0, \"Should return empty results\");\n      assert.ok(result.hint, \"Should provide a hint\");\n      assert.ok(\n        result.hint.includes(\"special characters\"),\n        \"Hint should mention special characters\"\n      );\n    });\n\n    test(\"should handle colon (:) without throwing error\", async () => {\n      const result = searchFrames(db, \"TICKET-123:\");\n      assert.strictEqual(result.frames.length, 0, \"Should return empty results\");\n      assert.ok(result.hint, \"Should provide a hint\");\n    });\n\n    test(\"should handle asterisk at start without throwing error\", async () => {\n      const result = searchFrames(db, \"*test\");\n      assert.strictEqual(result.frames.length, 0, \"Should return empty results\");\n      assert.ok(result.hint, \"Should provide a hint\");\n    });\n\n    test(\"should handle hyphen (-) at start without throwing error\", async () => {\n      const result = searchFrames(db, \"-test\");\n      assert.strictEqual(result.frames.length, 0, \"Should return empty results\");\n      assert.ok(result.hint, \"Should provide a hint\");\n    });\n\n    test(\"should suggest simplified query in hint\", async () => {\n      const result = searchFrames(db, \"v0.3.0 release\");\n      assert.strictEqual(result.frames.length, 0, \"Should return empty results\");\n      assert.ok(result.hint, \"Should provide a hint\");\n      assert.ok(\n        result.hint.includes(\"v0 3 0 release\") || result.hint.includes(\"release\"),\n        \"Hint should suggest simplified query\"\n      );\n    });\n  });\n\n  describe(\"Frame Schema v2: Merge-Weave Metadata\", () => {\n    test(\"should save and retrieve Frame with merge-weave metadata\", async () => {\n      const frameWithMergeWeave: Frame = {\n        id: \"frame-mw-001\",\n        timestamp: \"2025-11-09T12:00:00Z\",\n        branch: \"feat/merge-weave\",\n        module_scope: [\"core\"],\n        summary_caption: \"Merge-weave test frame\",\n        reference_point: \"merge weave test\",\n        status_snapshot: {\n          next_action: \"Complete merge-weave\",\n        },\n        runId: \"lexrunner-20251109-abc123\",\n        planHash: \"sha256:7f8c9d1234567890abcdef\",\n        spend: {\n          prompts: 3,\n          tokens_estimated: 1500,\n        },\n      };\n\n      saveFrame(db, frameWithMergeWeave);\n      const retrieved = getFrameById(db, \"frame-mw-001\");\n\n      assert.ok(retrieved, \"Frame should be retrieved\");\n      assert.strictEqual(retrieved!.runId, \"lexrunner-20251109-abc123\", \"runId should match\");\n      assert.strictEqual(\n        retrieved!.planHash,\n        \"sha256:7f8c9d1234567890abcdef\",\n        \"planHash should match\"\n      );\n      assert.ok(retrieved!.spend, \"spend should be present\");\n      assert.strictEqual(retrieved!.spend!.prompts, 3, \"spend.prompts should match\");\n      assert.strictEqual(\n        retrieved!.spend!.tokens_estimated,\n        1500,\n        \"spend.tokens_estimated should match\"\n      );\n\n      deleteFrame(db, \"frame-mw-001\");\n    });\n\n    test(\"should handle partial merge-weave metadata\", async () => {\n      const framePartial: Frame = {\n        id: \"frame-mw-002\",\n        timestamp: \"2025-11-09T12:10:00Z\",\n        branch: \"feat/merge-weave\",\n        module_scope: [\"core\"],\n        summary_caption: \"Partial merge-weave metadata\",\n        reference_point: \"partial test\",\n        status_snapshot: {\n          next_action: \"Test partial fields\",\n        },\n        runId: \"lexrunner-20251109-def456\",\n        // planHash and spend are omitted\n      };\n\n      saveFrame(db, framePartial);\n      const retrieved = getFrameById(db, \"frame-mw-002\");\n\n      assert.ok(retrieved, \"Frame should be retrieved\");\n      assert.strictEqual(retrieved!.runId, \"lexrunner-20251109-def456\", \"runId should match\");\n      assert.strictEqual(retrieved!.planHash, undefined, \"planHash should be undefined\");\n      assert.strictEqual(retrieved!.spend, undefined, \"spend should be undefined\");\n\n      deleteFrame(db, \"frame-mw-002\");\n    });\n\n    test(\"should handle spend with only one field\", async () => {\n      const framePartialSpend: Frame = {\n        id: \"frame-mw-003\",\n        timestamp: \"2025-11-09T12:20:00Z\",\n        branch: \"feat/merge-weave\",\n        module_scope: [\"core\"],\n        summary_caption: \"Partial spend metadata\",\n        reference_point: \"partial spend\",\n        status_snapshot: {\n          next_action: \"Test partial spend\",\n        },\n        spend: {\n          prompts: 5,\n          // tokens_estimated is omitted\n        },\n      };\n\n      saveFrame(db, framePartialSpend);\n      const retrieved = getFrameById(db, \"frame-mw-003\");\n\n      assert.ok(retrieved, \"Frame should be retrieved\");\n      assert.ok(retrieved!.spend, \"spend should be present\");\n      assert.strictEqual(retrieved!.spend!.prompts, 5, \"spend.prompts should match\");\n      assert.strictEqual(\n        retrieved!.spend!.tokens_estimated,\n        undefined,\n        \"spend.tokens_estimated should be undefined\"\n      );\n\n      deleteFrame(db, \"frame-mw-003\");\n    });\n\n    test(\"should maintain backward compatibility with legacy frames\", async () => {\n      const legacyFrame: Frame = {\n        id: \"frame-legacy-001\",\n        timestamp: \"2025-11-09T12:30:00Z\",\n        branch: \"main\",\n        module_scope: [\"core\"],\n        summary_caption: \"Legacy frame without v2 fields\",\n        reference_point: \"legacy test\",\n        status_snapshot: {\n          next_action: \"Test backward compatibility\",\n        },\n        // No merge-weave fields\n      };\n\n      saveFrame(db, legacyFrame);\n      const retrieved = getFrameById(db, \"frame-legacy-001\");\n\n      assert.ok(retrieved, \"Legacy frame should be retrieved\");\n      assert.strictEqual(retrieved!.id, \"frame-legacy-001\", \"id should match\");\n      assert.strictEqual(retrieved!.runId, undefined, \"runId should be undefined for legacy frame\");\n      assert.strictEqual(\n        retrieved!.planHash,\n        undefined,\n        \"planHash should be undefined for legacy frame\"\n      );\n      assert.strictEqual(retrieved!.spend, undefined, \"spend should be undefined for legacy frame\");\n\n      deleteFrame(db, \"frame-legacy-001\");\n    });\n\n    test(\"should allow updating frame from v1 to v2\", async () => {\n      const v1Frame: Frame = {\n        id: \"frame-upgrade-001\",\n        timestamp: \"2025-11-09T12:40:00Z\",\n        branch: \"main\",\n        module_scope: [\"core\"],\n        summary_caption: \"Frame to upgrade\",\n        reference_point: \"upgrade test\",\n        status_snapshot: {\n          next_action: \"Upgrade to v2\",\n        },\n      };\n\n      saveFrame(db, v1Frame);\n      let retrieved = getFrameById(db, \"frame-upgrade-001\");\n      assert.strictEqual(retrieved!.runId, undefined, \"Should start without runId\");\n\n      // Update with v2 fields\n      const v2Frame: Frame = {\n        ...v1Frame,\n        runId: \"lexrunner-20251109-ghi789\",\n        planHash: \"sha256:updated\",\n        spend: {\n          prompts: 2,\n          tokens_estimated: 800,\n        },\n      };\n\n      saveFrame(db, v2Frame);\n      retrieved = getFrameById(db, \"frame-upgrade-001\");\n\n      assert.strictEqual(retrieved!.runId, \"lexrunner-20251109-ghi789\", \"runId should be updated\");\n      assert.strictEqual(retrieved!.planHash, \"sha256:updated\", \"planHash should be updated\");\n      assert.ok(retrieved!.spend, \"spend should be present\");\n      assert.strictEqual(retrieved!.spend!.prompts, 2, \"spend should be updated\");\n\n      deleteFrame(db, \"frame-upgrade-001\");\n    });\n  });\n});\n\n// Summary message\nconsole.log(\n  \"\\n✅ Frame Storage Tests - covering CRUD, FTS5 search, queries, concurrent access, and Frame Schema v2\\n\"\n);\n","usedDeprecatedRules":[]},{"filePath":"/srv/lex-mcp/lex/test/policy/check/check.test.mjs","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/srv/lex-mcp/lex/test/policy/check/reporter.test.ts","messages":[{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":1,"message":"Unsafe assignment of an `any` value.","line":58,"column":9,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":58,"endColumn":36},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .count on an `any` value.","line":59,"column":20,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":59,"endColumn":25},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .status on an `any` value.","line":60,"column":20,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":60,"endColumn":26}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Reporter unit tests\n */\n\nimport { test } from \"node:test\";\nimport { strict as assert } from \"node:assert\";\nimport type { Policy, PolicyModule } from \"@app/shared/types/policy.js\";\nimport type { Violation } from \"@app/policy/check/violations.js\";\nimport { generateReport } from \"@app/policy/check/reporter.js\";\n\nfunction makeViolation(overrides: Partial<Violation> = {}): Violation {\n  const base: Violation = {\n    type: \"forbidden_caller\",\n    module: \"ui/user-admin\",\n    file: \"web-ui/userAdmin/panel.tsx\",\n    message: \"UI cannot call auth-core directly\",\n    details: \"Forbidden call blocked by policy\",\n    target_module: \"services/auth-core\",\n    import_from: \"services/auth-core\",\n  };\n  return { ...base, ...overrides } as Violation;\n}\n\nfunction makePolicy(moduleCount = 3): Policy {\n  const modules: Record<string, PolicyModule> = {};\n  for (let i = 0; i < moduleCount; i++) {\n    modules[`mod/${i}`] = { owns_paths: [\"**/*\"] };\n  }\n  return { modules } as Policy;\n}\n\n// Text format\n\ntest(\"generateReport text - zero violations (no policy)\", () => {\n  const r = generateReport([], { format: \"text\" });\n  assert.equal(r.exitCode, 0);\n  assert.match(r.content, /No violations found/);\n});\n\ntest(\"generateReport text - zero violations (with policy header)\", () => {\n  const policy = makePolicy(5);\n  const r = generateReport([], { policy, format: \"text\" });\n  assert.equal(r.exitCode, 0);\n  assert.match(r.content, /Policy: 5 modules/);\n});\n\ntest(\"generateReport text - one violation\", () => {\n  const r = generateReport([makeViolation()], { format: \"text\" });\n  assert.equal(r.exitCode, 1);\n  assert.match(r.content, /Found 1 violation\\(s\\)/);\n});\n\n// JSON format\n\ntest(\"generateReport json - two violations\", () => {\n  const r = generateReport([makeViolation(), makeViolation({ file: \"b.ts\" })], { format: \"json\" });\n  assert.equal(r.exitCode, 1);\n  const obj = JSON.parse(r.content);\n  assert.equal(obj.count, 2);\n  assert.equal(obj.status, \"violations_found\");\n});\n\n// Markdown format\n\ntest(\"generateReport markdown - zero violations (with policy header)\", () => {\n  const policy = makePolicy(2);\n  const r = generateReport([], { policy, format: \"markdown\" });\n  assert.equal(r.exitCode, 0);\n  assert.match(r.content, /Policy Check Report/);\n  assert.match(r.content, /\\*\\*Policy:\\*\\* 2 modules/);\n});\n\ntest(\"generateReport markdown - one violation, atlas fallback resilience\", () => {\n  // No policy; ensure we never throw and content includes summary\n  const r = generateReport([makeViolation()], { format: \"markdown\" });\n  assert.equal(r.exitCode, 1);\n  assert.match(r.content, /\\*\\*Status:\\*\\* ❌ 1 violation/);\n});\n","usedDeprecatedRules":[]},{"filePath":"/srv/lex-mcp/lex/test/policy/integration.test.mjs","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'merged' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":282,"column":13,"nodeType":null,"messageId":"unusedVar","endLine":282,"endColumn":19},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":369,"column":1,"nodeType":"MemberExpression","messageId":"unexpected","endLine":369,"endColumn":12,"suggestions":[{"fix":{"range":[10995,11067],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Integration tests for Policy Check Pipeline\n *\n * Tests the full policy check integration:\n * - Scanner → merge → check pipeline\n * - Violation detection with real policy\n *\n * Note: This requires policy modules to be built first:\n *   npm run build:merge && npm run build:check\n *\n * Run with: node policy/integration.test.mjs\n */\n\nimport { strict as assert } from \"assert\";\nimport { test, describe } from \"node:test\";\n// Adjusted import path to built dist output\nimport { mergeScans } from \"../../dist/policy/merge/merge.js\";\n\ndescribe(\"Policy Integration Tests\", () => {\n  describe(\"Scanner → Merge Pipeline\", () => {\n    test(\"should complete scan → merge workflow\", () => {\n      // Step 1: Simulate scanner outputs\n      const typescriptScan = {\n        language: \"typescript\",\n        files: [\n          {\n            path: \"src/ui/admin/UserPanel.tsx\",\n            declarations: [{ type: \"component\", name: \"UserPanel\" }],\n            imports: [{ from: \"src/services/auth/AuthCore\", type: \"import_statement\" }],\n            feature_flags: [],\n            permissions: [],\n            warnings: [],\n          },\n        ],\n      };\n\n      const phpScan = {\n        language: \"php\",\n        files: [\n          {\n            path: \"app/Controllers/UserController.php\",\n            declarations: [{ type: \"class\", name: \"UserController\" }],\n            imports: [{ from: \"App\\\\Services\\\\AuthService\", type: \"import_statement\" }],\n            feature_flags: [],\n            permissions: [],\n            warnings: [],\n          },\n        ],\n      };\n\n      // Step 2: Merge scanner outputs\n      const merged = mergeScans([typescriptScan, phpScan]);\n      assert.ok(merged, \"Should merge scanner outputs\");\n      assert.equal(merged.sources.length, 2, \"Should include both sources\");\n      assert.equal(merged.files.length, 2, \"Should include both files\");\n      assert.ok(merged.sources.includes(\"typescript\"));\n      assert.ok(merged.sources.includes(\"php\"));\n    });\n\n    test(\"should pass clean pipeline with no violations\", () => {\n      const scan = {\n        language: \"typescript\",\n        files: [\n          {\n            path: \"src/ui/components/Button.tsx\",\n            declarations: [{ type: \"component\", name: \"Button\" }],\n            imports: [{ from: \"src/services/api/ButtonApi\", type: \"import_statement\" }],\n            feature_flags: [],\n            permissions: [],\n            warnings: [],\n          },\n        ],\n      };\n\n      const merged = mergeScans([scan]);\n      assert.ok(merged, \"Should merge scanner output\");\n      assert.equal(merged.files.length, 1);\n      assert.equal(merged.sources[0], \"typescript\");\n    });\n\n    test(\"should handle multi-language pipeline\", () => {\n      const scans = [\n        {\n          language: \"typescript\",\n          files: [\n            {\n              path: \"frontend/src/App.tsx\",\n              declarations: [],\n              imports: [{ from: \"api/client\", type: \"import_statement\" }],\n              feature_flags: [],\n              permissions: [],\n              warnings: [],\n            },\n          ],\n        },\n        {\n          language: \"python\",\n          files: [\n            {\n              path: \"backend/api/views.py\",\n              declarations: [],\n              imports: [{ from: \"database.models\", type: \"import_statement\" }],\n              feature_flags: [],\n              permissions: [],\n              warnings: [],\n            },\n          ],\n        },\n        {\n          language: \"php\",\n          files: [\n            {\n              path: \"legacy/api/endpoints.php\",\n              declarations: [],\n              imports: [],\n              feature_flags: [],\n              permissions: [],\n              warnings: [],\n            },\n          ],\n        },\n      ];\n\n      const merged = mergeScans(scans);\n      assert.equal(merged.sources.length, 3, \"Should merge all languages\");\n      assert.equal(merged.files.length, 3, \"Should include all files\");\n      assert.ok(merged.sources.includes(\"typescript\"));\n      assert.ok(merged.sources.includes(\"python\"));\n      assert.ok(merged.sources.includes(\"php\"));\n    });\n\n    test(\"should deduplicate edges across scans\", () => {\n      const scan1 = {\n        language: \"typescript\",\n        files: [\n          {\n            path: \"src/auth.ts\",\n            declarations: [],\n            imports: [\n              { from: \"./utils\", type: \"import_statement\" },\n              { from: \"./config\", type: \"import_statement\" },\n            ],\n            feature_flags: [],\n            permissions: [],\n            warnings: [],\n          },\n        ],\n      };\n\n      const scan2 = {\n        language: \"typescript\",\n        files: [\n          {\n            path: \"src/admin.ts\",\n            declarations: [],\n            imports: [{ from: \"./utils\", type: \"import_statement\" }],\n            feature_flags: [],\n            permissions: [],\n            warnings: [],\n          },\n        ],\n      };\n\n      const merged = mergeScans([scan1, scan2]);\n\n      // Should have 3 unique edges (auth->utils, auth->config, admin->utils)\n      assert.equal(merged.edges.length, 3);\n\n      const edgeKeys = merged.edges.map((e) => `${e.from}->${e.to}`);\n      assert.ok(edgeKeys.includes(\"src/auth.ts->./utils\"));\n      assert.ok(edgeKeys.includes(\"src/auth.ts->./config\"));\n      assert.ok(edgeKeys.includes(\"src/admin.ts->./utils\"));\n    });\n\n    test(\"should sort files in merged output\", () => {\n      const scan = {\n        language: \"typescript\",\n        files: [\n          {\n            path: \"src/z.ts\",\n            declarations: [],\n            imports: [],\n            feature_flags: [],\n            permissions: [],\n            warnings: [],\n          },\n          {\n            path: \"src/a.ts\",\n            declarations: [],\n            imports: [],\n            feature_flags: [],\n            permissions: [],\n            warnings: [],\n          },\n          {\n            path: \"src/m.ts\",\n            declarations: [],\n            imports: [],\n            feature_flags: [],\n            permissions: [],\n            warnings: [],\n          },\n        ],\n      };\n\n      const merged = mergeScans([scan]);\n\n      // Files should be sorted alphabetically\n      assert.equal(merged.files[0].path, \"src/a.ts\");\n      assert.equal(merged.files[1].path, \"src/m.ts\");\n      assert.equal(merged.files[2].path, \"src/z.ts\");\n    });\n\n    test(\"should handle empty scanner output\", () => {\n      const scan = {\n        language: \"typescript\",\n        files: [],\n      };\n\n      const merged = mergeScans([scan]);\n      assert.equal(merged.files.length, 0);\n      assert.equal(merged.sources.length, 1);\n      assert.ok(merged.sources.includes(\"typescript\"));\n    });\n\n    test(\"should include version in merged output\", () => {\n      const scan = {\n        language: \"typescript\",\n        files: [],\n      };\n\n      const merged = mergeScans([scan]);\n      assert.ok(merged.version, \"Should have version\");\n      assert.equal(merged.version, \"1.0.0\");\n    });\n\n    test(\"should preserve file metadata through merge\", () => {\n      const scan = {\n        language: \"typescript\",\n        files: [\n          {\n            path: \"src/test.ts\",\n            declarations: [{ type: \"function\", name: \"test\" }],\n            imports: [{ from: \"assert\", type: \"import_statement\" }],\n            feature_flags: [\"test_mode\"],\n            permissions: [\"can_test\"],\n            warnings: [\"test warning\"],\n          },\n        ],\n      };\n\n      const merged = mergeScans([scan]);\n      const file = merged.files[0];\n\n      assert.equal(file.path, \"src/test.ts\");\n      assert.equal(file.declarations.length, 1);\n      assert.equal(file.declarations[0].name, \"test\");\n      assert.equal(file.imports.length, 1);\n      assert.equal(file.imports[0].from, \"assert\");\n      assert.ok(file.feature_flags.includes(\"test_mode\"));\n      assert.ok(file.permissions.includes(\"can_test\"));\n      assert.ok(file.warnings.includes(\"test warning\"));\n    });\n  });\n\n  describe(\"Frame Creation from Policy Results\", () => {\n    test(\"should create Frame structure from scan results\", () => {\n      const scan = {\n        language: \"typescript\",\n        files: [\n          {\n            path: \"src/features/beta/NewWidget.tsx\",\n            declarations: [],\n            imports: [],\n            feature_flags: [],\n            permissions: [],\n            warnings: [],\n          },\n        ],\n      };\n\n      const merged = mergeScans([scan]);\n\n      // Create a Frame from scan results\n      const frame = {\n        id: \"frame-policy-001\",\n        timestamp: new Date().toISOString(),\n        branch: \"feature/beta-ui\",\n        module_scope: [\"features/beta\"],\n        summary_caption: \"Policy scan completed\",\n        reference_point: \"beta feature scan\",\n        status_snapshot: {\n          next_action: \"Review scan results\",\n          blockers: [],\n        },\n        keywords: [\"policy\", \"scan\"],\n      };\n\n      // Verify Frame structure\n      assert.ok(frame, \"Should create Frame\");\n      assert.ok(frame.status_snapshot, \"Should have status snapshot\");\n      assert.ok(Array.isArray(frame.module_scope), \"Should have module scope array\");\n    });\n\n    test(\"should create Frame for successful scan\", () => {\n      const frame = {\n        id: \"frame-policy-002\",\n        timestamp: new Date().toISOString(),\n        branch: \"feature/compliant-code\",\n        module_scope: [\"ui/components\"],\n        summary_caption: \"All policy checks passed\",\n        reference_point: \"clean policy check\",\n        status_snapshot: {\n          next_action: \"Ready to merge\",\n          blockers: [],\n        },\n      };\n\n      // Verify Frame structure\n      assert.ok(frame, \"Should create Frame\");\n      assert.equal(frame.status_snapshot.next_action, \"Ready to merge\");\n      assert.equal(frame.status_snapshot.blockers.length, 0);\n    });\n  });\n\n  describe(\"Edge Cases and Error Handling\", () => {\n    test(\"should handle files outside known modules\", () => {\n      const scan = {\n        language: \"typescript\",\n        files: [\n          {\n            path: \"scripts/build.ts\",\n            declarations: [],\n            imports: [],\n            feature_flags: [],\n            permissions: [],\n            warnings: [],\n          },\n        ],\n      };\n\n      const merged = mergeScans([scan]);\n      assert.ok(merged, \"Should handle unknown files gracefully\");\n      assert.equal(merged.files.length, 1);\n    });\n\n    test(\"should merge scans with warnings\", () => {\n      const scan = {\n        language: \"typescript\",\n        files: [\n          {\n            path: \"src/legacy/OldCode.ts\",\n            declarations: [],\n            imports: [],\n            feature_flags: [],\n            permissions: [],\n            warnings: [\"deprecated pattern detected\"],\n          },\n        ],\n      };\n\n      const merged = mergeScans([scan]);\n      assert.equal(merged.files[0].warnings.length, 1);\n      assert.ok(merged.files[0].warnings[0].includes(\"deprecated\"));\n    });\n  });\n});\n\nconsole.log(\"\\n✅ Policy Integration Tests - Merge pipeline coverage\\n\");\n","usedDeprecatedRules":[]},{"filePath":"/srv/lex-mcp/lex/test/policy/merge/merge.test.mjs","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/srv/lex-mcp/lex/test/shared/aliases/case-sensitivity.spec.mjs","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'entry' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":75,"column":22,"nodeType":null,"messageId":"unusedVar","endLine":75,"endColumn":27}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Tests for case sensitivity in alias resolution\n *\n * Tests case-sensitive behavior of aliases and provides\n * case normalization utilities and validation.\n *\n * Run with: node --test src/shared/aliases/case-sensitivity.spec.mjs\n */\n\nimport { strict as assert } from \"assert\";\nimport { test, describe } from \"node:test\";\nimport {\n  resolveModuleId,\n  clearAliasTableCache,\n} from \"../../../dist/shared/aliases/resolver.js\";\n\n// Sample policy for case sensitivity testing\nconst samplePolicy = {\n  modules: {\n    \"services/auth-core\": {\n      description: \"Core authentication service\",\n      owns_paths: [\"services/auth/**\"],\n    },\n    \"UI/AdminPanel\": {\n      description: \"Admin panel with mixed case\",\n      owns_paths: [\"web-ui/admin/**\"],\n    },\n    \"api/UserService\": {\n      description: \"User service API with PascalCase\",\n      owns_paths: [\"api/users/**\"],\n    },\n  },\n};\n\n/**\n * Normalize alias to lowercase with validation\n * \n * Best practice: All aliases should be lowercase for consistency\n * and to avoid confusion between \"Cli-Core\", \"cli-core\", \"CLI-CORE\"\n *\n * @param alias - The alias to normalize\n * @returns Normalized lowercase alias\n */\nexport function normalizeAlias(alias) {\n  if (typeof alias !== \"string\") {\n    throw new TypeError(\"Alias must be a string\");\n  }\n  return alias.toLowerCase().trim();\n}\n\n/**\n * Validate that an alias follows lowercase convention\n *\n * @param alias - The alias to validate\n * @returns true if alias is valid (lowercase), false otherwise\n */\nexport function validateAliasCase(alias) {\n  if (typeof alias !== \"string\" || alias.length === 0) {\n    return false;\n  }\n\n  const normalized = normalizeAlias(alias);\n  return alias === normalized;\n}\n\n/**\n * Lint an alias table for case sensitivity issues\n *\n * @param aliasTable - The alias table to lint\n * @returns Array of validation errors, empty if valid\n */\nexport function lintAliasTableCase(aliasTable) {\n  const errors = [];\n\n  for (const [alias, entry] of Object.entries(aliasTable.aliases)) {\n    if (!validateAliasCase(alias)) {\n      errors.push({\n        alias,\n        issue: \"non-lowercase\",\n        suggestion: normalizeAlias(alias),\n        message: `Alias \"${alias}\" should be lowercase: \"${normalizeAlias(alias)}\"`,\n      });\n    }\n\n    // Also check for potential collisions after normalization\n    const normalized = normalizeAlias(alias);\n    if (normalized !== alias) {\n      // Check if normalized version already exists\n      if (aliasTable.aliases[normalized]) {\n        errors.push({\n          alias,\n          issue: \"normalization-collision\",\n          normalized,\n          message: `Alias \"${alias}\" would collide with \"${normalized}\" after normalization`,\n        });\n      }\n    }\n  }\n\n  return errors;\n}\n\ndescribe(\"Case Sensitivity in Aliases\", () => {\n  test(\"alias 'Cli-Core' vs 'cli-core' are treated as distinct\", async () => {\n    clearAliasTableCache();\n\n    const aliasTable = {\n      aliases: {\n        \"Cli-Core\": {\n          canonical: \"services/auth-core\",\n          confidence: 1.0,\n          reason: \"mixed case alias\",\n        },\n        \"cli-core\": {\n          canonical: \"UI/AdminPanel\",\n          confidence: 1.0,\n          reason: \"lowercase alias\",\n        },\n      },\n    };\n\n    const result1 = await resolveModuleId(\"Cli-Core\", samplePolicy, aliasTable);\n    const result2 = await resolveModuleId(\"cli-core\", samplePolicy, aliasTable);\n\n    // They resolve to different modules (case-sensitive)\n    assert.equal(result1.canonical, \"services/auth-core\");\n    assert.equal(result2.canonical, \"UI/AdminPanel\");\n    assert.notEqual(result1.canonical, result2.canonical);\n  });\n\n  test(\"case mismatch in alias lookup returns no match\", async () => {\n    clearAliasTableCache();\n\n    const aliasTable = {\n      aliases: {\n        \"auth-core\": {\n          canonical: \"services/auth-core\",\n          confidence: 1.0,\n        },\n      },\n    };\n\n    // Try to resolve with different case\n    const result = await resolveModuleId(\"Auth-Core\", samplePolicy, aliasTable, {\n      noSubstring: true, // Disable substring matching to isolate alias behavior\n    });\n\n    // Should not find alias (case-sensitive), falls back to fuzzy\n    assert.equal(result.confidence, 0);\n    assert.equal(result.source, \"fuzzy\");\n  });\n\n  test(\"exact module ID match is case-sensitive\", async () => {\n    clearAliasTableCache();\n\n    const resultExact = await resolveModuleId(\"UI/AdminPanel\", samplePolicy);\n    const resultWrongCase = await resolveModuleId(\"ui/adminpanel\", samplePolicy);\n\n    // Exact case matches\n    assert.equal(resultExact.canonical, \"UI/AdminPanel\");\n    assert.equal(resultExact.source, \"exact\");\n    assert.equal(resultExact.confidence, 1.0);\n\n    // Wrong case doesn't match exactly, falls to substring/fuzzy\n    assert.notEqual(resultWrongCase.source, \"exact\");\n  });\n});\n\ndescribe(\"Case Normalization Function\", () => {\n  test(\"normalizeAlias converts to lowercase\", () => {\n    assert.equal(normalizeAlias(\"Cli-Core\"), \"cli-core\");\n    assert.equal(normalizeAlias(\"AUTH-CORE\"), \"auth-core\");\n    assert.equal(normalizeAlias(\"MixedCaseAlias\"), \"mixedcasealias\");\n  });\n\n  test(\"normalizeAlias handles already lowercase\", () => {\n    assert.equal(normalizeAlias(\"cli-core\"), \"cli-core\");\n    assert.equal(normalizeAlias(\"auth\"), \"auth\");\n  });\n\n  test(\"normalizeAlias trims whitespace\", () => {\n    assert.equal(normalizeAlias(\"  cli-core  \"), \"cli-core\");\n    assert.equal(normalizeAlias(\"\\tauth-core\\n\"), \"auth-core\");\n  });\n\n  test(\"normalizeAlias handles special characters\", () => {\n    assert.equal(normalizeAlias(\"Cli-Core_123\"), \"cli-core_123\");\n    assert.equal(normalizeAlias(\"Auth/Service\"), \"auth/service\");\n  });\n\n  test(\"normalizeAlias throws on non-string input\", () => {\n    assert.throws(() => normalizeAlias(null), TypeError);\n    assert.throws(() => normalizeAlias(undefined), TypeError);\n    assert.throws(() => normalizeAlias(123), TypeError);\n    assert.throws(() => normalizeAlias({}), TypeError);\n  });\n\n  test(\"normalizeAlias is idempotent\", () => {\n    const alias = \"Cli-Core\";\n    const normalized = normalizeAlias(alias);\n    assert.equal(normalizeAlias(normalized), normalized);\n  });\n});\n\ndescribe(\"Case Validation Function\", () => {\n  test(\"validateAliasCase accepts lowercase aliases\", () => {\n    assert.ok(validateAliasCase(\"cli-core\"));\n    assert.ok(validateAliasCase(\"auth-service\"));\n    assert.ok(validateAliasCase(\"user-api\"));\n  });\n\n  test(\"validateAliasCase rejects mixed case aliases\", () => {\n    assert.ok(!validateAliasCase(\"Cli-Core\"));\n    assert.ok(!validateAliasCase(\"Auth-Service\"));\n    assert.ok(!validateAliasCase(\"UserAPI\"));\n  });\n\n  test(\"validateAliasCase rejects uppercase aliases\", () => {\n    assert.ok(!validateAliasCase(\"CLI-CORE\"));\n    assert.ok(!validateAliasCase(\"AUTH\"));\n  });\n\n  test(\"validateAliasCase rejects empty string\", () => {\n    assert.ok(!validateAliasCase(\"\"));\n  });\n\n  test(\"validateAliasCase rejects whitespace-only\", () => {\n    assert.ok(!validateAliasCase(\"   \"));\n  });\n\n  test(\"validateAliasCase rejects non-string types\", () => {\n    assert.ok(!validateAliasCase(null));\n    assert.ok(!validateAliasCase(undefined));\n    assert.ok(!validateAliasCase(123));\n    assert.ok(!validateAliasCase({}));\n  });\n\n  test(\"validateAliasCase allows numbers and special chars if lowercase\", () => {\n    assert.ok(validateAliasCase(\"cli-core-123\"));\n    assert.ok(validateAliasCase(\"auth_service\"));\n    assert.ok(validateAliasCase(\"user/api\"));\n  });\n});\n\ndescribe(\"Alias Table Linting\", () => {\n  test(\"lintAliasTableCase detects non-lowercase aliases\", () => {\n    const aliasTable = {\n      aliases: {\n        \"Cli-Core\": {\n          canonical: \"services/cli-core\",\n          confidence: 1.0,\n        },\n        \"auth-service\": {\n          canonical: \"services/auth\",\n          confidence: 1.0,\n        },\n        \"UserAPI\": {\n          canonical: \"api/users\",\n          confidence: 1.0,\n        },\n      },\n    };\n\n    const errors = lintAliasTableCase(aliasTable);\n\n    assert.equal(errors.length, 2); // Two non-lowercase aliases\n    assert.ok(errors.some((e) => e.alias === \"Cli-Core\"));\n    assert.ok(errors.some((e) => e.alias === \"UserAPI\"));\n    assert.ok(!errors.some((e) => e.alias === \"auth-service\"));\n  });\n\n  test(\"lintAliasTableCase returns empty for valid table\", () => {\n    const aliasTable = {\n      aliases: {\n        \"cli-core\": {\n          canonical: \"services/cli-core\",\n          confidence: 1.0,\n        },\n        \"auth-service\": {\n          canonical: \"services/auth\",\n          confidence: 1.0,\n        },\n      },\n    };\n\n    const errors = lintAliasTableCase(aliasTable);\n    assert.equal(errors.length, 0);\n  });\n\n  test(\"lintAliasTableCase detects normalization collisions\", () => {\n    const aliasTable = {\n      aliases: {\n        \"cli-core\": {\n          canonical: \"services/cli-core\",\n          confidence: 1.0,\n        },\n        \"Cli-Core\": {\n          canonical: \"services/cli-core-v2\",\n          confidence: 1.0,\n        },\n      },\n    };\n\n    const errors = lintAliasTableCase(aliasTable);\n\n    // Should detect that \"Cli-Core\" would collide with \"cli-core\" after normalization\n    assert.ok(errors.length > 0);\n    const collisionError = errors.find((e) => e.issue === \"normalization-collision\");\n    assert.ok(collisionError);\n    assert.equal(collisionError.alias, \"Cli-Core\");\n    assert.equal(collisionError.normalized, \"cli-core\");\n  });\n\n  test(\"lintAliasTableCase provides suggestions\", () => {\n    const aliasTable = {\n      aliases: {\n        \"Auth-Core\": {\n          canonical: \"services/auth-core\",\n          confidence: 1.0,\n        },\n      },\n    };\n\n    const errors = lintAliasTableCase(aliasTable);\n\n    assert.equal(errors.length, 1);\n    assert.equal(errors[0].suggestion, \"auth-core\");\n    assert.ok(errors[0].message.includes(\"should be lowercase\"));\n  });\n});\n\ndescribe(\"Recommendation: Enforce Lowercase\", () => {\n  test(\"lowercase convention avoids confusion\", () => {\n    // This test documents the recommendation\n\n    const confusingAliases = [\"Cli-Core\", \"cli-core\", \"CLI-CORE\", \"cLi-CoRe\"];\n\n    // All of these are distinct in a case-sensitive system\n    // but could confuse users who expect case-insensitive matching\n\n    const uniqueNormalized = new Set(confusingAliases.map(normalizeAlias));\n    assert.equal(uniqueNormalized.size, 1); // All normalize to same value\n\n    // Therefore: enforce lowercase to prevent confusion\n  });\n\n  test(\"lowercase allows case-insensitive substring matching\", async () => {\n    clearAliasTableCache();\n\n    // Even though aliases are case-sensitive,\n    // substring matching is case-insensitive\n\n    const result1 = await resolveModuleId(\"auth\", samplePolicy);\n    const result2 = await resolveModuleId(\"AUTH\", samplePolicy);\n\n    // Both should match 'services/auth-core' via substring\n    assert.equal(result1.canonical, \"services/auth-core\");\n    assert.equal(result2.canonical, \"services/auth-core\");\n    assert.equal(result1.source, \"substring\");\n    assert.equal(result2.source, \"substring\");\n  });\n\n  test(\"mixed case in canonical IDs is preserved\", async () => {\n    clearAliasTableCache();\n\n    const aliasTable = {\n      aliases: {\n        \"admin\": {\n          canonical: \"UI/AdminPanel\", // Canonical has mixed case\n          confidence: 1.0,\n        },\n      },\n    };\n\n    const result = await resolveModuleId(\"admin\", samplePolicy, aliasTable);\n\n    // Canonical ID case is preserved exactly\n    assert.equal(result.canonical, \"UI/AdminPanel\");\n    assert.equal(result.source, \"alias\");\n  });\n});\n\ndescribe(\"Integration with Linter/Validator\", () => {\n  test(\"alias table with violations should fail validation\", () => {\n    const invalidAliasTable = {\n      aliases: {\n        \"Auth-Core\": {\n          canonical: \"services/auth-core\",\n          confidence: 1.0,\n        },\n      },\n    };\n\n    const errors = lintAliasTableCase(invalidAliasTable);\n\n    // In a CI pipeline, this would cause a failure\n    if (errors.length > 0) {\n      assert.ok(true, \"Linter detected violations\");\n    }\n  });\n\n  test(\"alias table linting is fast enough for CI\", () => {\n    // Generate large alias table\n    const largeAliasTable = {\n      aliases: {},\n    };\n\n    for (let i = 0; i < 1000; i++) {\n      largeAliasTable.aliases[`alias-${i}`] = {\n        canonical: `module-${i}`,\n        confidence: 1.0,\n      };\n    }\n\n    const startTime = Date.now();\n    const errors = lintAliasTableCase(largeAliasTable);\n    const duration = Date.now() - startTime;\n\n    // Should complete in reasonable time (< 100ms for 1000 aliases)\n    assert.ok(duration < 100, `Linting took ${duration}ms, should be < 100ms`);\n    assert.equal(errors.length, 0); // All valid lowercase\n  });\n});\n\ndescribe(\"Case Sensitivity Edge Cases\", () => {\n  test(\"unicode characters in aliases maintain case\", () => {\n    const aliases = [\"café\", \"CAFÉ\", \"Café\"];\n\n    const normalized = aliases.map(normalizeAlias);\n\n    // All normalize to lowercase\n    assert.equal(normalized[0], \"café\");\n    assert.equal(normalized[1], \"café\");\n    assert.equal(normalized[2], \"café\");\n  });\n\n  test(\"numbers and symbols don't have case\", () => {\n    assert.equal(normalizeAlias(\"module-123\"), \"module-123\");\n    assert.equal(normalizeAlias(\"api/v2\"), \"api/v2\");\n    assert.equal(normalizeAlias(\"core_service\"), \"core_service\");\n  });\n\n  test(\"empty or whitespace-only aliases are invalid\", () => {\n    assert.ok(!validateAliasCase(\"\"));\n    assert.ok(!validateAliasCase(\"   \"));\n    assert.ok(!validateAliasCase(\"\\t\\n\"));\n  });\n});\n","usedDeprecatedRules":[]},{"filePath":"/srv/lex-mcp/lex/test/shared/aliases/collision.spec.mjs","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/srv/lex-mcp/lex/test/shared/aliases/failure-modes.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/srv/lex-mcp/lex/test/shared/aliases/lexrunner.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/srv/lex-mcp/lex/test/shared/aliases/resolution.spec.mjs","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'assert' is defined but never used. Allowed unused vars must match /^_/u.","line":11,"column":20,"nodeType":null,"messageId":"unusedVar","endLine":11,"endColumn":26},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":46,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":46,"endColumn":19,"suggestions":[{"fix":{"range":[1434,1493],"text":""},"messageId":"removeConsole","data":{"propertyName":"warn"},"desc":"Remove the console.warn()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":58,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":58,"endColumn":20,"suggestions":[{"fix":{"range":[1767,1827],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'entry' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":157,"column":24,"nodeType":null,"messageId":"unusedVar","endLine":157,"endColumn":29}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Snapshot tests for alias resolution\n *\n * Tests that verify the complete resolution output format,\n * useful for detecting breaking changes in the alias system.\n *\n * Run with: node --test src/shared/aliases/resolution.spec.mjs\n * Update snapshots with: LEX_UPDATE_SNAPSHOTS=1 node --test src/shared/aliases/resolution.spec.mjs\n */\n\nimport { strict as assert } from \"assert\";\nimport { test, describe } from \"node:test\";\nimport { readFileSync, writeFileSync, mkdirSync, existsSync } from \"fs\";\nimport { join, dirname } from \"path\";\nimport { fileURLToPath } from \"url\";\nimport {\n  resolveModuleId,\n  clearAliasTableCache,\n} from \"../../../dist/shared/aliases/resolver.js\";\n\n// Get directory for snapshots\nconst __filename = fileURLToPath(import.meta.url);\nconst __dirname = dirname(__filename);\nconst SNAPSHOTS_DIR = join(__dirname, \"__snapshots__\");\nconst SNAPSHOT_FILE = join(SNAPSHOTS_DIR, \"resolution.spec.mjs.snap\");\n\n/**\n * Simple snapshot testing utility for Node.js test runner\n */\nclass SnapshotManager {\n  constructor(snapshotFile) {\n    this.snapshotFile = snapshotFile;\n    this.snapshots = {};\n    this.updateMode = process.env.LEX_UPDATE_SNAPSHOTS === \"1\";\n    this.dirty = false;\n    this.load();\n  }\n\n  load() {\n    try {\n      if (existsSync(this.snapshotFile)) {\n        const content = readFileSync(this.snapshotFile, \"utf-8\");\n        this.snapshots = JSON.parse(content);\n      }\n    } catch (error) {\n      console.warn(`Could not load snapshots: ${error.message}`);\n      this.snapshots = {};\n    }\n  }\n\n  save() {\n    if (!this.dirty) return;\n\n    try {\n      mkdirSync(dirname(this.snapshotFile), { recursive: true });\n      writeFileSync(this.snapshotFile, JSON.stringify(this.snapshots, null, 2), \"utf-8\");\n    } catch (error) {\n      console.error(`Could not save snapshots: ${error.message}`);\n    }\n  }\n\n  matchSnapshot(testName, value) {\n    const serialized = JSON.stringify(value, null, 2);\n\n    if (this.updateMode) {\n      this.snapshots[testName] = serialized;\n      this.dirty = true;\n      return true;\n    }\n\n    if (!this.snapshots[testName]) {\n      throw new Error(\n        `Snapshot for \"${testName}\" does not exist. Run with LEX_UPDATE_SNAPSHOTS=1 to create.`\n      );\n    }\n\n    const expected = this.snapshots[testName];\n    if (serialized !== expected) {\n      throw new Error(\n        `Snapshot mismatch for \"${testName}\":\\n\\nExpected:\\n${expected}\\n\\nReceived:\\n${serialized}`\n      );\n    }\n\n    return true;\n  }\n}\n\nconst snapshots = new SnapshotManager(SNAPSHOT_FILE);\n\n// Save snapshots after all tests\nprocess.on(\"exit\", () => {\n  snapshots.save();\n});\n\n// Sample policy for snapshot tests\nconst samplePolicy = {\n  modules: {\n    \"src/cli/flags.ts\": {\n      description: \"CLI flags module\",\n      owns_paths: [\"src/cli/flags.ts\"],\n    },\n    \"src/cli/commands.ts\": {\n      description: \"CLI commands module\",\n      owns_paths: [\"src/cli/commands.ts\"],\n    },\n    \"src/gates/runner.ts\": {\n      description: \"Gates runner module\",\n      owns_paths: [\"src/gates/runner.ts\"],\n    },\n    \"services/auth-core\": {\n      description: \"Authentication core service\",\n      owns_paths: [\"services/auth/**\"],\n    },\n    \"services/user-api\": {\n      description: \"User API service\",\n      owns_paths: [\"services/users/**\"],\n    },\n  },\n};\n\ndescribe(\"Snapshot Tests: Alias Resolution\", () => {\n  test(\"snapshot: complete alias map resolution\", async () => {\n    clearAliasTableCache();\n\n    const aliasTable = {\n      aliases: {\n        \"cli-flags\": {\n          canonical: \"src/cli/flags.ts\",\n          confidence: 1.0,\n          reason: \"shorthand\",\n        },\n        \"cli-commands\": {\n          canonical: \"src/cli/commands.ts\",\n          confidence: 1.0,\n          reason: \"shorthand\",\n        },\n        \"gates-runner\": {\n          canonical: \"src/gates/runner.ts\",\n          confidence: 1.0,\n          reason: \"shorthand\",\n        },\n        \"auth\": {\n          canonical: \"services/auth-core\",\n          confidence: 1.0,\n          reason: \"common shorthand\",\n        },\n        \"user\": {\n          canonical: \"services/user-api\",\n          confidence: 1.0,\n          reason: \"common shorthand\",\n        },\n      },\n    };\n\n    // Resolve all aliases\n    const aliasResolutionMap = {};\n    for (const [alias, entry] of Object.entries(aliasTable.aliases)) {\n      const result = await resolveModuleId(alias, samplePolicy, aliasTable);\n      aliasResolutionMap[alias] = result.canonical;\n    }\n\n    // Snapshot the complete resolution map\n    snapshots.matchSnapshot(\"alias-map-resolution\", aliasResolutionMap);\n  });\n\n  test(\"snapshot: Frame moduleScope after aliasing\", async () => {\n    clearAliasTableCache();\n\n    const aliasTable = {\n      aliases: {\n        \"cli-flags\": {\n          canonical: \"src/cli/flags.ts\",\n          confidence: 1.0,\n        },\n        \"gates-runner\": {\n          canonical: \"src/gates/runner.ts\",\n          confidence: 1.0,\n        },\n      },\n    };\n\n    // Simulate user input with aliases\n    const userInputModules = [\"cli-flags\", \"src/cli/commands.ts\", \"gates-runner\"];\n\n    // Resolve all inputs to canonical IDs (as would be stored in Frame)\n    const resolvedModuleScope = [];\n    for (const input of userInputModules) {\n      const result = await resolveModuleId(input, samplePolicy, aliasTable);\n      resolvedModuleScope.push(result.canonical);\n    }\n\n    // Snapshot the final moduleScope that would be stored in Frame\n    snapshots.matchSnapshot(\"frame-module-scope\", resolvedModuleScope);\n  });\n\n  test(\"snapshot: resolution with mixed sources\", async () => {\n    clearAliasTableCache();\n\n    const aliasTable = {\n      aliases: {\n        \"auth\": {\n          canonical: \"services/auth-core\",\n          confidence: 1.0,\n        },\n      },\n    };\n\n    // Test various resolution methods\n    const testCases = [\n      { input: \"services/auth-core\", description: \"exact match\" },\n      { input: \"auth\", description: \"alias match\" },\n      { input: \"flags\", description: \"substring match\" },\n      { input: \"unknown-module\", description: \"no match\" },\n    ];\n\n    const resolutions = {};\n    for (const testCase of testCases) {\n      const result = await resolveModuleId(testCase.input, samplePolicy, aliasTable);\n      resolutions[testCase.input] = {\n        canonical: result.canonical,\n        confidence: result.confidence,\n        source: result.source,\n        description: testCase.description,\n      };\n    }\n\n    snapshots.matchSnapshot(\"mixed-source-resolutions\", resolutions);\n  });\n\n  test(\"snapshot: alias resolution priority order\", async () => {\n    clearAliasTableCache();\n\n    // Create scenario where same input could match multiple ways\n    const aliasTable = {\n      aliases: {\n        \"src/cli/flags.ts\": {\n          canonical: \"services/auth-core\", // Alias for exact module ID\n          confidence: 1.0,\n        },\n      },\n    };\n\n    const result = await resolveModuleId(\"src/cli/flags.ts\", samplePolicy, aliasTable);\n\n    // Should prefer exact match over alias\n    snapshots.matchSnapshot(\"priority-exact-over-alias\", {\n      input: \"src/cli/flags.ts\",\n      canonical: result.canonical,\n      source: result.source,\n      confidence: result.confidence,\n      note: \"exact match takes precedence over alias lookup\",\n    });\n  });\n});\n\ndescribe(\"Snapshot Tests: Error Cases\", () => {\n  test(\"snapshot: ambiguous substring resolution\", async () => {\n    clearAliasTableCache();\n\n    // 'cli' matches both 'src/cli/flags.ts' and 'src/cli/commands.ts'\n    const result = await resolveModuleId(\"cli\", samplePolicy);\n\n    snapshots.matchSnapshot(\"ambiguous-substring\", {\n      input: \"cli\",\n      canonical: result.canonical,\n      confidence: result.confidence,\n      source: result.source,\n      note: \"ambiguous substring returns confidence 0\",\n    });\n  });\n\n  test(\"snapshot: unknown module resolution\", async () => {\n    clearAliasTableCache();\n\n    const result = await resolveModuleId(\"completely-unknown\", samplePolicy);\n\n    snapshots.matchSnapshot(\"unknown-module\", {\n      input: \"completely-unknown\",\n      canonical: result.canonical,\n      confidence: result.confidence,\n      source: result.source,\n      note: \"unknown returns original with confidence 0\",\n    });\n  });\n\n  test(\"snapshot: empty input resolution\", async () => {\n    clearAliasTableCache();\n\n    const result = await resolveModuleId(\"\", samplePolicy);\n\n    snapshots.matchSnapshot(\"empty-input\", {\n      input: \"\",\n      canonical: result.canonical,\n      confidence: result.confidence,\n      source: result.source,\n    });\n  });\n});\n\ndescribe(\"Snapshot Tests: Breaking Change Detection\", () => {\n  test(\"snapshot: resolution output format\", async () => {\n    clearAliasTableCache();\n\n    const result = await resolveModuleId(\"services/auth-core\", samplePolicy);\n\n    // Snapshot the complete result structure\n    // Any change to AliasResolution interface would break this\n    snapshots.matchSnapshot(\"resolution-output-format\", {\n      canonical: result.canonical,\n      confidence: result.confidence,\n      original: result.original,\n      source: result.source,\n      typeCheck: {\n        hasCanonical: typeof result.canonical === \"string\",\n        hasConfidence: typeof result.confidence === \"number\",\n        hasOriginal: typeof result.original === \"string\",\n        hasSource: typeof result.source === \"string\",\n        validSource: [\"exact\", \"alias\", \"fuzzy\", \"substring\"].includes(result.source),\n      },\n    });\n  });\n\n  test(\"snapshot: alias table structure\", () => {\n    const aliasTable = {\n      aliases: {\n        \"test-alias\": {\n          canonical: \"services/test\",\n          confidence: 1.0,\n          reason: \"test reason\",\n        },\n      },\n    };\n\n    // Snapshot the expected alias table structure\n    // Changes to AliasTable or AliasEntry interfaces would break this\n    snapshots.matchSnapshot(\"alias-table-structure\", {\n      aliases: aliasTable.aliases,\n      typeCheck: {\n        isObject: typeof aliasTable.aliases === \"object\",\n        hasEntries: Object.keys(aliasTable.aliases).length > 0,\n        entryStructure: Object.values(aliasTable.aliases).map((entry) => ({\n          hasCanonical: \"canonical\" in entry,\n          hasConfidence: \"confidence\" in entry,\n          hasReason: \"reason\" in entry,\n          canonicalType: typeof entry.canonical,\n          confidenceType: typeof entry.confidence,\n          reasonType: typeof entry.reason,\n        }))[0],\n      },\n    });\n  });\n});\n\ndescribe(\"Snapshot Tests: Real-World Scenarios\", () => {\n  test(\"snapshot: batch resolution for /remember command\", async () => {\n    clearAliasTableCache();\n\n    const aliasTable = {\n      aliases: {\n        \"auth\": {\n          canonical: \"services/auth-core\",\n          confidence: 1.0,\n        },\n        \"user\": {\n          canonical: \"services/user-api\",\n          confidence: 1.0,\n        },\n      },\n    };\n\n    // Simulate user typing mixed aliases and exact IDs\n    const userInput = [\"auth\", \"src/cli/flags.ts\", \"user\", \"gates\"];\n\n    const batchResolution = [];\n    for (const input of userInput) {\n      const result = await resolveModuleId(input, samplePolicy, aliasTable);\n      batchResolution.push({\n        input,\n        canonical: result.canonical,\n        confidence: result.confidence,\n        source: result.source,\n      });\n    }\n\n    snapshots.matchSnapshot(\"batch-remember-resolution\", batchResolution);\n  });\n\n  test(\"snapshot: refactoring migration scenario\", async () => {\n    clearAliasTableCache();\n\n    // Scenario: Module was refactored, old paths aliased to new\n    const aliasTable = {\n      aliases: {\n        \"old/auth/service\": {\n          canonical: \"services/auth-core\",\n          confidence: 1.0,\n          reason: \"refactored 2025-10-15\",\n        },\n        \"legacy/user-access\": {\n          canonical: \"services/user-api\",\n          confidence: 1.0,\n          reason: \"renamed 2025-11-01\",\n        },\n      },\n    };\n\n    const oldPaths = [\"old/auth/service\", \"legacy/user-access\"];\n    const migrations = {};\n\n    for (const oldPath of oldPaths) {\n      const result = await resolveModuleId(oldPath, samplePolicy, aliasTable);\n      migrations[oldPath] = {\n        newCanonical: result.canonical,\n        migrationNote: aliasTable.aliases[oldPath]?.reason,\n      };\n    }\n\n    snapshots.matchSnapshot(\"refactoring-migration\", migrations);\n  });\n});\n\ndescribe(\"Snapshot Update Instructions\", () => {\n  test(\"documentation: how to update snapshots\", () => {\n    const instructions = {\n      command: \"LEX_UPDATE_SNAPSHOTS=1 node --test src/shared/aliases/resolution.spec.mjs\",\n      purpose:\n        \"Updates snapshot files when the resolution output intentionally changes\",\n      when_to_update: [\n        \"Adding new fields to AliasResolution interface\",\n        \"Changing resolution algorithm output\",\n        \"Updating canonical module IDs in policy\",\n        \"Modifying alias table structure\",\n      ],\n      review_required:\n        \"Always review snapshot diffs in PR to ensure changes are intentional\",\n      location: \"__snapshots__/resolution.spec.mjs.snap\",\n    };\n\n    // This snapshot documents how to use snapshot testing\n    snapshots.matchSnapshot(\"snapshot-update-instructions\", instructions);\n  });\n});\n","usedDeprecatedRules":[]},{"filePath":"/srv/lex-mcp/lex/test/shared/aliases/resolver.test.mjs","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/srv/lex-mcp/lex/test/shared/aliases/substring.spec.mjs","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/srv/lex-mcp/lex/test/shared/atlas/atlas-frame.test.mjs","messages":[{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":264,"column":1,"nodeType":"MemberExpression","messageId":"unexpected","endLine":264,"endColumn":12,"suggestions":[{"fix":{"range":[9527,9562],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Tests for Atlas Frame Generation\n *\n * Run with: node shared/atlas/atlas-frame.test.mjs\n */\n\nimport { strict as assert } from \"assert\";\nimport { test, describe } from \"node:test\";\n// Adjusted import path to built dist output\nimport { generateAtlasFrame, formatAtlasFrame } from \"../../../dist/shared/atlas/atlas-frame.js\";\nimport { writeFileSync, mkdirSync } from \"fs\";\nimport { fileURLToPath } from \"url\";\nimport { dirname, join } from \"path\";\n\nconst __filename = fileURLToPath(import.meta.url);\nconst __dirname = dirname(__filename);\n\n// Create a test policy for isolated testing\nconst testPolicyPath = join(__dirname, \"test-policy.json\");\n\n// Test policy with a small graph for controlled testing\nconst testPolicy = {\n  modules: {\n    \"ui/admin-panel\": {\n      owns_paths: [\"ui/admin/**\"],\n      allowed_callers: [],\n      forbidden_callers: [\"backend/auth\"],\n      feature_flags: [\"admin_ui\"],\n      requires_permissions: [\"admin_access\"],\n      notes: \"Admin UI module\",\n    },\n    \"api/user-service\": {\n      owns_paths: [\"api/users/**\"],\n      allowed_callers: [\"ui/admin-panel\", \"api/admin-service\"],\n      forbidden_callers: [],\n      notes: \"User management API\",\n    },\n    \"api/admin-service\": {\n      owns_paths: [\"api/admin/**\"],\n      allowed_callers: [\"ui/admin-panel\"],\n      forbidden_callers: [],\n      requires_permissions: [\"admin_access\"],\n      notes: \"Admin operations API\",\n    },\n    \"backend/auth\": {\n      owns_paths: [\"backend/auth/**\"],\n      allowed_callers: [\"api/user-service\", \"api/admin-service\"],\n      forbidden_callers: [\"ui/admin-panel\"],\n      notes: \"Authentication backend\",\n    },\n    \"backend/database\": {\n      owns_paths: [\"backend/db/**\"],\n      allowed_callers: [\"backend/auth\"],\n      forbidden_callers: [],\n      notes: \"Database layer\",\n    },\n    \"isolated/module\": {\n      owns_paths: [\"isolated/**\"],\n      allowed_callers: [],\n      forbidden_callers: [],\n      notes: \"Disconnected module for testing\",\n    },\n  },\n};\n\n// Write test policy to file\nmkdirSync(dirname(testPolicyPath), { recursive: true });\nwriteFileSync(testPolicyPath, JSON.stringify(testPolicy, null, 2));\n\ndescribe(\"generateAtlasFrame\", () => {\n  test(\"returns valid AtlasFrame structure\", () => {\n    const frame = generateAtlasFrame([\"ui/admin-panel\"], 1, testPolicyPath);\n\n    assert.ok(frame);\n    assert.ok(frame.atlas_timestamp);\n    assert.deepEqual(frame.seed_modules, [\"ui/admin-panel\"]);\n    assert.equal(frame.fold_radius, 1);\n    assert.ok(Array.isArray(frame.modules));\n    assert.ok(Array.isArray(frame.edges));\n    assert.equal(typeof frame.critical_rule, \"string\");\n  });\n\n  test(\"includes seed modules in result\", () => {\n    const frame = generateAtlasFrame([\"ui/admin-panel\"], 1, testPolicyPath);\n\n    const moduleIds = frame.modules.map((m) => m.id);\n    assert.ok(moduleIds.includes(\"ui/admin-panel\"));\n  });\n\n  test(\"extracts 1-hop neighborhood correctly\", () => {\n    const frame = generateAtlasFrame([\"ui/admin-panel\"], 1, testPolicyPath);\n\n    const moduleIds = new Set(frame.modules.map((m) => m.id));\n\n    // Seed module should be included\n    assert.ok(moduleIds.has(\"ui/admin-panel\"));\n\n    // 1-hop neighbors should be included\n    // ui/admin-panel calls api/user-service and api/admin-service\n    assert.ok(moduleIds.has(\"api/user-service\"));\n    assert.ok(moduleIds.has(\"api/admin-service\"));\n\n    // backend/auth has forbidden edge to ui/admin-panel, should be included\n    assert.ok(moduleIds.has(\"backend/auth\"));\n\n    // 2-hop neighbors should NOT be included\n    assert.ok(!moduleIds.has(\"backend/database\"));\n  });\n\n  test(\"extracts 2-hop neighborhood correctly\", () => {\n    const frame = generateAtlasFrame([\"ui/admin-panel\"], 2, testPolicyPath);\n\n    const moduleIds = new Set(frame.modules.map((m) => m.id));\n\n    // Seed module\n    assert.ok(moduleIds.has(\"ui/admin-panel\"));\n\n    // 1-hop neighbors\n    assert.ok(moduleIds.has(\"api/user-service\"));\n    assert.ok(moduleIds.has(\"api/admin-service\"));\n    assert.ok(moduleIds.has(\"backend/auth\"));\n\n    // 2-hop neighbors should now be included\n    // backend/auth is called by api/user-service and api/admin-service\n    // backend/database is called by backend/auth\n    assert.ok(moduleIds.has(\"backend/database\"));\n  });\n\n  test(\"includes forbidden edges in result\", () => {\n    const frame = generateAtlasFrame([\"ui/admin-panel\"], 1, testPolicyPath);\n\n    // Find forbidden edge from ui/admin-panel to backend/auth\n    const forbiddenEdge = frame.edges.find(\n      (e) => e.from === \"ui/admin-panel\" && e.to === \"backend/auth\" && !e.allowed\n    );\n\n    assert.ok(forbiddenEdge, \"Should include forbidden edge from ui/admin-panel to backend/auth\");\n    assert.equal(forbiddenEdge.allowed, false);\n    assert.equal(forbiddenEdge.reason, \"forbidden_caller\");\n  });\n\n  test(\"includes allowed edges in result\", () => {\n    const frame = generateAtlasFrame([\"ui/admin-panel\"], 1, testPolicyPath);\n\n    // Find allowed edge from ui/admin-panel to api/user-service\n    const allowedEdge = frame.edges.find(\n      (e) => e.from === \"ui/admin-panel\" && e.to === \"api/user-service\" && e.allowed\n    );\n\n    assert.ok(allowedEdge, \"Should include allowed edge from ui/admin-panel to api/user-service\");\n    assert.equal(allowedEdge.allowed, true);\n    assert.equal(allowedEdge.reason, undefined);\n  });\n\n  test(\"handles disconnected modules gracefully\", () => {\n    // isolated/module has no connections, so shouldn't be in neighborhood\n    const frame = generateAtlasFrame([\"ui/admin-panel\"], 2, testPolicyPath);\n\n    const moduleIds = new Set(frame.modules.map((m) => m.id));\n    assert.ok(!moduleIds.has(\"isolated/module\"));\n  });\n\n  test(\"handles disconnected seed module\", () => {\n    // If seed itself is disconnected, it should still be included\n    const frame = generateAtlasFrame([\"isolated/module\"], 1, testPolicyPath);\n\n    const moduleIds = new Set(frame.modules.map((m) => m.id));\n    assert.ok(moduleIds.has(\"isolated/module\"));\n    // But no other modules should be included\n    assert.equal(frame.modules.length, 1);\n  });\n\n  test(\"includes full policy metadata in modules\", () => {\n    const frame = generateAtlasFrame([\"ui/admin-panel\"], 1, testPolicyPath);\n\n    const adminPanel = frame.modules.find((m) => m.id === \"ui/admin-panel\");\n    assert.ok(adminPanel);\n\n    // Check that policy metadata is included\n    assert.ok(adminPanel.owns_paths);\n    assert.deepEqual(adminPanel.owns_paths, [\"ui/admin/**\"]);\n    assert.deepEqual(adminPanel.forbidden_callers, [\"backend/auth\"]);\n    assert.deepEqual(adminPanel.feature_flags, [\"admin_ui\"]);\n    assert.deepEqual(adminPanel.requires_permissions, [\"admin_access\"]);\n    assert.equal(adminPanel.notes, \"Admin UI module\");\n  });\n\n  test(\"generates coordinates for all modules\", () => {\n    const frame = generateAtlasFrame([\"ui/admin-panel\"], 1, testPolicyPath);\n\n    // All modules should have coordinates\n    for (const module of frame.modules) {\n      assert.ok(module.coords, `Module ${module.id} should have coordinates`);\n      assert.equal(module.coords.length, 2);\n      assert.equal(typeof module.coords[0], \"number\");\n      assert.equal(typeof module.coords[1], \"number\");\n\n      // Coordinates should be within reasonable bounds (0-1000 by default)\n      assert.ok(module.coords[0] >= 0 && module.coords[0] <= 1000);\n      assert.ok(module.coords[1] >= 0 && module.coords[1] <= 1000);\n    }\n  });\n\n  test(\"handles multiple seed modules\", () => {\n    const frame = generateAtlasFrame([\"ui/admin-panel\", \"backend/database\"], 1, testPolicyPath);\n\n    const moduleIds = new Set(frame.modules.map((m) => m.id));\n\n    // Both seeds should be included\n    assert.ok(moduleIds.has(\"ui/admin-panel\"));\n    assert.ok(moduleIds.has(\"backend/database\"));\n\n    // Should include neighbors of both seeds\n    assert.ok(moduleIds.has(\"api/user-service\")); // neighbor of ui/admin-panel\n    assert.ok(moduleIds.has(\"backend/auth\")); // neighbor of backend/database\n  });\n\n  test(\"handles empty seed modules\", () => {\n    const frame = generateAtlasFrame([], 1, testPolicyPath);\n\n    assert.equal(frame.modules.length, 0);\n    assert.equal(frame.edges.length, 0);\n  });\n\n  test(\"handles unknown seed modules\", () => {\n    const frame = generateAtlasFrame([\"unknown/module\"], 1, testPolicyPath);\n\n    // Should handle gracefully - unknown modules just don't get expanded\n    assert.equal(frame.modules.length, 0);\n  });\n\n  test(\"fold radius 0 returns only seed modules\", () => {\n    const frame = generateAtlasFrame([\"ui/admin-panel\"], 0, testPolicyPath);\n\n    const moduleIds = new Set(frame.modules.map((m) => m.id));\n    assert.ok(moduleIds.has(\"ui/admin-panel\"));\n    // With fold radius 0, should only have the seed module\n    assert.equal(frame.modules.length, 1);\n  });\n});\n\ndescribe(\"formatAtlasFrame\", () => {\n  test(\"formats atlas frame for display\", () => {\n    const frame = generateAtlasFrame([\"ui/admin-panel\"], 1, testPolicyPath);\n    const formatted = formatAtlasFrame(frame);\n\n    assert.ok(typeof formatted === \"string\");\n    assert.ok(formatted.includes(\"Atlas Frame\"));\n    assert.ok(formatted.includes(\"ui/admin-panel\"));\n    assert.ok(formatted.includes(\"fold radius: 1\"));\n  });\n\n  test(\"displays edges with correct status\", () => {\n    const frame = generateAtlasFrame([\"ui/admin-panel\"], 1, testPolicyPath);\n    const formatted = formatAtlasFrame(frame);\n\n    // Should show allowed and forbidden edges\n    if (frame.edges.length > 0) {\n      assert.ok(formatted.includes(\"Edges:\") || formatted.includes(\"🔗\"));\n    }\n  });\n});\n\nconsole.log(\"All tests passed! ✅\");\n","usedDeprecatedRules":[]},{"filePath":"/srv/lex-mcp/lex/test/shared/atlas/auto-tune.test.mjs","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'result' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":144,"column":11,"nodeType":null,"messageId":"unusedVar","endLine":144,"endColumn":17},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":227,"column":1,"nodeType":"MemberExpression","messageId":"unexpected","endLine":227,"endColumn":12,"suggestions":[{"fix":{"range":[6720,6765],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Tests for Auto-Tuning\n *\n * Run with: node shared/atlas/auto-tune.test.mjs\n */\n\nimport { strict as assert } from \"assert\";\nimport { test, describe } from \"node:test\";\n// Adjusted import path to built dist output\nimport {\n  estimateTokens,\n  autoTuneRadius,\n  estimateTokensBeforeGeneration,\n} from \"../../../dist/shared/atlas/auto-tune.js\";\n\ndescribe(\"estimateTokens\", () => {\n  test(\"estimates tokens based on JSON size\", () => {\n    const mockFrame = {\n      atlas_timestamp: \"2025-01-01T00:00:00Z\",\n      seed_modules: [\"module-a\"],\n      fold_radius: 1,\n      modules: [],\n      edges: [],\n      critical_rule: \"test\",\n    };\n\n    const tokens = estimateTokens(mockFrame);\n\n    // Should be approximately JSON.stringify(mockFrame).length / 4\n    const json = JSON.stringify(mockFrame);\n    const expected = Math.ceil(json.length / 4);\n\n    assert.equal(tokens, expected);\n    assert.ok(tokens > 0);\n  });\n\n  test(\"larger frames have more tokens\", () => {\n    const smallFrame = {\n      atlas_timestamp: \"2025-01-01T00:00:00Z\",\n      seed_modules: [\"a\"],\n      fold_radius: 1,\n      modules: [],\n      edges: [],\n      critical_rule: \"test\",\n    };\n\n    const largeFrame = {\n      atlas_timestamp: \"2025-01-01T00:00:00Z\",\n      seed_modules: [\"module-a\", \"module-b\", \"module-c\"],\n      fold_radius: 2,\n      modules: [\n        { id: \"a\", coords: [100, 200], allowed_callers: [\"b\", \"c\"] },\n        { id: \"b\", coords: [150, 250], forbidden_callers: [\"d\"] },\n        { id: \"c\", coords: [200, 300], feature_flags: [\"flag1\", \"flag2\"] },\n      ],\n      edges: [\n        { from: \"a\", to: \"b\", allowed: true },\n        { from: \"b\", to: \"c\", allowed: false, reason: \"test\" },\n      ],\n      critical_rule: \"test rule with more text\",\n    };\n\n    const smallTokens = estimateTokens(smallFrame);\n    const largeTokens = estimateTokens(largeFrame);\n\n    assert.ok(largeTokens > smallTokens);\n  });\n});\n\ndescribe(\"autoTuneRadius\", () => {\n  test(\"returns frame when within token limit\", () => {\n    const generateFn = (radius) => ({\n      atlas_timestamp: \"2025-01-01T00:00:00Z\",\n      seed_modules: [\"a\"],\n      fold_radius: radius,\n      modules: [],\n      edges: [],\n      critical_rule: \"test\",\n    });\n\n    const result = autoTuneRadius(generateFn, 2, 10000);\n\n    assert.equal(result.radiusUsed, 2);\n    assert.ok(result.tokensUsed > 0);\n    assert.ok(result.tokensUsed < 10000);\n  });\n\n  test(\"reduces radius when exceeding token limit\", () => {\n    let callCount = 0;\n    const generateFn = (radius) => {\n      callCount++;\n      // Create frames that are clearly over/under the limit\n      // Radius 2 = ~331 tokens, radius 1 = ~231 tokens, radius 0 = ~131 tokens\n      const content = \"x\".repeat(radius * 400 + 400);\n      return {\n        atlas_timestamp: \"2025-01-01T00:00:00Z\",\n        seed_modules: [\"a\"],\n        fold_radius: radius,\n        modules: [],\n        edges: [],\n        critical_rule: content,\n      };\n    };\n\n    // Set limit to 250: radius 2 exceeds (331), radius 1 fits (231)\n    const result = autoTuneRadius(generateFn, 2, 250);\n\n    // Should have tried radius 2, then radius 1\n    assert.ok(callCount >= 2);\n    assert.equal(result.radiusUsed, 1);\n    assert.ok(result.tokensUsed <= 250);\n  });\n\n  test(\"stops at radius 0 if still exceeding limit\", () => {\n    const generateFn = (radius) => ({\n      atlas_timestamp: \"2025-01-01T00:00:00Z\",\n      seed_modules: [\"a\"],\n      fold_radius: radius,\n      modules: [],\n      edges: [],\n      critical_rule: \"x\".repeat(1000), // Always large\n    });\n\n    const result = autoTuneRadius(generateFn, 3, 10); // Very small limit\n\n    // Should reduce to radius 0 and stop\n    assert.equal(result.radiusUsed, 0);\n    // Even at radius 0, still exceeds limit, but returns anyway\n    assert.ok(result.tokensUsed > 10);\n  });\n\n  test(\"calls adjustment callback when reducing radius\", () => {\n    const adjustments = [];\n\n    const generateFn = (radius) => ({\n      atlas_timestamp: \"2025-01-01T00:00:00Z\",\n      seed_modules: [\"a\"],\n      fold_radius: radius,\n      modules: [],\n      edges: [],\n      critical_rule: \"x\".repeat(radius * 200 + 200),\n    });\n\n    const result = autoTuneRadius(generateFn, 3, 120, (oldRadius, newRadius, tokens, limit) => {\n      adjustments.push({ oldRadius, newRadius, tokens, limit });\n    });\n\n    // Should have reduced radius at least once\n    assert.ok(adjustments.length > 0);\n\n    // Each adjustment should show radius decreasing\n    for (const adj of adjustments) {\n      assert.equal(adj.newRadius, adj.oldRadius - 1);\n      assert.equal(adj.limit, 120);\n      assert.ok(adj.tokens > adj.limit);\n    }\n  });\n\n  test(\"does not call adjustment callback if no reduction needed\", () => {\n    let callbackCalled = false;\n\n    const generateFn = (radius) => ({\n      atlas_timestamp: \"2025-01-01T00:00:00Z\",\n      seed_modules: [\"a\"],\n      fold_radius: radius,\n      modules: [],\n      edges: [],\n      critical_rule: \"small\",\n    });\n\n    const result = autoTuneRadius(generateFn, 2, 10000, () => {\n      callbackCalled = true;\n    });\n\n    assert.equal(callbackCalled, false);\n    assert.equal(result.radiusUsed, 2);\n  });\n});\n\ndescribe(\"estimateTokensBeforeGeneration\", () => {\n  test(\"estimates increase with more seeds\", () => {\n    const tokens1 = estimateTokensBeforeGeneration(1, 1);\n    const tokens5 = estimateTokensBeforeGeneration(5, 1);\n\n    assert.ok(tokens5 > tokens1);\n  });\n\n  test(\"estimates increase with higher radius\", () => {\n    const radius0 = estimateTokensBeforeGeneration(1, 0);\n    const radius1 = estimateTokensBeforeGeneration(1, 1);\n    const radius2 = estimateTokensBeforeGeneration(1, 2);\n\n    assert.ok(radius1 > radius0);\n    assert.ok(radius2 > radius1);\n  });\n\n  test(\"uses custom average degree\", () => {\n    // Higher degree = more module expansion\n    const lowDegree = estimateTokensBeforeGeneration(1, 1, 2);\n    const highDegree = estimateTokensBeforeGeneration(1, 1, 5);\n\n    assert.ok(highDegree > lowDegree);\n  });\n\n  test(\"uses custom tokens per module\", () => {\n    const lowTokens = estimateTokensBeforeGeneration(1, 1, 3, 100);\n    const highTokens = estimateTokensBeforeGeneration(1, 1, 3, 500);\n\n    assert.ok(highTokens > lowTokens);\n  });\n\n  test(\"radius 0 returns approximately seed count * tokens per module\", () => {\n    const seeds = 5;\n    const tokensPerModule = 200;\n    const estimated = estimateTokensBeforeGeneration(seeds, 0, 3, tokensPerModule);\n\n    // Radius 0 = just seed modules + overhead\n    // Should be approximately seeds * tokensPerModule + overhead\n    const expected = seeds * tokensPerModule;\n\n    // Within 50% margin (rough estimate)\n    assert.ok(estimated >= expected * 0.5);\n    assert.ok(estimated <= expected * 1.5);\n  });\n});\n\nconsole.log(\"All auto-tune tests passed! ✅\");\n","usedDeprecatedRules":[]},{"filePath":"/srv/lex-mcp/lex/test/shared/atlas/cache.test.mjs","messages":[{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":246,"column":1,"nodeType":"MemberExpression","messageId":"unexpected","endLine":246,"endColumn":12,"suggestions":[{"fix":{"range":[6741,6782],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Tests for Atlas Frame Cache\n *\n * Run with: node shared/atlas/cache.test.mjs\n */\n\nimport { strict as assert } from \"assert\";\nimport { test, describe } from \"node:test\";\n// Adjusted import path to built dist output\nimport { AtlasFrameCache } from \"../../../dist/shared/atlas/cache.js\";\n\ndescribe(\"AtlasFrameCache\", () => {\n  test(\"stores and retrieves cache entries\", () => {\n    const cache = new AtlasFrameCache();\n    const mockFrame = {\n      atlas_timestamp: \"2025-01-01T00:00:00Z\",\n      seed_modules: [\"module-a\", \"module-b\"],\n      fold_radius: 1,\n      modules: [],\n      edges: [],\n      critical_rule: \"test\",\n    };\n\n    // Cache miss initially\n    const result1 = cache.get([\"module-a\", \"module-b\"], 1);\n    assert.equal(result1, undefined);\n\n    // Store in cache\n    cache.set([\"module-a\", \"module-b\"], 1, mockFrame);\n\n    // Cache hit\n    const result2 = cache.get([\"module-a\", \"module-b\"], 1);\n    assert.deepEqual(result2, mockFrame);\n  });\n\n  test(\"normalizes module order for cache keys\", () => {\n    const cache = new AtlasFrameCache();\n    const mockFrame = {\n      atlas_timestamp: \"2025-01-01T00:00:00Z\",\n      seed_modules: [\"module-a\", \"module-b\"],\n      fold_radius: 1,\n      modules: [],\n      edges: [],\n      critical_rule: \"test\",\n    };\n\n    // Store with one order\n    cache.set([\"module-b\", \"module-a\"], 1, mockFrame);\n\n    // Retrieve with different order - should hit cache\n    const result = cache.get([\"module-a\", \"module-b\"], 1);\n    assert.deepEqual(result, mockFrame);\n  });\n\n  test(\"different radii create different cache entries\", () => {\n    const cache = new AtlasFrameCache();\n    const frame1 = {\n      atlas_timestamp: \"2025-01-01T00:00:00Z\",\n      seed_modules: [\"module-a\"],\n      fold_radius: 1,\n      modules: [],\n      edges: [],\n      critical_rule: \"test\",\n    };\n    const frame2 = {\n      atlas_timestamp: \"2025-01-01T00:00:00Z\",\n      seed_modules: [\"module-a\"],\n      fold_radius: 2,\n      modules: [],\n      edges: [],\n      critical_rule: \"test\",\n    };\n\n    cache.set([\"module-a\"], 1, frame1);\n    cache.set([\"module-a\"], 2, frame2);\n\n    const result1 = cache.get([\"module-a\"], 1);\n    const result2 = cache.get([\"module-a\"], 2);\n\n    assert.deepEqual(result1, frame1);\n    assert.deepEqual(result2, frame2);\n  });\n\n  test(\"tracks cache hits and misses\", () => {\n    const cache = new AtlasFrameCache();\n    const mockFrame = {\n      atlas_timestamp: \"2025-01-01T00:00:00Z\",\n      seed_modules: [\"module-a\"],\n      fold_radius: 1,\n      modules: [],\n      edges: [],\n      critical_rule: \"test\",\n    };\n\n    // Initial stats\n    let stats = cache.getStats();\n    assert.equal(stats.hits, 0);\n    assert.equal(stats.misses, 0);\n\n    // Cache miss\n    cache.get([\"module-a\"], 1);\n    stats = cache.getStats();\n    assert.equal(stats.hits, 0);\n    assert.equal(stats.misses, 1);\n\n    // Store and hit\n    cache.set([\"module-a\"], 1, mockFrame);\n    cache.get([\"module-a\"], 1);\n    stats = cache.getStats();\n    assert.equal(stats.hits, 1);\n    assert.equal(stats.misses, 1);\n\n    // Multiple hits\n    cache.get([\"module-a\"], 1);\n    cache.get([\"module-a\"], 1);\n    stats = cache.getStats();\n    assert.equal(stats.hits, 3);\n    assert.equal(stats.misses, 1);\n  });\n\n  test(\"calculates hit rate correctly\", () => {\n    const cache = new AtlasFrameCache();\n    const mockFrame = {\n      atlas_timestamp: \"2025-01-01T00:00:00Z\",\n      seed_modules: [\"module-a\"],\n      fold_radius: 1,\n      modules: [],\n      edges: [],\n      critical_rule: \"test\",\n    };\n\n    // No accesses yet\n    assert.equal(cache.getHitRate(), 0);\n\n    // 1 miss, 0 hits = 0% hit rate\n    cache.get([\"module-a\"], 1);\n    assert.equal(cache.getHitRate(), 0);\n\n    // Store and get - 1 miss, 1 hit = 50%\n    cache.set([\"module-a\"], 1, mockFrame);\n    cache.get([\"module-a\"], 1);\n    assert.equal(cache.getHitRate(), 0.5);\n\n    // 1 miss, 3 hits = 75%\n    cache.get([\"module-a\"], 1);\n    cache.get([\"module-a\"], 1);\n    assert.equal(cache.getHitRate(), 0.75);\n  });\n\n  test(\"evicts LRU entries when cache is full\", () => {\n    const cache = new AtlasFrameCache(3); // Small cache for testing\n    const makeFrame = (id) => ({\n      atlas_timestamp: \"2025-01-01T00:00:00Z\",\n      seed_modules: [id],\n      fold_radius: 1,\n      modules: [],\n      edges: [],\n      critical_rule: \"test\",\n    });\n\n    // Fill cache\n    cache.set([\"module-1\"], 1, makeFrame(\"module-1\"));\n    cache.set([\"module-2\"], 1, makeFrame(\"module-2\"));\n    cache.set([\"module-3\"], 1, makeFrame(\"module-3\"));\n\n    let stats = cache.getStats();\n    assert.equal(stats.size, 3);\n    assert.equal(stats.evictions, 0);\n\n    // Access module-1 to make it more recent\n    cache.get([\"module-1\"], 1);\n\n    // Add module-4 - should evict module-2 (least recently used)\n    cache.set([\"module-4\"], 1, makeFrame(\"module-4\"));\n\n    stats = cache.getStats();\n    assert.equal(stats.size, 3);\n    assert.equal(stats.evictions, 1);\n\n    // module-2 should be evicted\n    assert.equal(cache.get([\"module-2\"], 1), undefined);\n\n    // module-1, module-3, module-4 should still be cached\n    assert.notEqual(cache.get([\"module-1\"], 1), undefined);\n    assert.notEqual(cache.get([\"module-3\"], 1), undefined);\n    assert.notEqual(cache.get([\"module-4\"], 1), undefined);\n  });\n\n  test(\"clear removes all entries\", () => {\n    const cache = new AtlasFrameCache();\n    const mockFrame = {\n      atlas_timestamp: \"2025-01-01T00:00:00Z\",\n      seed_modules: [\"module-a\"],\n      fold_radius: 1,\n      modules: [],\n      edges: [],\n      critical_rule: \"test\",\n    };\n\n    cache.set([\"module-a\"], 1, mockFrame);\n    cache.set([\"module-b\"], 1, mockFrame);\n\n    let stats = cache.getStats();\n    assert.equal(stats.size, 2);\n\n    cache.clear();\n\n    stats = cache.getStats();\n    assert.equal(stats.size, 0);\n    assert.equal(cache.get([\"module-a\"], 1), undefined);\n    assert.equal(cache.get([\"module-b\"], 1), undefined);\n  });\n\n  test(\"resetStats clears statistics but keeps entries\", () => {\n    const cache = new AtlasFrameCache();\n    const mockFrame = {\n      atlas_timestamp: \"2025-01-01T00:00:00Z\",\n      seed_modules: [\"module-a\"],\n      fold_radius: 1,\n      modules: [],\n      edges: [],\n      critical_rule: \"test\",\n    };\n\n    cache.set([\"module-a\"], 1, mockFrame);\n    cache.get([\"module-a\"], 1);\n    cache.get([\"module-b\"], 1); // miss\n\n    let stats = cache.getStats();\n    assert.equal(stats.hits, 1);\n    assert.equal(stats.misses, 1);\n    assert.equal(stats.size, 1);\n\n    cache.resetStats();\n\n    stats = cache.getStats();\n    assert.equal(stats.hits, 0);\n    assert.equal(stats.misses, 0);\n    assert.equal(stats.size, 1); // Size not reset\n\n    // Entry should still be there\n    assert.notEqual(cache.get([\"module-a\"], 1), undefined);\n  });\n});\n\nconsole.log(\"All cache tests passed! ✅\");\n","usedDeprecatedRules":[]},{"filePath":"/srv/lex-mcp/lex/test/shared/cli/cli.test.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'readFileSync' is defined but never used. Allowed unused vars must match /^_/u.","line":10,"column":56,"nodeType":null,"messageId":"unusedVar","endLine":10,"endColumn":68},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":109,"column":19,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":109,"endColumn":22,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3242,3245],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3242,3245],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .stderr on an `any` value.","line":111,"column":13,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":111,"endColumn":19},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .stdout on an `any` value.","line":111,"column":29,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":111,"endColumn":35},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":1,"message":"Unsafe assignment of an `any` value.","line":132,"column":11,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":132,"endColumn":43},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .id on an `any` value.","line":133,"column":20,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":133,"endColumn":22},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .timestamp on an `any` value.","line":134,"column":20,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":134,"endColumn":29},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":1,"message":"Unsafe assignment of an `any` value.","line":185,"column":11,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":185,"endColumn":43},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .frame on an `any` value.","line":188,"column":23,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":188,"endColumn":28},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":253,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":253,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7396,7399],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7396,7399],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .status on an `any` value.","line":254,"column":32,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":254,"endColumn":38},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":1,"message":"Unsafe assignment of an `any` value.","line":255,"column":13,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":255,"endColumn":50},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .stdout on an `any` value.","line":255,"column":28,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":255,"endColumn":34},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .stderr on an `any` value.","line":255,"column":44,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":255,"endColumn":50},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":1,"message":"Unsafe assignment of an `any` value.","line":280,"column":11,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":280,"endColumn":43},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .violations on an `any` value.","line":281,"column":34,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":281,"endColumn":44},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .count on an `any` value.","line":282,"column":29,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":282,"endColumn":34},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":1,"message":"Unsafe assignment of an `any` value.","line":347,"column":11,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":347,"endColumn":43},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .frame on an `any` value.","line":350,"column":23,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":350,"endColumn":28}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":19,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * CLI Tests\n *\n * Tests for lex remember, lex recall, and lex check commands\n */\n\nimport { test } from \"node:test\";\nimport assert from \"node:assert\";\nimport { execSync } from \"node:child_process\";\nimport { writeFileSync, mkdirSync, existsSync, rmSync, readFileSync } from \"fs\";\nimport { join } from \"path\";\nimport { tmpdir } from \"os\";\n\nconst testDir = join(tmpdir(), \"lex-cli-test-\" + Date.now());\nconst testDbPath = join(testDir, \"frames.db\");\nconst lexBin = join(process.cwd(), \"dist\", \"shared\", \"cli\", \"lex.js\");\n\n// Setup test environment\nfunction setupTest() {\n  if (existsSync(testDir)) {\n    rmSync(testDir, { recursive: true, force: true });\n  }\n  mkdirSync(testDir, { recursive: true });\n\n  // Create a minimal policy file for testing\n  const policyPath = join(testDir, \"lexmap.policy.json\");\n  const policy = {\n    modules: {\n      \"ui/admin-panel\": {\n        owns_paths: [\"web-ui/admin/**\"],\n      },\n      \"services/auth-core\": {\n        owns_paths: [\"backend/auth/**\"],\n        forbidden_callers: [\"ui/**\"],\n      },\n      \"services/user-api\": {\n        owns_paths: [\"backend/users/**\"],\n      },\n    },\n  };\n  writeFileSync(policyPath, JSON.stringify(policy, null, 2));\n\n  // Set environment variable for policy path\n  process.env.LEX_POLICY_PATH = policyPath;\n  process.env.LEX_DB_PATH = testDbPath;\n}\n\nfunction cleanup() {\n  if (existsSync(testDir)) {\n    rmSync(testDir, { recursive: true, force: true });\n  }\n  delete process.env.LEX_POLICY_PATH;\n  delete process.env.LEX_DB_PATH;\n}\n\ntest(\"CLI: lex --version shows version\", () => {\n  setupTest();\n  try {\n    const output = execSync(`node ${lexBin} --version`, { encoding: \"utf-8\" });\n    assert.match(output, /\\d+\\.\\d+\\.\\d+/, \"Version should be in semver format\");\n  } finally {\n    cleanup();\n  }\n});\n\ntest(\"CLI: lex --help shows help text\", () => {\n  setupTest();\n  try {\n    const output = execSync(`node ${lexBin} --help`, { encoding: \"utf-8\" });\n    assert.match(output, /remember/, \"Help should mention remember command\");\n    assert.match(output, /recall/, \"Help should mention recall command\");\n    assert.match(output, /check/, \"Help should mention check command\");\n  } finally {\n    cleanup();\n  }\n});\n\ntest(\"CLI: lex remember with valid module_scope succeeds\", () => {\n  setupTest();\n  try {\n    const output = execSync(\n      `node ${lexBin} remember ` +\n        `--reference-point \"test frame\" ` +\n        `--summary \"Test summary\" ` +\n        `--next \"Test next action\" ` +\n        `--modules \"ui/admin-panel,services/user-api\"`,\n      { encoding: \"utf-8\", env: { ...process.env, LEX_DB_PATH: testDbPath } }\n    );\n\n    assert.match(output, /Frame created successfully/, \"Should show success message\");\n    assert.match(output, /Frame ID:/, \"Should show Frame ID\");\n  } finally {\n    cleanup();\n  }\n});\n\ntest(\"CLI: lex remember with invalid module_scope fails\", () => {\n  setupTest();\n  try {\n    execSync(\n      `node ${lexBin} remember ` +\n        `--reference-point \"test frame\" ` +\n        `--summary \"Test summary\" ` +\n        `--next \"Test next action\" ` +\n        `--modules \"invalid-module\"`,\n      { encoding: \"utf-8\", env: { ...process.env, LEX_DB_PATH: testDbPath } }\n    );\n    assert.fail(\"Should have thrown an error\");\n  } catch (error: any) {\n    assert.match(\n      error.stderr || error.stdout,\n      /Module validation failed/,\n      \"Should show validation error\"\n    );\n  } finally {\n    cleanup();\n  }\n});\n\ntest(\"CLI: lex remember with --json outputs JSON\", () => {\n  setupTest();\n  try {\n    const output = execSync(\n      `node ${lexBin} --json remember ` +\n        `--reference-point \"json test\" ` +\n        `--summary \"JSON test\" ` +\n        `--next \"Test action\" ` +\n        `--modules \"ui/admin-panel\"`,\n      { encoding: \"utf-8\", env: { ...process.env, LEX_DB_PATH: testDbPath } }\n    );\n\n    const json = JSON.parse(output.trim());\n    assert.ok(json.id, \"JSON should contain Frame ID\");\n    assert.ok(json.timestamp, \"JSON should contain timestamp\");\n  } finally {\n    cleanup();\n  }\n});\n\ntest(\"CLI: lex recall retrieves created frame\", () => {\n  setupTest();\n  try {\n    // Create a frame first\n    execSync(\n      `node ${lexBin} remember ` +\n        `--reference-point \"recall test frame\" ` +\n        `--summary \"Test recall\" ` +\n        `--next \"Test action\" ` +\n        `--modules \"ui/admin-panel\"`,\n      { encoding: \"utf-8\", env: { ...process.env, LEX_DB_PATH: testDbPath } }\n    );\n\n    // Recall it\n    const output = execSync(`node ${lexBin} recall \"recall test frame\"`, {\n      encoding: \"utf-8\",\n      env: { ...process.env, LEX_DB_PATH: testDbPath },\n    });\n\n    assert.match(output, /recall test frame/, \"Should show reference point\");\n    assert.match(output, /Test recall/, \"Should show summary\");\n  } finally {\n    cleanup();\n  }\n});\n\ntest(\"CLI: lex recall with --json outputs JSON\", () => {\n  setupTest();\n  try {\n    // Create a frame first\n    execSync(\n      `node ${lexBin} remember ` +\n        `--reference-point \"json recall test\" ` +\n        `--summary \"JSON recall\" ` +\n        `--next \"Test action\" ` +\n        `--modules \"ui/admin-panel\"`,\n      { encoding: \"utf-8\", env: { ...process.env, LEX_DB_PATH: testDbPath } }\n    );\n\n    // Recall it\n    const output = execSync(`node ${lexBin} --json recall \"json recall test\"`, {\n      encoding: \"utf-8\",\n      env: { ...process.env, LEX_DB_PATH: testDbPath },\n    });\n\n    const json = JSON.parse(output.trim());\n    assert.ok(Array.isArray(json), \"JSON should be an array\");\n    assert.ok(json.length > 0, \"JSON should contain results\");\n    assert.ok(json[0].frame, \"JSON should contain frame data\");\n  } finally {\n    cleanup();\n  }\n});\n\ntest(\"CLI: lex check with no violations exits with 0\", () => {\n  setupTest();\n  try {\n    const mergedPath = join(testDir, \"merged.json\");\n    const policyPath = join(testDir, \"lexmap.policy.json\");\n\n    // Create a merged scanner output with no violations\n    const merged = {\n      sources: [\"test\"],\n      files: [\n        {\n          path: \"web-ui/admin/test.ts\",\n          module_scope: \"ui/admin-panel\",\n          declarations: [],\n          imports: [{ from: \"services/user-api\", type: \"default\" }],\n          feature_flags: [],\n          permissions: [],\n          warnings: [],\n        },\n      ],\n    };\n    writeFileSync(mergedPath, JSON.stringify(merged, null, 2));\n\n    const output = execSync(`node ${lexBin} check ${mergedPath} ${policyPath}`, {\n      encoding: \"utf-8\",\n    });\n\n    assert.match(output, /No policy violations/, \"Should show no violations\");\n  } finally {\n    cleanup();\n  }\n});\n\ntest(\"CLI: lex check with violations exits with 1\", () => {\n  setupTest();\n  try {\n    const mergedPath = join(testDir, \"merged.json\");\n    const policyPath = join(testDir, \"lexmap.policy.json\");\n\n    // Create a merged scanner output with violations\n    const merged = {\n      sources: [\"test\"],\n      files: [\n        {\n          path: \"web-ui/admin/test.ts\",\n          module_scope: \"ui/admin-panel\",\n          declarations: [],\n          imports: [{ from: \"services/auth-core\", type: \"default\" }],\n          feature_flags: [],\n          permissions: [],\n          warnings: [],\n        },\n      ],\n    };\n    writeFileSync(mergedPath, JSON.stringify(merged, null, 2));\n\n    try {\n      execSync(`node ${lexBin} check ${mergedPath} ${policyPath}`, { encoding: \"utf-8\" });\n      assert.fail(\"Should have exited with code 1\");\n    } catch (error: any) {\n      assert.strictEqual(error.status, 1, \"Should exit with code 1\");\n      const output = error.stdout || error.stderr;\n      assert.match(output, /violation/i, \"Should mention violations\");\n    }\n  } finally {\n    cleanup();\n  }\n});\n\ntest(\"CLI: lex check with --json outputs JSON\", () => {\n  setupTest();\n  try {\n    const mergedPath = join(testDir, \"merged.json\");\n    const policyPath = join(testDir, \"lexmap.policy.json\");\n\n    // Create a merged scanner output with no violations\n    const merged = {\n      sources: [\"test\"],\n      files: [],\n    };\n    writeFileSync(mergedPath, JSON.stringify(merged, null, 2));\n\n    const output = execSync(`node ${lexBin} --json check ${mergedPath} ${policyPath}`, {\n      encoding: \"utf-8\",\n    });\n\n    const json = JSON.parse(output.trim());\n    assert.ok(Array.isArray(json.violations), \"JSON should contain violations array\");\n    assert.strictEqual(json.count, 0, \"JSON should show count of 0\");\n  } finally {\n    cleanup();\n  }\n});\n\ntest(\"CLI: lex timeline shows frames for a ticket\", () => {\n  setupTest();\n  try {\n    // Create multiple frames for the same ticket\n    execSync(\n      `node ${lexBin} remember ` +\n        `--jira TICKET-123 ` +\n        `--reference-point \"frame 1\" ` +\n        `--summary \"First frame\" ` +\n        `--next \"Test action 1\" ` +\n        `--modules \"ui/admin-panel\"`,\n      { encoding: \"utf-8\", env: { ...process.env, LEX_DB_PATH: testDbPath } }\n    );\n\n    execSync(\n      `node ${lexBin} remember ` +\n        `--jira TICKET-123 ` +\n        `--reference-point \"frame 2\" ` +\n        `--summary \"Second frame\" ` +\n        `--next \"Test action 2\" ` +\n        `--modules \"ui/admin-panel,services/user-api\"`,\n      { encoding: \"utf-8\", env: { ...process.env, LEX_DB_PATH: testDbPath } }\n    );\n\n    // Get timeline\n    const output = execSync(`node ${lexBin} timeline TICKET-123`, {\n      encoding: \"utf-8\",\n      env: { ...process.env, LEX_DB_PATH: testDbPath },\n    });\n\n    assert.match(output, /TICKET-123/, \"Should show ticket ID\");\n    assert.match(output, /First frame/, \"Should show first frame\");\n    assert.match(output, /Second frame/, \"Should show second frame\");\n    assert.match(output, /Module Scope Evolution/, \"Should show module scope evolution\");\n  } finally {\n    cleanup();\n  }\n});\n\ntest(\"CLI: lex timeline with --format=json outputs JSON\", () => {\n  setupTest();\n  try {\n    // Create a frame\n    execSync(\n      `node ${lexBin} remember ` +\n        `--jira TICKET-456 ` +\n        `--reference-point \"json timeline test\" ` +\n        `--summary \"JSON test\" ` +\n        `--next \"Test action\" ` +\n        `--modules \"ui/admin-panel\"`,\n      { encoding: \"utf-8\", env: { ...process.env, LEX_DB_PATH: testDbPath } }\n    );\n\n    // Get timeline as JSON\n    const output = execSync(`node ${lexBin} timeline TICKET-456 --format=json`, {\n      encoding: \"utf-8\",\n      env: { ...process.env, LEX_DB_PATH: testDbPath },\n    });\n\n    const json = JSON.parse(output.trim());\n    assert.ok(Array.isArray(json), \"JSON should be an array\");\n    assert.ok(json.length > 0, \"JSON should contain timeline entries\");\n    assert.ok(json[0].frame, \"Entry should contain frame\");\n  } finally {\n    cleanup();\n  }\n});\n\ntest(\"CLI: lex timeline shows blocker evolution\", () => {\n  setupTest();\n  try {\n    // Create frames with blockers\n    execSync(\n      `node ${lexBin} remember ` +\n        `--jira TICKET-789 ` +\n        `--reference-point \"blocker test 1\" ` +\n        `--summary \"Frame with blocker\" ` +\n        `--next \"Test action\" ` +\n        `--modules \"ui/admin-panel\" ` +\n        `--blockers \"CORS issue\"`,\n      { encoding: \"utf-8\", env: { ...process.env, LEX_DB_PATH: testDbPath } }\n    );\n\n    execSync(\n      `node ${lexBin} remember ` +\n        `--jira TICKET-789 ` +\n        `--reference-point \"blocker test 2\" ` +\n        `--summary \"Frame without blocker\" ` +\n        `--next \"Test action\" ` +\n        `--modules \"ui/admin-panel\"`,\n      { encoding: \"utf-8\", env: { ...process.env, LEX_DB_PATH: testDbPath } }\n    );\n\n    // Get timeline\n    const output = execSync(`node ${lexBin} timeline TICKET-789`, {\n      encoding: \"utf-8\",\n      env: { ...process.env, LEX_DB_PATH: testDbPath },\n    });\n\n    assert.match(output, /CORS issue/, \"Should show blocker\");\n    assert.match(output, /Blocker Tracking/, \"Should show blocker tracking section\");\n  } finally {\n    cleanup();\n  }\n});\n","usedDeprecatedRules":[]},{"filePath":"/srv/lex-mcp/lex/test/shared/git/branch.test.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'e' is defined but never used.","line":44,"column":16,"nodeType":null,"messageId":"unusedVar","endLine":44,"endColumn":17}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Tests for git branch detection utilities\n *\n * Tests cover:\n * - Normal git repository branch detection\n * - Detached HEAD state\n * - Non-git directory\n * - Environment variable override\n * - Caching behavior\n * - Error handling\n */\n\nimport { test, describe, beforeEach } from \"node:test\";\nimport assert from \"node:assert\";\nimport { getCurrentBranch, clearBranchCache } from \"@app/shared/git/branch.js\";\nimport { execSync } from \"child_process\";\nimport { mkdtempSync, rmSync } from \"fs\";\nimport { join } from \"path\";\nimport { tmpdir } from \"os\";\n\ndescribe(\"Git Branch Detection\", () => {\n  let originalDir: string;\n  let originalEnv: string | undefined;\n\n  // Setup: save current directory and environment\n  beforeEach(() => {\n    originalDir = process.cwd();\n    originalEnv = process.env.LEX_DEFAULT_BRANCH;\n    delete process.env.LEX_DEFAULT_BRANCH;\n    clearBranchCache();\n  });\n\n  // Teardown helper\n  function teardown(testDir?: string) {\n    process.chdir(originalDir);\n    if (originalEnv !== undefined) {\n      process.env.LEX_DEFAULT_BRANCH = originalEnv;\n    } else {\n      delete process.env.LEX_DEFAULT_BRANCH;\n    }\n    if (testDir) {\n      try {\n        rmSync(testDir, { recursive: true, force: true });\n      } catch (e) {\n        // Ignore cleanup errors\n      }\n    }\n    clearBranchCache();\n  }\n\n  test(\"detects current branch in normal git repository\", () => {\n    try {\n      // We're in the lex repo, so this should return the actual branch\n      const branch = getCurrentBranch();\n\n      // Should not be the fallback values\n      assert.notStrictEqual(branch, \"unknown\", \"Should detect branch in git repo\");\n      assert.notStrictEqual(branch, \"\", \"Branch should not be empty\");\n\n      // Should match what git actually says (unless detached)\n      if (branch !== \"detached\") {\n        const actualBranch = execSync(\"git rev-parse --abbrev-ref HEAD\", {\n          encoding: \"utf-8\",\n        }).trim();\n        assert.strictEqual(branch, actualBranch, \"Should match actual git branch\");\n      }\n    } finally {\n      teardown();\n    }\n  });\n\n  test(\"handles detached HEAD state\", () => {\n    // Create a temporary git repository\n    const testDir = mkdtempSync(join(tmpdir(), \"lex-git-test-\"));\n\n    try {\n      process.chdir(testDir);\n\n      // Initialize git repo\n      execSync(\"git init\", { stdio: \"pipe\" });\n      execSync('git config user.email \"test@example.com\"', { stdio: \"pipe\" });\n      execSync('git config user.name \"Test User\"', { stdio: \"pipe\" });\n\n      // Create a commit\n      execSync(\"touch test.txt\", { stdio: \"pipe\" });\n      execSync(\"git add test.txt\", { stdio: \"pipe\" });\n      execSync('git commit -m \"Initial commit\"', { stdio: \"pipe\" });\n\n      // Get the commit hash\n      const commitHash = execSync(\"git rev-parse HEAD\", {\n        encoding: \"utf-8\",\n      }).trim();\n\n      // Checkout the commit to create detached HEAD\n      execSync(`git checkout ${commitHash}`, { stdio: \"pipe\" });\n\n      // Clear cache and test\n      clearBranchCache();\n      const branch = getCurrentBranch();\n\n      assert.strictEqual(branch, \"detached\", \"Should return 'detached' for detached HEAD\");\n    } finally {\n      teardown(testDir);\n    }\n  });\n\n  test(\"handles non-git directory\", () => {\n    // Create a temporary non-git directory\n    const testDir = mkdtempSync(join(tmpdir(), \"lex-nongit-test-\"));\n\n    try {\n      process.chdir(testDir);\n\n      const branch = getCurrentBranch();\n\n      assert.strictEqual(branch, \"unknown\", \"Should return 'unknown' for non-git directory\");\n    } finally {\n      teardown(testDir);\n    }\n  });\n\n  test(\"respects LEX_DEFAULT_BRANCH environment variable\", () => {\n    try {\n      process.env.LEX_DEFAULT_BRANCH = \"custom-branch\";\n      clearBranchCache();\n\n      const branch = getCurrentBranch();\n\n      assert.strictEqual(branch, \"custom-branch\", \"Should return env var value\");\n    } finally {\n      teardown();\n    }\n  });\n\n  test(\"environment variable override takes precedence over git\", () => {\n    try {\n      // Even in a git repo, env var should take precedence\n      process.env.LEX_DEFAULT_BRANCH = \"env-override\";\n      clearBranchCache();\n\n      const branch = getCurrentBranch();\n\n      assert.strictEqual(branch, \"env-override\", \"Env var should override git detection\");\n    } finally {\n      teardown();\n    }\n  });\n\n  test(\"caches branch result for performance\", () => {\n    try {\n      clearBranchCache();\n\n      // First call\n      const branch1 = getCurrentBranch();\n\n      // Second call should return cached value (same result)\n      const branch2 = getCurrentBranch();\n\n      assert.strictEqual(branch1, branch2, \"Cached result should match first call\");\n    } finally {\n      teardown();\n    }\n  });\n\n  test(\"clearBranchCache allows re-detection\", () => {\n    // Create a temporary git repository\n    const testDir = mkdtempSync(join(tmpdir(), \"lex-cache-test-\"));\n\n    try {\n      process.chdir(testDir);\n\n      // Initialize git repo with a branch\n      execSync(\"git init\", { stdio: \"pipe\" });\n      execSync('git config user.email \"test@example.com\"', { stdio: \"pipe\" });\n      execSync('git config user.name \"Test User\"', { stdio: \"pipe\" });\n      execSync(\"touch test.txt\", { stdio: \"pipe\" });\n      execSync(\"git add test.txt\", { stdio: \"pipe\" });\n      execSync('git commit -m \"Initial commit\"', { stdio: \"pipe\" });\n\n      // Get initial branch\n      clearBranchCache();\n      const branch1 = getCurrentBranch();\n\n      // Switch to a new branch\n      execSync(\"git checkout -b feature-branch\", { stdio: \"pipe\" });\n\n      // Without clearing cache, should return old value\n      const branch2 = getCurrentBranch();\n      assert.strictEqual(branch2, branch1, \"Should return cached value\");\n\n      // After clearing cache, should detect new branch\n      clearBranchCache();\n      const branch3 = getCurrentBranch();\n      assert.strictEqual(branch3, \"feature-branch\", \"Should detect new branch after cache clear\");\n    } finally {\n      teardown(testDir);\n    }\n  });\n\n  test(\"handles git command errors gracefully\", () => {\n    // Create a temporary directory\n    const testDir = mkdtempSync(join(tmpdir(), \"lex-error-test-\"));\n\n    try {\n      process.chdir(testDir);\n\n      // No git repo, so command should fail\n      const branch = getCurrentBranch();\n\n      assert.strictEqual(branch, \"unknown\", \"Should handle git errors gracefully\");\n    } finally {\n      teardown(testDir);\n    }\n  });\n});\n","usedDeprecatedRules":[]},{"filePath":"/srv/lex-mcp/lex/test/shared/module_ids/validator.test.mjs","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/srv/lex-mcp/lex/test/shared/module_ids/validator.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/srv/lex-mcp/lex/test/shared/policy/loader.test.mjs","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/srv/lex-mcp/lex/test/shared/policy/loader.test.ts","messages":[{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":1,"message":"Unsafe assignment of an error typed value.","line":22,"column":11,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":22,"endColumn":32},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .modules on an `error` typed value.","line":25,"column":22,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":25,"endColumn":29},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .modules on an `error` typed value.","line":26,"column":32,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":26,"endColumn":39},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .modules on an `error` typed value.","line":29,"column":22,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":29,"endColumn":29},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .modules on an `error` typed value.","line":30,"column":22,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":30,"endColumn":29},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .modules on an `error` typed value.","line":31,"column":22,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":31,"endColumn":29},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .modules on an `error` typed value.","line":32,"column":22,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":32,"endColumn":29},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":1,"message":"Unsafe assignment of an error typed value.","line":38,"column":11,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":38,"endColumn":33},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":1,"message":"Unsafe assignment of an error typed value.","line":39,"column":11,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":39,"endColumn":33},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":1,"message":"Unsafe assignment of an error typed value.","line":52,"column":11,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":52,"endColumn":42},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .modules on an `error` typed value.","line":55,"column":22,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":55,"endColumn":29},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":1,"message":"Unsafe assignment of an error typed value.","line":75,"column":13,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":75,"endColumn":34},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .modules on an `error` typed value.","line":77,"column":24,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":77,"endColumn":31},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":1,"message":"Unsafe assignment of an error typed value.","line":114,"column":13,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":114,"endColumn":34},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .modules on an `error` typed value.","line":117,"column":24,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":117,"endColumn":31},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":1,"message":"Unsafe assignment of an error typed value.","line":132,"column":11,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":132,"endColumn":33},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":1,"message":"Unsafe assignment of an error typed value.","line":134,"column":11,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":134,"endColumn":33},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .modules on an `error` typed value.","line":140,"column":30,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":140,"endColumn":37},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .modules on an `error` typed value.","line":140,"column":47,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":140,"endColumn":54}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":19,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Tests for Policy Loader\n *\n * Run with: node shared/policy/loader.test.mjs\n */\n\nimport { strict as assert } from \"assert\";\nimport { test, describe } from \"node:test\";\nimport { loadPolicy, clearPolicyCache } from \"@app/shared/policy/loader.js\";\nimport { fileURLToPath } from \"url\";\nimport { dirname, resolve, join } from \"path\";\nimport { existsSync, readFileSync, unlinkSync, mkdirSync, writeFileSync } from \"fs\";\n\nconst __filename = fileURLToPath(import.meta.url);\nconst __dirname = dirname(__filename);\n\ndescribe(\"loadPolicy\", () => {\n  test(\"loads policy from default path\", () => {\n    // Clear cache to ensure we're loading fresh\n    clearPolicyCache();\n\n    const policy = loadPolicy();\n\n    assert.ok(policy);\n    assert.ok(policy.modules);\n    assert.equal(typeof policy.modules, \"object\");\n\n    // Verify it has the expected modules from lexmap.policy.json\n    assert.ok(policy.modules[\"memory/store\"]);\n    assert.ok(policy.modules[\"policy/check\"]);\n    assert.ok(policy.modules[\"shared/types\"]);\n    assert.ok(policy.modules[\"cli\"]);\n  });\n\n  test(\"caches policy on subsequent loads\", () => {\n    clearPolicyCache();\n\n    const policy1 = loadPolicy();\n    const policy2 = loadPolicy();\n\n    // Should return the same cached object\n    assert.strictEqual(policy1, policy2);\n  });\n\n  test(\"custom path overrides default\", () => {\n    clearPolicyCache();\n\n    const customPath = resolve(\n      __dirname,\n      \"../../../src/policy/policy_spec/lexmap.policy.json.example\"\n    );\n    const policy = loadPolicy(customPath);\n\n    assert.ok(policy);\n    assert.ok(policy.modules);\n  });\n\n  test(\"falls back to example file when working file missing\", () => {\n    clearPolicyCache();\n\n    const repoRoot = resolve(__dirname, \"../../..\");\n    const workingPath = join(repoRoot, \".smartergpt.local/lex/lexmap.policy.json\");\n\n    let workingFileExisted = false;\n    let workingFileContent = null;\n\n    try {\n      if (existsSync(workingPath)) {\n        workingFileExisted = true;\n        workingFileContent = readFileSync(workingPath, \"utf-8\");\n        unlinkSync(workingPath);\n      }\n\n      // Should still load from example file\n      const policy = loadPolicy();\n      assert.ok(policy);\n      assert.ok(policy.modules);\n    } finally {\n      // Restore working file if it existed\n      if (workingFileExisted && workingFileContent) {\n        const dir = dirname(workingPath);\n        if (!existsSync(dir)) {\n          mkdirSync(dir, { recursive: true });\n        }\n        writeFileSync(workingPath, workingFileContent);\n      }\n      clearPolicyCache();\n    }\n  });\n\n  test(\"throws error for non-existent file\", () => {\n    clearPolicyCache();\n\n    assert.throws(() => {\n      loadPolicy(\"/nonexistent/path/policy.json\");\n    }, /Policy file not found/);\n  });\n\n  test(\"throws error for invalid JSON\", () => {\n    // This test would need a temp file with invalid JSON\n    // Skipping for now as it requires more setup\n  });\n\n  test(\"environment variable works for custom path\", () => {\n    clearPolicyCache();\n\n    const originalEnv = process.env.LEX_POLICY_PATH;\n\n    try {\n      process.env.LEX_POLICY_PATH = resolve(\n        __dirname,\n        \"../../../src/policy/policy_spec/lexmap.policy.json.example\"\n      );\n      const policy = loadPolicy();\n\n      assert.ok(policy);\n      assert.ok(policy.modules);\n    } finally {\n      // Restore original env\n      if (originalEnv) {\n        process.env.LEX_POLICY_PATH = originalEnv;\n      } else {\n        delete process.env.LEX_POLICY_PATH;\n      }\n      clearPolicyCache();\n    }\n  });\n\n  test(\"clearPolicyCache clears the cache\", () => {\n    clearPolicyCache();\n\n    const policy1 = loadPolicy();\n    clearPolicyCache();\n    const policy2 = loadPolicy();\n\n    // Should be different objects since cache was cleared\n    assert.notStrictEqual(policy1, policy2);\n\n    // But content should be the same\n    assert.deepEqual(policy1.modules, policy2.modules);\n  });\n});\n","usedDeprecatedRules":[]},{"filePath":"/srv/lex-mcp/lex/test/shared/types/frame.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]}]
