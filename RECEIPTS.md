# Receipts: End-to-End Walkthrough

A **receipt** is proof that your work aligns with architectural policy. This guide shows how to capture work context, recall it later, and verify policy compliance—all with audit trails.

## Scenario

You're implementing a new authentication feature:
1. Write some code
2. Capture your progress with a Frame
3. Check policy compliance
4. Later: recall what you were working on
5. Get policy explanation for blocked edges

---

## Step 1: Set Up Policy

Create a minimal `lexmap.policy.json`:

```json
{
  "modules": {
    "services/auth-core": {
      "owns": ["src/services/auth/**"],
      "allowedCallers": ["services/api-gateway", "services/user-mgmt"],
      "forbiddenCallers": [],
      "allowedDeps": ["shared/utils", "shared/types"],
      "forbiddenDeps": ["services/legacy-auth"],
      "requiredPermissions": [],
      "requiredFlags": []
    },
    "services/legacy-auth": {
      "owns": ["src/services/legacy/**"],
      "allowedCallers": [],
      "forbiddenCallers": ["services/auth-core"],
      "allowedDeps": [],
      "forbiddenDeps": [],
      "requiredPermissions": [],
      "requiredFlags": [],
      "killPatterns": ["LegacyAuth", "OldPasswordHash"]
    },
    "services/api-gateway": {
      "owns": ["src/gateway/**"],
      "allowedCallers": [],
      "forbiddenCallers": [],
      "allowedDeps": ["services/auth-core"],
      "forbiddenDeps": [],
      "requiredPermissions": [],
      "requiredFlags": []
    }
  }
}
```

This policy says:
- `auth-core` can be called by `api-gateway` and `user-mgmt`
- `auth-core` **must not** depend on `legacy-auth`
- `legacy-auth` is being sunset (kill patterns)

---

## Step 2: Capture a Frame (CLI)

```bash
lex remember \
  --jira AUTH-456 \
  --summary "Refactored password hashing to use bcrypt" \
  --next "Remove LegacyAuth references from gateway" \
  --modules "services/auth-core,services/api-gateway" \
  --blockers "Gateway still imports legacy-auth - forbidden edge" \
  --branch "feature/modern-auth"
```

**Output:**
```
✓ Frame captured: frame_abc123
  Summary: Refactored password hashing to use bcrypt
  Modules: services/auth-core, services/api-gateway
  Next: Remove LegacyAuth references from gateway
  Blockers:
    - Gateway still imports legacy-auth - forbidden edge
```

**What happened:**
- Lex stored a timestamped snapshot of your work session
- The Frame includes module scope, branch, next action, and blockers
- This is your **memory receipt**—you can recall it later

---

## Step 3: Capture a Frame (Programmatic)

```typescript
import { saveFrame, getDb, closeDb } from "lex";

const db = getDb("./memory.db");

const frame = await saveFrame(db, {
  referencePoint: "implementing modern password hashing",
  summaryCaption: "Refactored password hashing to use bcrypt",
  statusSnapshot: {
    nextAction: "Remove LegacyAuth references from gateway",
    blockers: ["Gateway still imports legacy-auth - forbidden edge"],
  },
  moduleScope: ["services/auth-core", "services/api-gateway"],
  branch: "feature/modern-auth",
  jira: "AUTH-456",
  keywords: ["authentication", "security", "bcrypt"],
});

console.log(`✓ Frame captured: ${frame.id}`);
console.log(`  Modules: ${frame.moduleScope.join(", ")}`);

closeDb(db);
```

**Output:**
```
✓ Frame captured: frame_abc123
  Modules: services/auth-core, services/api-gateway
```

---

## Step 4: Check Policy Compliance

Create a `merged-facts.json` (normally generated by scanners):

```json
{
  "calls": [
    {
      "from": "services/api-gateway",
      "to": "services/auth-core",
      "locations": [{ "file": "src/gateway/auth.ts", "line": 42 }]
    },
    {
      "from": "services/auth-core",
      "to": "services/legacy-auth",
      "locations": [{ "file": "src/services/auth/helpers.ts", "line": 18 }]
    }
  ],
  "symbols": [
    {
      "module": "services/legacy-auth",
      "type": "class",
      "name": "LegacyAuthProvider",
      "location": { "file": "src/services/legacy/provider.ts", "line": 10 }
    }
  ]
}
```

Run the policy check:

```bash
lex check merged-facts.json lexmap.policy.json
```

**Output (Receipt):**
```
❌ Policy violations found:

[FORBIDDEN_EDGE]
  From: services/auth-core
  To:   services/legacy-auth
  File: src/services/auth/helpers.ts:18

  Reason: services/auth-core lists services/legacy-auth in forbiddenDeps

  Fix: Remove this dependency and use the modern auth primitives

[KILL_PATTERN]
  Module: services/legacy-auth
  Symbol: LegacyAuthProvider (class)
  File:   src/services/legacy/provider.ts:10

  Pattern: "LegacyAuth*"
  Reason: This module is being sunset; no new references allowed

  Fix: Migrate to services/auth-core

Summary:
  2 violations
  0 warnings

Exit code: 1
```

**What happened:**
- Lex compared the code facts against policy rules
- It found a **forbidden edge** (auth-core → legacy-auth)
- It found a **kill pattern** match (LegacyAuthProvider)
- This is your **policy receipt**—proof of what failed and why

---

## Step 5: Recall Your Work

Later, when you (or an assistant) want to continue:

```bash
lex recall "modern auth"
```

**Output:**
```
Found 1 matching frame:

[frame_abc123] feature/modern-auth
  Summary: Refactored password hashing to use bcrypt
  Jira:    AUTH-456
  Modules: services/auth-core, services/api-gateway

  Next Action:
    Remove LegacyAuth references from gateway

  Blockers:
    - Gateway still imports legacy-auth - forbidden edge

  Atlas Frame (fold radius = 1):
    services/auth-core
      ├─ allowed callers: services/api-gateway ✓
      ├─ forbidden deps: services/legacy-auth ❌
      └─ required perms: (none)

    services/api-gateway
      ├─ allowed deps: services/auth-core ✓
      └─ current status: calls auth-core (OK), calls legacy-auth (FORBIDDEN)
```

**What happened:**
- Lex found your Frame by keyword search
- It showed the **module neighborhood** (Atlas Frame with fold radius = 1)
- You can see allowed/forbidden edges, blockers, and next steps
- This is **continuity with proof**—you know exactly where you left off

---

## Step 6: Programmatic Recall

```typescript
import { searchFrames, getDb, closeDb } from "lex";

const db = getDb("./memory.db");

const frames = await searchFrames(db, {
  referencePoint: "modern auth",
  limit: 5,
});

frames.forEach((frame) => {
  console.log(`\n[${frame.id}] ${frame.branch}`);
  console.log(`  ${frame.summaryCaption}`);
  console.log(`  Next: ${frame.statusSnapshot.nextAction}`);

  if (frame.statusSnapshot.blockers?.length > 0) {
    console.log(`  Blockers:`);
    frame.statusSnapshot.blockers.forEach((b) => {
      console.log(`    - ${b}`);
    });
  }
});

closeDb(db);
```

---

## Step 7: Policy Explanation (Programmatic)

```typescript
import { loadPolicy } from "lex/shared/policy";
import { explainEdge } from "lex/shared/atlas";

const policy = loadPolicy("./lexmap.policy.json");

const explanation = explainEdge(policy, "services/auth-core", "services/legacy-auth");

console.log(explanation);
/*
Output:
{
  allowed: false,
  reason: "services/legacy-auth is in forbiddenDeps for services/auth-core",
  recommendation: "Remove this dependency; services/legacy-auth is being sunset",
  killPatterns: ["LegacyAuth*", "OldPasswordHash*"]
}
*/
```

---

## Receipt Summary

### Memory Receipt (Frame)
- **Input**: Your work session (code, blockers, next steps)
- **Output**: Timestamped Frame with module scope and Atlas neighborhood
- **Proof**: You can recall exactly where you left off

### Policy Receipt (Check)
- **Input**: Code facts (calls, symbols) + policy rules
- **Output**: Violations with file locations and reasons
- **Proof**: Audit trail of what broke policy and why

### Continuity Receipt (Recall + Explain)
- **Input**: Search query or Jira ticket
- **Output**: Matching frames with context and policy explanations
- **Proof**: You and your assistant see the same architectural constraints

---

## Expected Output Format

All receipts follow this structure:

```
RECEIPT: <operation>
  Input: <what you asked for>
  Gate: <what checked it>
  Output: <what was found>
  Verdict: PASS | FAIL
  Next Steps: <actionable items>
```

This format appears in:
- CLI output (human-readable)
- CI logs (structured JSON)
- Atlas Frames (embedded in recall results)

**RECEIPT_OK** is the token we assert in smoke tests to confirm receipts are working end-to-end.

---

## Next Steps

- Integrate `lex check` into CI to enforce policy on every PR
- Use `lex remember` at meaningful milestones (end of session, before context switch)
- Use `lex recall` to resume work or hand off to assistants
- Check [CONTRIBUTING.md](./CONTRIBUTING.md) for development setup
- See [docs/ARCHITECTURE_LOOP.md](./docs/ARCHITECTURE_LOOP.md) for the full explainability story
