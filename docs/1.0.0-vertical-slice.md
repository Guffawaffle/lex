# Lex 1.0.0 — Vertical Slice & Architectural Contracts

> **Status:** Active
> **Created:** 2025-11-27
> **Chief Architect Review:** Completed

This document defines what "1.0.0" means for Lex: the contracts, the happy path, the tests, and the risks we're tracking.

---

## A. Store Contracts (FrameStore)

**Contract Location:** [`src/memory/store/CONTRACT.md`](../src/memory/store/CONTRACT.md)

### Key Points

- **Schema Version:** `FRAME_STORE_SCHEMA_VERSION = "1.0.0"`
- **ID Format:** ULID (lexicographically sortable)
- **Timestamp Format:** ISO 8601 UTC
- **Lifecycle:** `created → active → archived`

### Required Fields

| Field | Type |
|-------|------|
| `id` | ULID |
| `timestamp` | ISO 8601 |
| `reference_point` | string |
| `summary_caption` | string |
| `status_snapshot` | object |

### Change Protocol

Any changes require:
1. Schema migration plan
2. Version bump (SemVer)
3. Cross-repo notification (LexRunner)
4. Chief Architect approval

---

## B. Vertical Slice — Lex + LexRunner

The single happy path that MUST work before 1.0.0 ships:

### The 4-Step Flow

1. **User runs CLI command** (in LexRunner)
   - Command: `lex-pr-runner run --plan plan.json`
   - Creates a Run record

2. **Run persists via RunStore** (in LexRunner)
   - `SqliteRunStore.createRun()` called
   - Run state: `pending → running`

3. **Lex + FrameStore used for memory/policy**
   - Frames created/retrieved via `FrameStore`
   - Policy rules applied from Lex canon
   - Mode enforcement active

4. **Minimal transcript printed**
   - Human-readable summary of what happened
   - Run ID, gates executed, final state

### Re-Run Behavior

When user runs again:
- Previous Run is visible via `listRuns()`
- New Run gets fresh ID
- Frame references consistent (same Frame ID = same Frame)

### Hot-Path PRs (Scoped to This Slice ONLY)

| PR | Scope |
|----|-------|
| #364 | Wire MCP server to FrameStore |
| #365 | Wire CLI commands to FrameStore |

**Everything else is post-1.0.0.**

---

## C. Red Line Tests — Lex

These are the architectural canaries. If they fail, something foundational broke.

### 1. Store Contract Invariant Test

**Location:** `test/memory/store/contract.spec.ts`

Tests:
- [ ] `saveFrame()` persists and is retrievable
- [ ] `getFrameById()` returns null for missing (no throw)
- [ ] `searchFrames()` returns empty array for no matches
- [ ] `listFrames()` respects limit/offset
- [ ] `close()` is idempotent

### 2. Mode/Policy Grounding Test

**Location:** `test/policy/grounding.spec.ts`

Tests:
- [ ] Policy rules are loaded from canon
- [ ] Mode enforcement rejects invalid tool calls
- [ ] Changes to policy in Lex propagate correctly

---

## D. Quiet Risks to Monitor

These aren't blockers, but the Chief Architect should hold them in mind:

### 1. Interface Drift (FrameStore ↔ RunStore)

**Risk:** Lex and LexRunner evolve "almost together but not quite."

**Mitigation:**
- Cross-repo mapping documented in CONTRACT.md
- Shared concepts use same formats (ULID, ISO 8601)
- Changes require cross-repo notification

### 2. Schema Migration / Versioning

**Risk:** Post-1.0.0, "blow away DB" stops being acceptable.

**Mitigation:**
- Version field in schema
- Clear error on version mismatch
- Migration path documented (even if "reset" for now)

### 3. 12 Parallel Agents on Fresh Abstractions

**Risk:** Agent PRs want to tweak the new interfaces.

**Mitigation:**
- Treat stores as **read-only surfaces** for this wave
- Interface changes = soft red flag, require approval
- Contract docs are the source of truth

### 4. Tool-Grounded Mode Enforcement Coupling

**Risk:** Subtle policy/mode changes in Lex create invisible LexRunner behavior shifts.

**Mitigation:**
- Policy/mode tweaks in Lex need LexRunner regression test
- Mode enforcement tests are red-line canaries

---

## E. Post-1.0.0 Backlog

Items explicitly deferred:

- Full migration framework (numbered SQL files)
- Multi-database support
- FrameStore cloud/remote drivers
- Performance benchmarks
- Schema validation on startup

---

**Next Steps:**
1. Complete hot-path PRs (#364, #365)
2. Add red-line tests
3. Validate vertical slice end-to-end
4. Tag 1.0.0
